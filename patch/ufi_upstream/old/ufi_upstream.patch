diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000000..56a35cf58d2
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,101 @@
+# Contributing to msm8916-mainline/linux
+Thanks for your interest in contributing to msm8916-mainline/linux! :tada:
+
+## About
+[msm8916-mainline/linux] is a fork of the [mainline Linux kernel](https://kernel.org)
+(released by Linus Torvalds). Goal of the repository is to **temporarily** host
+**work-in-progress** changes for various devices based on the
+Qualcomm Snapdragon 410/412 (MSM8916) SoC.
+
+Once ready, changes should be [submitted upstream](https://www.kernel.org/doc/html/latest/process/submitting-patches.html)
+through the appropriate mailing lists.  
+**Changes submitted in this repository will not automatically land upstream!**
+
+**Note:** This fork is **unofficial** and not (directly) affiliated to the mainline
+Linux project. As such, it is entirely **optional** to submit your changes as
+pull request to this repository. You can also immediately send your changes
+upstream to the appropriate mailing lists. Submitting your changes here (before
+sending them upstream) has the following advantages:
+
+  - **Preliminary review:** You get early feedback on your patches which may
+    speed up submission of your patch upstream later.
+    **Note:** Acceptance of your patch in this repository does not mean that
+    the upstream maintainers will accept it!
+
+  - **Kept up-to-date:** All patches in this repository will be rebased to newer
+    upstream Linux releases, so your device will be always up-to-date even with
+    some work-in-progress changes.
+
+  - **Packaged in [postmarketOS]:** This fork is the source of the
+    `linux-postmarketos-qcom-msm8916` package in postmarketOS, which is used by
+    all MSM8916 devices based on the mainline kernel. Your changes will be
+    included in the next release and therefore show up in postmarketOS.
+
+## Patch Requirements
+Goal for all patches in this repository is to upstream them eventually. Therefore,
+the formal requirements are similar to upstream, e.g.:
+
+  - No compile warnings/errors
+  - Clean code style
+  - Changes separated into clean commits (one per logical change/subsystem)
+  - Appropriate commit message that explains the motivation for the change
+
+If you want to contribute to this repository, you should be willing to bring your
+patches into suitable shape for upstreaming. Most of this is documented upstream
+in [Submitting patches]. Don't worry if you don't get it exactly right the first time. :)
+
+### Sign off your patches - the Developer's Certificate of Origin
+Upstream contributions to the Linux kernel are required to have the following
+tag in the commit message:
+
+```
+Signed-off-by: FirstName LastName <your-email@example.com>
+```
+
+These tags are also required when contributing to this repository. Reason for
+this is that you might become busy at some point, or your interests change. Then
+it is important that someone else can pick up your work and finish it up.
+
+Please read [Sign your work - the Developerâ€™s Certificate of Origin](https://www.kernel.org/doc/html/latest/process/submitting-patches.html#sign-your-work-the-developer-s-certificate-of-origin)
+**carefully** to understand the meaning of the `Signed-off-by:`.
+It also explains how to add it easily when creating new commits.
+
+## Upstreaming
+Upstreaming changes takes time. And sometimes, changes cannot be submitted
+upstream yet because they are work-in-progress or because there are fundamental
+open problems that cannot be solved immediately, e.g.:
+
+  - Weird issues where the actual cause cannot be determined at the moment ("hacks").
+  - New drivers with problems in some edge cases.
+  - Panel drivers that are mostly auto-generated and that are hard to document
+    properly because of lack of documentation.
+  - Battery/charging drivers that are hard to validate without expert knowledge.
+
+If you have something (mostly) working and the [formal patch requirements](#patch-requirements)
+are met, then it's good to share it with others in this repository.
+
+However, keep in mind that maintaining a large amount of patches in this
+repository consumes a significant amount of time, especially when breaking
+changes are made upstream. This means less time to review new patches
+or to work on improvements everyone can benefit from.
+
+**Please help to keep maintenance time at an acceptable level by submitting your
+patches upstream when they are ready.** If you are not sure if your patches are
+ready, just ask and we can discuss it.
+
+### Patches that touch upstream files
+Patches that touch upstream files which are frequently updated
+(e.g. existing, shared drivers instead of files specific to your device)
+should be submitted upstream before they are merged into this repository.
+This is because those tend to cause conflicts much more frequently when updating
+to newer kernel versions.
+
+This is just a guideline to reduce maintenance, exceptions can be made if necessary.
+
+## Questions
+If you have any questions, feel free to ask in the [postmarketOS mainline channel
+on Matrix or IRC](https://wiki.postmarketos.org/wiki/Matrix_and_IRC).
+
+[msm8916-mainline/linux]: https://github.com/msm8916-mainline/linux
+[postmarketOS]: https://postmarketos.org
+[Submitting patches]: https://www.kernel.org/doc/html/latest/process/submitting-patches.html
diff --git a/Documentation/devicetree/bindings/input/touchscreen/mstar,msg2638.yaml b/Documentation/devicetree/bindings/input/touchscreen/mstar,msg2638.yaml
index 3a42c23faf6..af4f954de95 100644
--- a/Documentation/devicetree/bindings/input/touchscreen/mstar,msg2638.yaml
+++ b/Documentation/devicetree/bindings/input/touchscreen/mstar,msg2638.yaml
@@ -14,7 +14,9 @@ allOf:
 
 properties:
   compatible:
-    const: mstar,msg2638
+    enum:
+      - mstar,msg2138
+      - mstar,msg2638
 
   reg:
     const: 0x26
@@ -34,6 +36,10 @@ properties:
   touchscreen-size-x: true
   touchscreen-size-y: true
 
+  linux,keycodes:
+    minItems: 1
+    maxItems: 4
+
 additionalProperties: false
 
 required:
diff --git a/Documentation/devicetree/bindings/power/supply/smb1360.yaml b/Documentation/devicetree/bindings/power/supply/smb1360.yaml
new file mode 100644
index 00000000000..a90eede1fab
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/supply/smb1360.yaml
@@ -0,0 +1,271 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/power/supply/smb1360.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Qualcomm SMB1360 charger and fuel gauge
+
+maintainers:
+  - Jonathan Albrieux <jonathan.albrieux@gmail.com>
+
+description: |
+  Port for Qualcomm SMB1360 charger and fuel gauge downstream driver.
+
+  A brief overview of the chip can be found at:
+    https://www.qualcomm.com/products/quick-charge-10
+
+  Original code can be found at:
+    https://github.com/msm8916-mainline/android_kernel_qcom_msm8916/blob/master/drivers/power/smb1360-charger-fg.c
+
+properties:
+  compatible:
+    enum:
+      - qcom,smb1360
+
+  reg:
+    description: I2C address of the charger.
+
+  interrupts:
+    description:
+      IRQ number of the GPIO connected to the STAT pin.
+
+  qcom,rsense-10mohm:
+    type: boolean
+    description:
+      Indicates the Rsense resistor configuration.
+      If set, the Rsense is 10mOhm else it's 20mOhm.
+
+  qcom,float-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The maximum voltage up to which the battery is charged.
+      This value is in mV.
+
+  qcom,iterm-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the termination current to indicate end-of-charge.
+      Possible values in 25, 50, 75, 100, 125, 150, 175 and 200mA
+
+  qcom,charging-timeout:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Maximum duration in minutes that a single charge cycle may last.
+      Supported values are 0, 192, 384, 768, and 1536. A value of 0 means that
+      no charge cycle timeout is used and charging can continue indefinitely.
+
+  qcom,recharge-thresh-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the minimum voltage drop in millivolts below the float voltage
+      that is required in order to initiate a new charging cycle.
+      Supported values are 50, 100, 200 and 300mV.
+
+  qcom,chg-inhibit-disabled:
+    type: boolean
+    description:
+      Disables the charger-inhibit function.
+
+  qcom,battery-profile:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the battery profile to use.
+      0 is for profile A, 1 is for profile B.
+    enum: [0,1]
+
+  qcom,fg-batt-capacity-mah:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The new battery capacity to be supported.
+      This updates the ACTUAL and NOMINAL CAPACITY of the profile.
+
+  qcom,fg-cc-soc-coeff:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The CC_TO_SOC_COEFF of the new battery capacity.
+      This value is calculated from the batt-capacity and then encoded
+      as floating number. cc_soc_coeff = HALF_ENCODING(8192 / batt-capacity)
+
+  qcom,fg-cutoff-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the minimum allowed system voltage. The FG will report
+      SOC = 0 at this voltage. This value is in mV.
+
+  qcom,fg-iterm-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is termination current at which the Monotonic SOC reports 100.
+      The value passed here is negated in the driver (assuming that the iterm
+      is always -ve). This value is in mA.
+
+  qcom,fg-ibatt-standby-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the minimum current value for the SOC to be above 0% at
+      the cutoff voltage. This value is in mA.
+
+  qcom,fg-cc-to-cv-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the voltage at which the FG transitions from CC to CV.
+      This value should never be higher than the float voltage. This
+      value is in mV.
+
+  qcom,thermistor-c1-coeff:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the NTC thermistor C1 coeff for the thermistor inside
+      the battery. This value is 16-bit float encoded value determined from the
+      NTC-c1_coeff mapping.
+
+  qcom,fg-auto-recharge-soc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Defines the auto recharging SOC threshold.
+
+  qcom,otp-hard-jeita-config:
+    type: boolean
+    description:
+      Indicates if cold and hot thresholds need be modified.
+      If it's not defined, default temp thresholds [0, 55] will be used.
+
+  qcom,otp-hot-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Hot battery temperature in decidegC.
+
+  qcom,otp-cold-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Cold battery temperature in decidegC.
+
+  qcom,soft-jeita-config:
+    type: boolean
+    description:
+      Indicates if soft JEITA compensation should be enabled. When the soft
+      temperature limits are reached, the maximum voltage up to which battery
+      is charged is reduced and charging current is limited.
+
+  qcom,warm-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Warm battery temperature in decidegC.
+
+  qcom,cool-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Cool battery temperature in decidegC.
+
+  qcom,soft-jeita-comp-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The battery target voltage that is used when the soft temperature
+      thresholds are reached.
+
+  qcom,soft-jeita-comp-current-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The maximum charging current used when the soft temperature thresholds
+      are reached.
+
+  qcom,shdn-after-pwroff:
+    type: boolean
+    description:
+      Configure smb1360 for shutdown at power-off.
+
+  qcom,fg-reset-at-pon:
+    type: boolean
+    description:
+      Indicates if the FG reset at power-on is enabled.
+
+  qcom,fg-reset-threshold-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Indicates the voltage threshold to reset the FG. It is compared against
+      the difference between in predicted voltage and current voltage.
+      If this value is not specified a default value of 50mV is used.
+      Unit is in milli-volts.
+
+  qcom,otp-rslow-config:
+    $ref: /schemas/types.yaml#/definitions/uint8-array
+    description:
+      Undocumented feature found on some devices as "qcom,otp-rslow-cfg".
+      Each item is a value keyed respectively to 0x54, 0x55, 0x56 and 0x57
+      and written to OTP.
+    minItems: 4
+    maxItems: 4
+
+  usb_otg_vbus:
+    description: Regulator controlling USB OTG VBUS.
+    # TODO: Reference regulator-max-microamps here somehow?
+
+dependencies:
+  qcom,otp-hard-jeita-config: [ 'qcom,otp-hot-bat-decidegc', 'qcom,otp-cold-bat-decidegc' ]
+  qcom,otp-hot-bat-decidegc: [ 'qcom,otp-hard-jeita-config' ]
+  qcom,otp-cold-bat-decidegc: [ 'qcom,otp-hard-jeita-config' ]
+  qcom,fg-cc-soc-coeff: [ 'qcom,fg-batt-capacity-mah' ]
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      charger: battery@14 {
+        compatible = "qcom,smb1360";
+        reg = <0x14>;
+
+        interrupt-parent = <&msmgpio>;
+        interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+        pinctrl-names = "default";
+        pinctrl-0 = <&smb_int_default>;
+
+        qcom,rsense-10mohm;
+
+        qcom,float-voltage-mv = <4400>;
+        qcom,iterm-ma = <100>;
+        qcom,charging-timeout = <192>;
+        qcom,recharge-thresh-mv = <50>;
+        qcom,chg-inhibit-disabled;
+
+        qcom,battery-profile = <0>;
+
+        qcom,fg-batt-capacity-mah = <2810>;
+        qcom,fg-cc-soc-coeff = <0x81D5>;
+        qcom,fg-cutoff-voltage-mv = <3400>;
+        qcom,fg-iterm-ma = <100>;
+        qcom,fg-ibatt-standby-ma = <200>;
+        qcom,fg-cc-to-cv-mv = <4397>;
+        qcom,thermistor-c1-coeff = <0x86C2>;
+        qcom,fg-auto-recharge-soc = <97>;
+
+        qcom,otp-hard-jeita-config;
+        qcom,otp-hot-bat-decidegc = <500>;
+        qcom,otp-cold-bat-decidegc = <(-50)>;
+
+        qcom,soft-jeita-config;
+        qcom,warm-bat-decidegc = <450>;
+        qcom,cool-bat-decidegc = <100>;
+        qcom,soft-jeita-comp-voltage-mv = <4000>;
+        qcom,soft-jeita-comp-current-ma = <600>;
+
+        qcom,shdn-after-pwroff;
+        qcom,fg-reset-at-pon;
+        qcom,fg-reset-threshold-mv = <200>;
+
+        usb_otg_vbus: usb-otg-vbus {
+          regulator-max-microamp = <1500000>;
+        };
+      };
+    };
diff --git a/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml b/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml
new file mode 100644
index 00000000000..ebdf128b066
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml
@@ -0,0 +1,109 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/soc/qcom/qcom,memshare.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Qualcomm QMI Shared Memory Service
+
+description: |
+  This driver provides a QMI service that allows remote processors (like modem)
+  to request additional memory. It is used for applications like GPS in modem.
+
+maintainers:
+  - Nikita Travkin <nikitos.tr@gmail.com>
+
+properties:
+  compatible:
+    const: qcom,memshare
+
+  qcom,legacy-client:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: Phandle to a memshare client node used for legacy requests.
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 0
+
+patternProperties:
+  "^.*@[0-9]+$":
+    type: object
+
+    properties:
+      reg:
+        description: Proc-ID for clients in this node.
+
+      qcom,qrtr-node:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description: Node from which the requests are expected.
+
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+    patternProperties:
+      "^.*@[0-9]+$":
+        type: object
+
+        properties:
+          reg:
+            description: ID of this client.
+
+          memory-region:
+            $ref: /schemas/types.yaml#/definitions/phandle
+            description: |
+              Reserved memory region that should be used for allocation.
+
+        required:
+          - reg
+
+    required:
+      - reg
+      - qcom,qrtr-node
+
+required:
+  - compatible
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/soc/qcom,memshare.h>
+
+    reserved-memory {
+
+      #address-cells = <2>;
+      #size-cells = <2>;
+
+      gps_mem: gps@93c00000 {
+        reg = <0x0 0x93c00000 0x0 0x200000>;
+        no-map;
+      };
+    };
+
+    memshare {
+      compatible = "qcom,memshare";
+      qcom,legacy-client = <&memshare_gps>;
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      mpss@0 {
+        reg = <MEMSHARE_PROC_MPSS_V01>;
+        qcom,qrtr-node = <0>;
+
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        memshare_gps: gps@0 {
+          reg = <0>;
+          memory-region = <&gps_mem>;
+        };
+      };
+    };
+
+...
diff --git a/MAINTAINERS b/MAINTAINERS
index edc32575828..9e457daed04 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -15485,6 +15485,14 @@ S:	Supported
 W:	https://wireless.wiki.kernel.org/en/users/Drivers/ath9k
 F:	drivers/net/wireless/ath/ath9k/
 
+QUALCOMM BAM-DMUX WWAN NETWORK DRIVER
+M:	Stephan Gerhold <stephan@gerhold.net>
+L:	netdev@vger.kernel.org
+L:	linux-arm-msm@vger.kernel.org
+S:	Maintained
+F:	Documentation/devicetree/bindings/net/qcom,bam-dmux.yaml
+F:	drivers/net/wwan/qcom_bam_dmux.c
+
 QUALCOMM CAMERA SUBSYSTEM DRIVER
 M:	Robert Foss <robert.foss@linaro.org>
 M:	Todor Tomov <todor.too@gmail.com>
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index a8ae17f5740..0da81e97391 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -5,6 +5,7 @@ config ARM
 	select ARCH_32BIT_OFF_T
 	select ARCH_HAS_BINFMT_FLAT
 	select ARCH_HAS_DEBUG_VIRTUAL if MMU
+	select ARCH_HAS_DMA_PREP_COHERENT if IOMMU_DMA
 	select ARCH_HAS_DMA_WRITE_COMBINE if !ARM_DMA_MEM_BUFFERABLE
 	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_FORTIFY_SOURCE
@@ -18,8 +19,8 @@ config ARM
 	select ARCH_HAS_SET_MEMORY
 	select ARCH_HAS_STRICT_KERNEL_RWX if MMU && !XIP_KERNEL
 	select ARCH_HAS_STRICT_MODULE_RWX if MMU
-	select ARCH_HAS_SYNC_DMA_FOR_DEVICE if SWIOTLB || !MMU
-	select ARCH_HAS_SYNC_DMA_FOR_CPU if SWIOTLB || !MMU
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE if SWIOTLB || !MMU || IOMMU_DMA
+	select ARCH_HAS_SYNC_DMA_FOR_CPU if SWIOTLB || !MMU || IOMMU_DMA
 	select ARCH_HAS_TEARDOWN_DMA_OPS if MMU
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
 	select ARCH_HAVE_CUSTOM_GPIO_H
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 7a72fc636a7..f75639bb8f7 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -941,6 +941,7 @@ dtb-$(CONFIG_ARCH_OXNAS) += \
 	ox810se-wd-mbwe.dtb \
 	ox820-cloudengines-pogoplug-series-3.dtb
 dtb-$(CONFIG_ARCH_QCOM) += \
+	qcom-apq8016-sbc.dtb \
 	qcom-apq8060-dragonboard.dtb \
 	qcom-apq8064-cm-qs600.dtb \
 	qcom-apq8064-ifc6410.dtb \
@@ -961,6 +962,7 @@ dtb-$(CONFIG_ARCH_QCOM) += \
 	qcom-ipq8064-rb3011.dtb \
 	qcom-msm8226-samsung-s3ve3g.dtb \
 	qcom-msm8660-surf.dtb \
+	qcom-msm8916-samsung-serranove.dtb \
 	qcom-msm8960-cdp.dtb \
 	qcom-msm8974-fairphone-fp2.dtb \
 	qcom-msm8974-lge-nexus5-hammerhead.dtb \
diff --git a/arch/arm/boot/dts/qcom-apq8016-sbc.dts b/arch/arm/boot/dts/qcom-apq8016-sbc.dts
new file mode 100644
index 00000000000..bf9cd1ba67b
--- /dev/null
+++ b/arch/arm/boot/dts/qcom-apq8016-sbc.dts
@@ -0,0 +1 @@
+#include "arm64/qcom/apq8016-sbc.dts"
diff --git a/arch/arm/boot/dts/qcom-msm8916-samsung-serranove.dts b/arch/arm/boot/dts/qcom-msm8916-samsung-serranove.dts
new file mode 100644
index 00000000000..dee2c20af35
--- /dev/null
+++ b/arch/arm/boot/dts/qcom-msm8916-samsung-serranove.dts
@@ -0,0 +1,3 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include "arm64/qcom/msm8916-samsung-serranove.dts"
+#include "qcom-msm8916-smp.dtsi"
diff --git a/arch/arm/boot/dts/qcom-msm8916-smp.dtsi b/arch/arm/boot/dts/qcom-msm8916-smp.dtsi
new file mode 100644
index 00000000000..36328dbe421
--- /dev/null
+++ b/arch/arm/boot/dts/qcom-msm8916-smp.dtsi
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/ {
+	cpus {
+		cpu@0 {
+			enable-method = "qcom,msm8916-smp";
+		};
+		cpu@1 {
+			enable-method = "qcom,msm8916-smp";
+		};
+		cpu@2 {
+			enable-method = "qcom,msm8916-smp";
+		};
+		cpu@3 {
+			enable-method = "qcom,msm8916-smp";
+		};
+
+		idle-states {
+			/delete-property/ entry-method;
+		};
+	};
+
+	psci {
+		status = "disabled";
+	};
+};
+
+&CPU_SLEEP_0 {
+	compatible = "qcom,idle-state-spc";
+};
+
+&cpu0_acc {
+	status = "okay";
+};
+
+&cpu0_saw {
+	status = "okay";
+};
+
+&cpu1_acc {
+	status = "okay";
+};
+
+&cpu1_saw {
+	status = "okay";
+};
+
+&cpu2_acc {
+	status = "okay";
+};
+
+&cpu2_saw {
+	status = "okay";
+};
+
+&cpu3_acc {
+	status = "okay";
+};
+
+&cpu3_saw {
+	status = "okay";
+};
diff --git a/arch/arm/configs/.gitignore b/arch/arm/configs/.gitignore
new file mode 100644
index 00000000000..1cd39ba800c
--- /dev/null
+++ b/arch/arm/configs/.gitignore
@@ -0,0 +1,2 @@
+# This is dynamically built from the arm64 one (see msm8916_defconfig.part)
+msm8916_defconfig
diff --git a/arch/arm/configs/msm8916_defconfig.part b/arch/arm/configs/msm8916_defconfig.part
new file mode 100644
index 00000000000..8da5974424c
--- /dev/null
+++ b/arch/arm/configs/msm8916_defconfig.part
@@ -0,0 +1,32 @@
+# Build the full configuration by running
+# cat arch/arm64/configs/msm8916_defconfig arch/arm/configs/msm8916_defconfig.part > arch/arm/configs/msm8916_defconfig
+
+CONFIG_PERF_EVENTS=y
+CONFIG_ARCH_MSM8916=y
+CONFIG_SMP=y
+CONFIG_ARM_PSCI=y
+CONFIG_HZ_250=y
+CONFIG_HIGHMEM=y
+# CONFIG_ATAGS is not set
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_ARM_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM_NEON=y
+CONFIG_CRYPTO_SHA1_ARM_CE=y
+CONFIG_CRYPTO_SHA2_ARM_CE=y
+CONFIG_CRYPTO_SHA512_ARM=m
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_CRYPTO_AES_ARM_BS=y
+CONFIG_CRYPTO_AES_ARM_CE=y
+CONFIG_CRYPTO_GHASH_ARM_CE=y
+CONFIG_CRYPTO_CRC32_ARM_CE=y
+CONFIG_GPIOLIB=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_SHA3=m
+CONFIG_CRYPTO_SM3=m
+CONFIG_CRYPTO_SM4=m
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_SMMU is not set
diff --git a/arch/arm/mach-qcom/Kconfig b/arch/arm/mach-qcom/Kconfig
index 1772eccb5ca..92ec4a5c7f8 100644
--- a/arch/arm/mach-qcom/Kconfig
+++ b/arch/arm/mach-qcom/Kconfig
@@ -21,6 +21,17 @@ config ARCH_MSM8X60
 	bool "Enable support for MSM8X60"
 	select CLKSRC_QCOM
 
+config ARCH_MSM8916
+	bool "Enable support for MSM8916"
+	select HAVE_ARM_ARCH_TIMER
+	select IOMMU_DMA
+	help
+	  Enable support for the Qualcomm Snapdragon 410 (MSM8916/APQ8016).
+
+	  Note that ARM64 is the main supported architecture for MSM8916.
+	  The ARM32 option is intended for a few devices with signed firmware
+	  that does not allow booting ARM64 kernels.
+
 config ARCH_MSM8960
 	bool "Enable support for MSM8960"
 	select CLKSRC_QCOM
diff --git a/arch/arm/mach-qcom/platsmp.c b/arch/arm/mach-qcom/platsmp.c
index 630a038f451..58a4228455c 100644
--- a/arch/arm/mach-qcom/platsmp.c
+++ b/arch/arm/mach-qcom/platsmp.c
@@ -29,6 +29,7 @@
 #define COREPOR_RST		BIT(5)
 #define CORE_RST		BIT(4)
 #define L2DT_SLP		BIT(3)
+#define CORE_MEM_CLAMP		BIT(1)
 #define CLAMP			BIT(0)
 
 #define APC_PWR_GATE_CTL	0x14
@@ -75,6 +76,62 @@ static int scss_release_secondary(unsigned int cpu)
 	return 0;
 }
 
+static int cortex_a7_release_secondary(unsigned int cpu)
+{
+	int ret = 0;
+	void __iomem *reg;
+	struct device_node *cpu_node, *acc_node;
+	u32 reg_val;
+
+	cpu_node = of_get_cpu_node(cpu, NULL);
+	if (!cpu_node)
+		return -ENODEV;
+
+	acc_node = of_parse_phandle(cpu_node, "qcom,acc", 0);
+	if (!acc_node) {
+		ret = -ENODEV;
+		goto out_acc;
+	}
+
+	reg = of_iomap(acc_node, 0);
+	if (!reg) {
+		ret = -ENOMEM;
+		goto out_acc_map;
+	}
+
+	/* Put the CPU into reset. */
+	reg_val = CORE_RST | COREPOR_RST | CLAMP | CORE_MEM_CLAMP;
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+
+	/* Turn on the BHS and set the BHS_CNT to 16 XO clock cycles */
+	writel(BHS_EN | (0x10 << BHS_CNT_SHIFT), reg + APC_PWR_GATE_CTL);
+	/* Wait for the BHS to settle */
+	udelay(2);
+
+	reg_val &= ~CORE_MEM_CLAMP;
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+	reg_val |= L2DT_SLP;
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+	udelay(2);
+
+	reg_val = (reg_val | BIT(17)) & ~CLAMP;
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+	udelay(2);
+
+	/* Release CPU out of reset and bring it to life. */
+	reg_val &= ~(CORE_RST | COREPOR_RST);
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+	reg_val |= CORE_PWRD_UP;
+	writel(reg_val, reg + APCS_CPU_PWR_CTL);
+
+	iounmap(reg);
+out_acc_map:
+	of_node_put(acc_node);
+out_acc:
+	of_node_put(cpu_node);
+	return ret;
+}
+
 static int kpssv1_release_secondary(unsigned int cpu)
 {
 	int ret = 0;
@@ -281,6 +338,11 @@ static int msm8660_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return qcom_boot_secondary(cpu, scss_release_secondary);
 }
 
+static int cortex_a7_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	return qcom_boot_secondary(cpu, cortex_a7_release_secondary);
+}
+
 static int kpssv1_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	return qcom_boot_secondary(cpu, kpssv1_release_secondary);
@@ -315,6 +377,16 @@ static const struct smp_operations smp_msm8660_ops __initconst = {
 };
 CPU_METHOD_OF_DECLARE(qcom_smp, "qcom,gcc-msm8660", &smp_msm8660_ops);
 
+static const struct smp_operations qcom_smp_cortex_a7_ops __initconst = {
+	.smp_prepare_cpus	= qcom_smp_prepare_cpus,
+	.smp_boot_secondary	= cortex_a7_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= qcom_cpu_die,
+#endif
+};
+CPU_METHOD_OF_DECLARE(qcom_smp_msm8226, "qcom,msm8226-smp", &qcom_smp_cortex_a7_ops);
+CPU_METHOD_OF_DECLARE(qcom_smp_msm8916, "qcom,msm8916-smp", &qcom_smp_cortex_a7_ops);
+
 static const struct smp_operations qcom_smp_kpssv1_ops __initconst = {
 	.smp_prepare_cpus	= qcom_smp_prepare_cpus,
 	.smp_boot_secondary	= kpssv1_boot_secondary,
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 4b61541853e..73a351baffc 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/dma-direct.h>
+#include <linux/dma-iommu.h>
 #include <linux/dma-map-ops.h>
 #include <linux/highmem.h>
 #include <linux/memblock.h>
@@ -2266,10 +2267,13 @@ void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 	const struct dma_map_ops *dma_ops;
 
 	dev->archdata.dma_coherent = coherent;
-#ifdef CONFIG_SWIOTLB
+#if defined(CONFIG_SWIOTLB) || defined(CONFIG_IOMMU_DMA)
 	dev->dma_coherent = coherent;
 #endif
 
+	if (iommu)
+		iommu_setup_dma_ops(dev, dma_base, dma_base + size - 1);
+
 	/*
 	 * Don't override the dma_ops if they have already been set. Ideally
 	 * this should be the only location where dma_ops are set, remove this
@@ -2302,7 +2306,14 @@ void arch_teardown_dma_ops(struct device *dev)
 	set_dma_ops(dev, NULL);
 }
 
-#ifdef CONFIG_SWIOTLB
+#ifdef CONFIG_IOMMU_DMA
+void arch_dma_prep_coherent(struct page *page, size_t size)
+{
+	__dma_clear_buffer(page, size, NORMAL);
+}
+#endif
+
+#if defined(CONFIG_SWIOTLB) || defined(CONFIG_IOMMU_DMA)
 void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
 		enum dma_data_direction dir)
 {
diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index 70516508be5..b06d02fca52 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -1,4 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-samsung-gtelwifiue.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-samsung-matissevewifi.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-sbc.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= apq8094-sony-xperia-kitakami-karin_windy.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= apq8096-db820c.dtb
@@ -7,14 +9,33 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq6018-cp01-c1.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk01.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c1.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-alto5-vdf.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-ark-peach.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z010d.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-y635.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-lg-c50.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-lg-m216.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-longcheer-l8150.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-longcheer-l8910.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-motorola-harpia.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-motorola-osprey.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-motorola-surnia.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-mtp.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-oppo-a51f.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a3u-eur.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a5-zt.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a5u-eur.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gprime.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gt510.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gt58.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-j5.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-j5x.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-serranove.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt86518.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt86528.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt88047.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8992-bullhead-rev-101.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8992-msft-lumia-octagon-talkman.dtb
diff --git a/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts b/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts
new file mode 100644
index 00000000000..bba56a9eb6e
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts
@@ -0,0 +1,349 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Samsung Galaxy Tab E 9.6 (SM-T560NU)";
+	compatible = "samsung,gtelwifiue", "qcom,apq8016";
+	chassis-type = "tablet";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home {
+			label = "Home";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	reg_vdd_tsp: regulator-vdd-tsp {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_tsp";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&reg_tsp_en_default>;
+
+		startup-delay-us = <150>;
+	};
+
+	reg_lcd: regulator-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&reg_lcd_en_default>;
+
+		// FIXME: This breaks turning panel back on
+		regulator-always-on;
+		regulator-boot-on;
+		startup-delay-us = <150>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@1d {
+		compatible = "st,lis2hh12";
+		reg = <0x1d>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l5>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "INT1";
+
+		st,drdy-int-pin = <1>;
+		mount-matrix = "0", "1", "0",
+				  "-1", "0", "0",
+				   "0", "0", "1";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@20 {
+		compatible = "zinitix,zt7554", "zinitix,bt541";
+		reg = <0x20>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <1280>;
+		linux,keycodes = <KEY_APPSELECT KEY_BACK>;
+
+		vdd-supply = <&reg_vdd_tsp>;
+		vddo-supply = <&pm8916_l16>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_int_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	panel@0 {
+		compatible = "samsung,nt51017-b4p096wx5vp09";
+		reg = <0>;
+
+		lcd-supply = <&reg_lcd>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+// Wifi
+&pronto {
+	status = "okay";
+
+	iris {
+		compatible = "qcom,wcn3660b";
+	};
+};
+
+// EMMC
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+// SD Card slot
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	// FIXME: Replace with SM5703 MUIC when driver is available
+	extcon = <&pm8916_usbin>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	reg_lcd_en_default: reg-lcd-en-default {
+		pins = "gpio8";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	reg_tsp_en_default: reg-tsp-en-default {
+		pins = "gpio73";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_default: tsp-int-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts b/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts
new file mode 100644
index 00000000000..cd349b2914d
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts
@@ -0,0 +1,507 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	model = "Samsung Galaxy Tab 4 10.1 WiFi (2015) (SM-T533)";
+	compatible = "samsung,matissevewifi", "qcom,apq8016";
+	chassis-type = "tablet";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	speaker_codec: audio-codec {
+		compatible = "maxim,max98357a";
+		sdmode-gpios = <&msmgpio 100 GPIO_ACTIVE_HIGH>;
+		#sound-dai-cells = <0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home {
+			label = "Home";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	reg_lcd: regulator-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		/* FIXME: find why we have to force regulator on */
+		regulator-always-on;
+		regulator-boot-on;
+
+		gpio = <&msmgpio 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_en_default>;
+	};
+
+	reg_lvds: regulator-lvds {
+		compatible = "regulator-fixed";
+		regulator-name = "lvds";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		/* FIXME: see above */
+		regulator-always-on;
+		regulator-boot-on;
+
+		gpio = <&msmgpio 17 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_en_default>;
+	};
+
+	reg_tsp_1p8v: regulator-tsp-1p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_1p8v";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_en_default>;
+	};
+
+	reg_tsp_3p3v: regulator-tsp-3p3v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_3p3v";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 98 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_en1_default>;
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	muic: extcon@25 {
+		compatible = "siliconmitus,sm5502-muic";
+
+		reg = <0x25>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&muic_int_default>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@1d {
+		compatible = "st,lis2hh12";
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l5>;
+
+		reg = <0x1d>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "INT1";
+
+		st,drdy-int-pin = <1>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@4a {
+		compatible = "atmel,maxtouch";
+		reg = <0x4a>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&reg_tsp_1p8v>;
+		vdda-supply = <&reg_tsp_3p3v>;
+
+		reset-gpios = <&msmgpio 114 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_int_rst_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "samsung,tc358764-ltl101al06";
+		reg = <0>;
+
+		lcd-supply = <&reg_lcd>;
+		lvds-supply = <&reg_lvds>;
+		reset-gpios = <&msmgpio 31 GPIO_ACTIVE_LOW>;
+
+		clocks = <&gcc GCC_GP3_CLK>;
+		clock-names = "pwm";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&lpass {
+	status = "okay";
+
+	dai@3 {
+		reg = <MI2S_QUATERNARY>;
+		qcom,playback-sd-lines = <1>;
+	};
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pronto {
+	status = "okay";
+
+	iris {
+		compatible = "qcom,wcn3660b";
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &ext_sec_tlmm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &ext_sec_tlmm_lines_sus>;
+
+	model = "samsung-gt510";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&wcd_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&wcd_codec 1>;
+		};
+	};
+
+	dai-link-quaternary {
+		link-name = "Quaternary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_QUATERNARY>;
+		};
+		codec {
+			sound-dai = <&speaker_codec>;
+		};
+	};
+};
+
+&usb {
+	status = "okay";
+	extcon = <&muic>, <&muic>;
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&wcd_codec {
+	jack-gpios = <&msmgpio 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vtreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vtreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	jack_default: jack-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_en_default: lcd-en-default {
+		pins = "gpio8";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lvds_en_default: lvds-en-default {
+		pins = "gpio17";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio31";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio31";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	muic_int_default: muic-int-default {
+		pins = "gpio12";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en_default: tsp-en-default {
+		pins = "gpio73";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en1_default: tsp-en1-default {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_rst_default: tsp-int-rst-default {
+		pins = "gpio13", "gpio114";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/apq8016-sbc.dtsi b/arch/arm64/boot/dts/qcom/apq8016-sbc.dtsi
index f8d8f3e3664..0e4a1f00402 100644
--- a/arch/arm64/boot/dts/qcom/apq8016-sbc.dtsi
+++ b/arch/arm64/boot/dts/qcom/apq8016-sbc.dtsi
@@ -305,6 +305,12 @@ &mdss {
 	status = "okay";
 };
 
+&mpss {
+	status = "okay";
+
+	firmware-name = "qcom/apq8016/mba.mbn", "qcom/apq8016/modem.mbn";
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -312,6 +318,8 @@ &pm8916_resin {
 
 &pronto {
 	status = "okay";
+
+	firmware-name = "qcom/apq8016/wcnss.mbn";
 };
 
 &sdhc_1 {
@@ -394,6 +402,10 @@ &wcd_codec {
 	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
 };
 
+&wcnss_ctrl {
+	firmware-name = "qcom/apq8016/WCNSS_qcom_wlan_nv_sbc.bin";
+};
+
 /* Enable CoreSight */
 &cti0 { status = "okay"; };
 &cti1 { status = "okay"; };
diff --git a/arch/arm64/boot/dts/qcom/apq8094-sony-xperia-kitakami-karin_windy.dts b/arch/arm64/boot/dts/qcom/apq8094-sony-xperia-kitakami-karin_windy.dts
index a8dffc8c64e..314d2dc4726 100644
--- a/arch/arm64/boot/dts/qcom/apq8094-sony-xperia-kitakami-karin_windy.dts
+++ b/arch/arm64/boot/dts/qcom/apq8094-sony-xperia-kitakami-karin_windy.dts
@@ -11,6 +11,7 @@
 / {
 	model = "Sony Xperia Z4 Tablet (Wi-Fi)";
 	compatible = "sony,karin_windy", "qcom,apq8094";
+	chassis-type = "tablet";
 
 	/*
 	 * This model uses the APQ variant of MSM8994 (APQ8094).
diff --git a/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts b/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts
new file mode 100644
index 00000000000..dbde5f0c927
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Vodafone Smart prime 6 (alto5-vdf)";
+	compatible = "alcatel,alto5-vdf", "qcom,msm8916";
+	chassis-type = "handset";
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_HIGH>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts b/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
index 670bd1bebd7..b1a62cca36d 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
@@ -3,12 +3,16 @@
 /dts-v1/;
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "Alcatel OneTouch Idol 3 (4.7)";
 	compatible = "alcatel,idol347", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -18,6 +22,38 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	reserved-memory {
+		/delete-node/ rmtfs@86700000;
+		/delete-node/ reserved@86680000;
+
+		rmtfs: rmtfs@86680000 {
+			compatible = "qcom,rmtfs-mem";
+			reg = <0x0 0x86680000 0x0 0x160000>;
+			no-map;
+
+			qcom,client-id = <1>;
+		};
+
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5000000>;
+			no-map;
+		};
+
+		gps_mem: gps@8b800000 {
+			reg = <0x0 0x8b800000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <64>;
+	};
+
 	gpio-keys {
 		compatible = "gpio-keys";
 
@@ -45,6 +81,84 @@ &blsp1_uart2 {
 	status = "okay";
 };
 
+&blsp_i2c2 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <9 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+
+		/* Set by bootloader */
+		status = "disabled";
+		qcom,otp-rslow-config = /bits/ 8 <0x0 0x0 0x0 0x0>;
+
+		qcom,float-voltage-mv = <4350>;
+		qcom,iterm-ma = <75>;
+		qcom,charging-timeout = <192>; /* 0 in downstream */
+		qcom,recharge-thresh-mv = <100>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <0>;
+		qcom,fg-batt-capacity-mah = <2000>;
+		qcom,fg-cc-soc-coeff = <0x8819>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4328>;
+		qcom,thermistor-c1-coeff = <0x86C8>;
+		qcom,fg-auto-recharge-soc = <95>; /* 99 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <550>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,soft-jeita-config;
+		qcom,warm-bat-decidegc = <450>;
+		qcom,cool-bat-decidegc = <100>;
+		qcom,soft-jeita-comp-voltage-mv = <4100>;
+		qcom,soft-jeita-comp-current-ma = <550>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <200>;
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+};
+
+&blsp_i2c3 {
+	status = "okay";
+
+	speaker_codec_top: audio-codec@34 {
+		compatible = "nxp,tfa9897";
+		reg = <0x34>;
+		vddd-supply = <&pm8916_l6>;
+		rcv-gpios = <&msmgpio 50 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&speaker_top_default>;
+		sound-name-prefix = "Speaker Top";
+		#sound-dai-cells = <0>;
+	};
+
+	speaker_codec_bottom: audio-codec@36 {
+		compatible = "nxp,tfa9897";
+		reg = <0x36>;
+		vddd-supply = <&pm8916_l6>;
+		rcv-gpios = <&msmgpio 111 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&speaker_bottom_default>;
+		sound-name-prefix = "Speaker Bottom";
+		#sound-dai-cells = <0>;
+	};
+};
+
 &blsp_i2c4 {
 	status = "okay";
 
@@ -93,6 +207,29 @@ accelerometer@f {
 			       "0", "0", "-1";
 	};
 
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tps65132_en_default>;
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&msmgpio 2 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&msmgpio 33 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+
 	proximity@48 {
 		compatible = "sensortek,stk3310";
 		reg = <0x48>;
@@ -115,6 +252,45 @@ gyroscope@68 {
 	};
 };
 
+&dsi0 {
+	panel@0 {
+		compatible = "alcatel,idol347-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -128,6 +304,13 @@ &pronto {
 	status = "okay";
 };
 
+&q6afedai {
+	dai@22 {
+		reg = <QUATERNARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+};
+
 &sdhc_1 {
 	status = "okay";
 
@@ -146,13 +329,48 @@ &sdhc_2 {
 	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
 };
 
+&sound {
+	status = "okay";
+
+	model = "alcatel-idol3";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &ext_sec_tlmm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &ext_sec_tlmm_lines_sus>;
+};
+
+&sound_dai_primary {
+	/* unused primary link is kept so we can use same UCM with modem */
+};
+
+&sound_dai_quaternary {
+	status = "okay";
+
+	codec {
+		sound-dai = <&speaker_codec_top>, <&speaker_codec_bottom>;
+	};
+};
+
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
 };
 
 &smd_rpm_regulators {
@@ -291,6 +509,23 @@ mag_reset_default: mag-reset-default {
 		bias-disable;
 	};
 
+	mdss {
+		mdss_active: mdss-active {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_suspend: mdss-suspend {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
 	proximity_int_default: proximity-int-default {
 		pins = "gpio12";
 		function = "gpio";
@@ -299,6 +534,38 @@ proximity_int_default: proximity-int-default {
 		bias-pull-up;
 	};
 
+	smb_int_default: smb_int_default {
+		pins = "gpio9";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	speaker_bottom_default: speaker-bottom-default {
+		pins = "gpio111";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	speaker_top_default: speaker-top-default {
+		pins = "gpio50";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tps65132_en_default: tps65132-en-default {
+		pins = "gpio2", "gpio33";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	ts_int_reset_default: ts-int-reset-default {
 		pins = "gpio13", "gpio100";
 		function = "gpio";
@@ -315,3 +582,14 @@ usb_id_default: usb-id-default {
 		bias-pull-up;
 	};
 };
+
+&pm8916_mpps {
+	pwm_out: mpp4 {
+		pins = "mpp4";
+		function = "digital";
+
+		output-low;
+		qcom,dtest = <1>;
+		power-source = <PM8916_MPP_L5>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts b/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts
new file mode 100644
index 00000000000..ed56b1fc87e
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "ARK Benefit A3";
+	compatible = "ark,peach", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		volume-down {
+			label = "Volume Down";
+			gpios = <&msmgpio 108 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off>;
+
+	non-removable;
+};
+
+&usb {
+	status = "okay";
+	extcon = <&pm8916_usbin>;
+	dr_mode = "peripheral";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio108";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts b/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
index cee451e5938..c0fb566df98 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
@@ -3,11 +3,16 @@
 /dts-v1/;
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
 
 / {
 	model = "Asus Zenfone 2 Laser";
 	compatible = "asus,z00l", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -17,6 +22,18 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
 	gpio-keys {
 		compatible = "gpio-keys";
 
@@ -40,6 +57,21 @@ volume-down {
 		};
 	};
 
+	reg_sd_vmmc: regulator-sdcard-vmmc {
+		compatible = "regulator-fixed";
+		regulator-name = "sdcard-vmmc";
+		regulator-min-microvolt = <2950000>;
+		regulator-max-microvolt = <2950000>;
+
+		gpio = <&msmgpio 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		startup-delay-us = <200>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&sd_vmmc_en_default>;
+	};
+
 	usb_id: usb-id {
 		compatible = "linux,extcon-usb-gpio";
 		id-gpios = <&msmgpio 110 GPIO_ACTIVE_HIGH>;
@@ -48,10 +80,101 @@ usb_id: usb-id {
 	};
 };
 
+&blsp_i2c2 {
+	status = "okay";
+
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+
+		vdd-supply = <&pm8916_l8>;
+		vid-supply = <&pm8916_l6>;
+
+		reset-gpios = <&msmgpio 112 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&mag_reset_default>;
+	};
+
+	imu@68 {
+		compatible = "invensense,mpu6515";
+		reg = <0x68>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <36 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&imu_default>;
+
+		mount-matrix = "1",  "0", "0",
+			       "0", "-1", "0",
+			       "0",  "0", "1";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@38 {
+		compatible = "edt,edt-ft5306";
+		reg = <0x38>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		reset-gpios = <&msmgpio 12 GPIO_ACTIVE_LOW>;
+
+		vcc-supply = <&pm8916_l11>;
+		iovcc-supply = <&pm8916_l6>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_default>;
+	};
+};
+
 &blsp1_uart2 {
 	status = "okay";
 };
 
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "asus,z00l-panel";
+		reg = <0>;
+
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+		backlight-gpios = <&msmgpio 21 GPIO_ACTIVE_HIGH>;
+		power-supply = <&pm8916_l8>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_bl_en_default>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss {
+	status = "okay";
+};
+
 &pronto {
 	status = "okay";
 };
@@ -64,6 +187,24 @@ &sdhc_1 {
 	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
 };
 
+&sdhc_2 {
+	status = "okay";
+	vmmc-supply = <&reg_sd_vmmc>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+};
+
 &usb {
 	status = "okay";
 	extcon = <&usb_id>, <&usb_id>;
@@ -73,6 +214,14 @@ &usb_hs_phy {
 	extcon = <&usb_id>;
 };
 
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,micbias1-ext-cap;
+	qcom,hphl-jack-type-normally-open;
+};
+
 &smd_rpm_regulators {
 	vdd_l1_l2_l3-supply = <&pm8916_s3>;
 	vdd_l4_l5_l6-supply = <&pm8916_s4>;
@@ -185,6 +334,71 @@ gpio_keys_default: gpio-keys-default {
 		bias-pull-up;
 	};
 
+	imu_default: imu-default {
+		pins = "gpio36";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_bl_en_default: lcd-bl-en-default {
+		pins = "gpio21";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mag_reset_default: mag-reset-default {
+		pins = "gpio112";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	sd_vmmc_en_default: sd-vmmc-en-default {
+		pins = "gpio87";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+
+		reset {
+			pins = "gpio12";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
 	usb_id_default: usb-id-default {
 		pins = "gpio110";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts b/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts
new file mode 100644
index 00000000000..89372db368d
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts
@@ -0,0 +1,447 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	model = "Asus Zenfone Max ZC550KL";
+	compatible = "asus,z010d", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+
+		label = "GPIO Hall Effect Sensor";
+
+		hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&msmgpio 115 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+
+	speaker_amp: audio-amplifier {
+		compatible = "awinic,aw8738";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&spk_ext_pa_default>;
+
+		enable-gpios = <&msmgpio 112 GPIO_ACTIVE_HIGH>;
+		aw8738,mode = <2>;
+		sound-name-prefix = "Speaker Amp";
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpios = <&msmgpio 110 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb_id_default>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@e {
+		compatible = "kionix,kxtj21009";
+		reg = <0x0e>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <114 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+
+		vdd-supply = <&pm8916_l17>;
+		vid-supply = <&pm8916_l6>;
+
+		reset-gpios = <&msmgpio 36 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&mag_reset_default>;
+	};
+
+	led-controller@45 {
+		compatible = "awinic,aw2013";
+		reg = <0x45>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vcc-supply = <&pm8916_l17>;
+
+		led@0 {
+			reg = <0>;
+			led-max-microamp = <5000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_GREEN>;
+		};
+
+		led@1 {
+			reg = <1>;
+			led-max-microamp = <5000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_RED>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@38 {
+		/* Actually ft5x46 */
+		compatible = "edt,edt-ft5306";
+		reg = <0x38>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vcc-supply = <&pm8916_l17>;
+		iovcc-supply = <&pm8916_l6>;
+
+		reset-gpios = <&msmgpio 12 GPIO_ACTIVE_LOW>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "asus,z010d-r69339";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+
+	model = "bq-paella";
+	audio-routing =
+		"Speaker Amp IN", "HPH_R_EXT",
+		"AMIC1", "MIC BIAS Internal1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS Internal3";
+	aux-devs = <&speaker_amp>;
+};
+
+&usb {
+	status = "okay";
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio114";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mag_reset_default: mag-reset-default {
+		pins = "gpio36";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable = <0>;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	spk_ext_pa_default: spk-ext-pa-default {
+		pins = "gpio112";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+
+		reset {
+			pins = "gpio12";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	usb_id_default: usb-id-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts b/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
index e0075b57419..9ad7dbb6715 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
 
 /*
  * Note: The original firmware from Huawei can only boot 32-bit kernels.
@@ -25,6 +26,7 @@
 / {
 	model = "Huawei Ascend G7";
 	compatible = "huawei,g7", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -215,6 +217,40 @@ &blsp1_uart2 {
 	status = "okay";
 };
 
+&dsi0 {
+	panel@0 {
+		compatible = "huawei,tianma-nt35521";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&lpass {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -259,6 +295,40 @@ &sdhc_2 {
 	cd-gpios = <&msmgpio 56 GPIO_ACTIVE_LOW>;
 };
 
+&sound {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus>;
+
+	model = "msm8916";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS External2",
+		"AMIC3", "MIC BIAS External1";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&wcd_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&wcd_codec 1>;
+		};
+	};
+};
+
 &usb {
 	status = "okay";
 	extcon = <&usb_id>, <&usb_id>;
@@ -268,6 +338,13 @@ &usb_hs_phy {
 	extcon = <&usb_id>;
 };
 
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
 &smd_rpm_regulators {
 	vdd_l1_l2_l3-supply = <&pm8916_s3>;
 	vdd_l4_l5_l6-supply = <&pm8916_s4>;
@@ -412,6 +489,23 @@ mag_reset_default: mag-reset-default {
 		bias-disable;
 	};
 
+	mdss {
+		mdss_active: mdss-active {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_suspend: mdss-suspend {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
 	prox_irq_default: prox-irq-default {
 		pins = "gpio113";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts b/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts
new file mode 100644
index 00000000000..dd60ac51eb4
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts
@@ -0,0 +1,409 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	model = "Huawei Y635";
+	compatible = "huawei,y635", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <7600000>;
+		charge-full-design-microamp-hours = <2000000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4331000 100>, <4261000 95>, <4204000 90>,
+			<4152000 85>, <4102000 80>, <4060000 75>, <3998000 70>,
+			<3964000 65>, <3924000 60>, <3874000 55>, <3842000 50>,
+			<3820000 45>, <3800000 40>, <3785000 35>, <3720000 30>,
+			<3758000 25>, <3735000 20>, <3706000 16>, <3690000 13>,
+			<3687000 11>, <3686000 10>, <3684000 9>, <3680000 8>,
+			<3668000 7>, <3640000 6>, <3596000 5>, <3542000 4>,
+			<3472000 3>, <3378000 2>, <3239000 1>, <3000000 0>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@18 {
+		compatible = "st,lis3dh-accel";
+		reg = <0x18>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+
+		mount-matrix =	"0", "-1", "0",
+				"-1", "0", "0",
+				"0", "0", "1";
+	};
+
+	proximity@39 {
+		compatible = "avago,apds9930";
+		reg = <0x39>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <113 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		led-max-microamp = <100000>;
+		amstaos,proximity-diodes = <1>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&prox_irq_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@26 {
+		compatible = "mstar,msg2138";
+		reg = <0x26>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		reset-gpios = <&msmgpio 12 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_int_reset_default>;
+
+		vdd-supply = <&pm8916_l16>;
+		vddio-supply = <&pm8916_l6>;
+
+		touchscreen-size-x = <2048>;
+		touchscreen-size-y = <2048>;
+
+		linux,keycodes = <KEY_BACK KEY_APPSELECT KEY_HOMEPAGE>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "huawei,boe-otm8019a";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <1 2>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&lpass {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_bms {
+	status = "okay";
+
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8916_charger>;
+};
+
+&pm8916_charger {
+	status = "okay";
+
+	qcom,vdd-safe = <4300000>;
+	qcom,ibat-safe = <700000>;
+
+	monitored-battery = <&bat>;
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus>;
+
+	model = "msm8916";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&wcd_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&wcd_codec 1>;
+		};
+	};
+};
+
+&usb {
+	status = "okay";
+	extcon = <&pm8916_charger>;
+	dr_mode = "peripheral";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_charger>;
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <2100000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2950000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio112";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	prox_irq_default: prox-irq-default {
+		pins = "gpio113";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_int_reset_default: ts-int-reset-default {
+		pins = "gpio12", "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts b/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts
new file mode 100644
index 00000000000..dcaab11e329
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts
@@ -0,0 +1,252 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "LG Leon LTE";
+	compatible = "lg,c50", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 108 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		volume-down {
+			label = "Volume Down";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+
+	reg_sd_vmmc: regulator-sdcard-vmmc {
+		compatible = "regulator-fixed";
+		regulator-name = "sdcard-vmmc";
+		regulator-min-microvolt = <2950000>;
+		regulator-max-microvolt = <2950000>;
+
+		gpio = <&msmgpio 60 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		startup-delay-us = <5000>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&sd_vmmc_en_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	panel@0 {
+		compatible = "lg,c50-panel";
+		reg = <0>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	vmmc-supply = <&reg_sd_vmmc>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_HIGH>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio108";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	sd_vmmc_en_default: sd-vmmc-en-default {
+		pins = "gpio60";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&sdc2_cd_on {
+	/delete-property/ bias-pull-up;
+	bias-pull-down;
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts b/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts
new file mode 100644
index 00000000000..fbe7ee12f35
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "LG K10 (K420n)";
+	compatible = "lg,m216", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x4a00000>;
+			no-map;
+		};
+
+		gps_mem: gps@8b200000 {
+			reg = <0x0 0x8b200000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3300000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <8800000>;
+		charge-full-design-microamp-hours = <2300000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4342000 100>, <4266000 95>, <4206000 90>,
+			<4148000 85>, <4094000 80>, <4046000 75>, <3994000 70>,
+			<3956000 65>, <3916000 60>, <3866000 55>, <3831000 50>,
+			<3808000 45>, <3789000 40>, <3776000 35>, <3769000 30>,
+			<3760000 25>, <3740000 20>, <3712000 16>, <3684000 13>,
+			<3676000 11>, <3674000 10>, <3672000 9>, <3669000 8>,
+			<3665000 7>, <3660000 6>, <3643000 5>, <3602000 4>,
+			<3542000 3>, <3458000 2>, <3326000 1>, <3000000 0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		volume-down {
+			label = "Volume Down";
+			gpios = <&msmgpio 108 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@11 {
+		compatible = "bosch,bmc150_accel";
+		reg = <0x11>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+
+		mount-matrix =	 "0", "1", "0",
+				"-1", "0", "0",
+				 "0", "0", "1";
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+
+	magnetometer@13 {
+		compatible = "bosch,bmc150_magn";
+		reg = <0x13>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <69 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&magn_int_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@34 {
+		compatible = "melfas,mip4_ts";
+		reg = <0x34>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		ce-gpios = <&msmgpio 12 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	panel@0 {
+		compatible = "lg,m2db7400-incell-simple";
+		reg = <0>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_bms {
+	status = "okay";
+
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8916_charger>;
+};
+
+&pm8916_charger {
+	status = "okay";
+
+	qcom,vdd-safe = <4300000>;
+	qcom,ibat-safe = <700000>;
+
+	monitored-battery = <&bat>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_charger>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_charger>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio108";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	magn_int_default: magn-int-default {
+		pins = "gpio69";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+
+		ce {
+			pins = "gpio12";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
index 1e893c0b6fb..3500b6ee8b8 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
@@ -3,14 +3,21 @@
 /dts-v1/;
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/delete-node/ &mpss_mem;
+/delete-node/ &wcnss_mem;
 
 / {
 	model = "Longcheer L8150";
 	compatible = "longcheer,l8150", "qcom,msm8916-v1-qrd/9-v1", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -20,22 +27,81 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	/*
+	 * For some reason, the wcnss firmware is not relocatable, it must be
+	 * loaded at 0x8b600000. Unfortunately this overlaps with the memory
+	 * region required for the modem (0x86800000-0x8b800000).
+	 *
+	 * On the downstream kernel everything somehow works even with the
+	 * overlap (possibly because wcnss is loaded after the modem
+	 * and the modem never accessed its last 2 MB memory...?)
+	 *
+	 * Fortunately at least the modem is relocatable (aligned to 0x400000),
+	 * so put it after everything else and keep the original region empty.
+	 */
 	reserved-memory {
-		// wcnss.mdt is not relocatable, so it must be loaded at 0x8b600000
-		/delete-node/ wcnss@89300000;
-
 		wcnss_mem: wcnss@8b600000 {
 			reg = <0x0 0x8b600000 0x0 0x600000>;
 			no-map;
 		};
+
+		mpss_mem: mpss@8ec00000 {
+			reg = <0x0 0x8ec00000 0x0 0x5000000>;
+			no-map;
+		};
+
+		gps_mem: gps@93c00000 {
+			reg = <0x0 0x93c00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
 	};
 
-	// FIXME: Use extcon device provided by charger driver when available
-	usb_vbus: usb-vbus {
+	usb_otg_hack: usb-otg-hack {
 		compatible = "linux,extcon-usb-gpio";
-		vbus-gpio = <&msmgpio 62 GPIO_ACTIVE_HIGH>;
+
+		/*
+		 * NOTE: This allows detection of custom-made OTG adapters
+		 *
+		 * Since L8150 doesn't support OTG it's impossible to use normal OTG
+		 * adapters. However since USB_ID is in fact connected to GPIO it's
+		 * possible to detect custom-made OTG adapters that connect USB_ID
+		 * to 5v instead of GND and provie external power.
+		 *
+		 * Downside of this approach is that USB_ID pin is used to change boot
+		 * order of SoC and if device will be powered on with adapter attached
+		 * and powered, it will boot into USB BOOT mode.
+		 */
+		id-gpio = <&msmgpio 37 GPIO_ACTIVE_LOW>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&usb_vbus_default>;
+		pinctrl-0 = <&usb_id_default>;
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <9500000>;
+		charge-full-design-microamp-hours = <2500000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4330000 100>, <4265000 95>,
+			<4208000 90>, <4153000 85>, <4100000 80>, <4049000 75>,
+			<4001000 70>, <3962000 65>, <3919000 60>, <3872000 55>,
+			<3839000 50>, <3817000 45>, <3798000 40>, <3783000 35>,
+			<3767000 30>, <3747000 25>, <3729000 20>, <3709000 16>,
+			<3688000 13>, <3681000 11>, <3680000 10>, <3679000 9>,
+			<3677000 8>, <3674000 7>, <3666000 6>, <3641000 5>,
+			<3597000 4>, <3537000 3>, <3457000 2>, <3336000 1>,
+			<3000000 0>;
 	};
 
 	gpio-keys {
@@ -120,10 +186,32 @@ led@2 {
 &blsp_i2c2 {
 	status = "okay";
 
+	light-sensor@23 {
+		compatible = "liteon,ltr559";
+		reg = <0x23>;
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_FALLING>;
+	};
+
 	accelerometer@10 {
-		compatible = "bosch,bmc150_accel";
+		compatible = "bosch,bmc156_accel";
 		reg = <0x10>;
 
+		/*
+		 * For some reason the interrupt line is usually not connected
+		 * to the BMC156. However, there are two pads next to the chip
+		 * that can be shorted to make it work if needed.
+		 *
+		 * interrupt-parent = <&msmgpio>;
+		 * interrupts = <116 IRQ_TYPE_EDGE_RISING>;
+		 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+
 		vdd-supply = <&pm8916_l17>;
 		vddio-supply = <&pm8916_l6>;
 
@@ -133,9 +221,15 @@ accelerometer@10 {
 	};
 
 	magnetometer@12 {
-		compatible = "bosch,bmc150_magn";
+		compatible = "bosch,bmc156_magn";
 		reg = <0x12>;
 
+		interrupt-parent = <&msmgpio>;
+		interrupts = <113 IRQ_TYPE_EDGE_RISING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&magn_int_default>;
+
 		vdd-supply = <&pm8916_l17>;
 		vddio-supply = <&pm8916_l6>;
 	};
@@ -145,7 +239,8 @@ gyroscope@68 {
 		reg = <0x68>;
 
 		interrupt-parent = <&msmgpio>;
-		interrupts = <23 IRQ_TYPE_EDGE_RISING>;
+		interrupts = <23 IRQ_TYPE_EDGE_RISING>,
+			     <22 IRQ_TYPE_EDGE_RISING>;
 
 		pinctrl-names = "default";
 		pinctrl-0 = <&gyro_int_default>;
@@ -191,6 +286,62 @@ &blsp1_uart2 {
 	status = "okay";
 };
 
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "longcheer,l8150-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_bms {
+	status = "okay";
+
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8916_charger>;
+};
+
+&pm8916_charger {
+	status = "okay";
+
+	qcom,vdd-safe = <4300000>;
+	qcom,ibat-safe = <900000>;
+
+	monitored-battery = <&bat>;
+};
+
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -222,14 +373,28 @@ &sdhc_2 {
 	non-removable;
 };
 
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS Internal1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS Internal3";
+};
+
 &usb {
 	status = "okay";
-	dr_mode = "peripheral";
-	extcon = <&usb_vbus>;
+	extcon = <&pm8916_charger>, <&usb_otg_hack>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_vbus>;
+	extcon = <&pm8916_charger>;
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
 };
 
 &smd_rpm_regulators {
@@ -336,6 +501,14 @@ l18 {
 };
 
 &msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio116";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	camera_flash_default: camera-flash-default {
 		pins = "gpio31", "gpio32";
 		function = "gpio";
@@ -361,13 +534,38 @@ gpio_keys_default: gpio-keys-default {
 	};
 
 	gyro_int_default: gyro-int-default {
-		pins = "gpio23";
+		pins = "gpio22", "gpio23";
 		function = "gpio";
 
 		drive-strength = <2>;
 		bias-disable;
 	};
 
+	magn_int_default: magn-int-default {
+		pins = "gpio113";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
 	tp_int_default: tp-int-default {
 		pins = "gpio13";
 		function = "gpio";
@@ -376,10 +574,22 @@ tp_int_default: tp-int-default {
 		bias-disable;
 	};
 
-	usb_vbus_default: usb-vbus-default {
-		pins = "gpio62";
+	usb_id_default: usb-id-default {
+		pins = "gpio37";
 		function = "gpio";
 
-		bias-pull-up;
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4 {
+		pins = "mpp4";
+		function = "digital";
+
+		output-low;
+		qcom,dtest = <1>;
+		power-source = <PM8916_MPP_VPH>;
 	};
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
index 27845189ac2..42b36377d8a 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
@@ -3,13 +3,17 @@
 /dts-v1/;
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "BQ Aquaris X5 (Longcheer L8910)";
 	compatible = "longcheer,l8910", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -19,6 +23,38 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5000000>;
+			no-map;
+		};
+
+		gps_mem: gps@8b800000 {
+			reg = <0x0 0x8b800000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	speaker_amp: audio-amplifier {
+		compatible = "awinic,aw8738";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&spk_ext_pa_default>;
+
+		enable-gpios = <&msmgpio 114 GPIO_ACTIVE_HIGH>;
+		aw8738,mode = <5>;
+		sound-name-prefix = "Speaker Amp";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	gpio-keys {
 		compatible = "gpio-keys";
 
@@ -48,11 +84,24 @@ led-0 {
 		};
 	};
 
+	reg_ts_vcca: regulator-vcca-ts {
+		compatible = "regulator-fixed";
+		regulator-name = "regulator-vcca-ts";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 78 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_vcca_default>;
+	};
+
 	usb_id: usb-id {
 		compatible = "linux,extcon-usb-gpio";
 		id-gpio = <&msmgpio 110 GPIO_ACTIVE_HIGH>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&usb_id_default>;
+		pinctrl-0 = <&usb_id_default &usb_id_switch_default>;
 	};
 };
 
@@ -85,10 +134,124 @@ imu@68 {
 	};
 };
 
+&blsp_i2c4 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+
+		/*
+		 * Some properties are battery-specific. Battery detection
+		 * happens in the bootloader, so it will fill those appropriately
+		 * and set status = "okay".
+		 */
+		status = "disabled";
+
+		qcom,rsense-10mohm;
+
+		qcom,float-voltage-mv = <4400>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <192>; /* 768 in downstream */
+		qcom,recharge-thresh-mv = <50>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <(-1)>; /* Set by bootloader */
+		qcom,fg-batt-capacity-mah = <2810>;
+		qcom,fg-cc-soc-coeff = <0x81D5>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-iterm-ma = <100>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4397>;
+		qcom,thermistor-c1-coeff = <0x86C2>;
+		qcom,fg-auto-recharge-soc = <95>; /* 97 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <500>;
+		qcom,otp-cold-bat-decidegc = <(-50)>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <200>;
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@48 {
+		compatible = "himax,852x";
+		reg = <0x48>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
+
+		reset-gpio = <&msmgpio 12 GPIO_ACTIVE_HIGH>;
+
+		vcca-supply = <&reg_ts_vcca>;
+		vccd-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_int_reset_default>;
+
+		linux,keycodes = <KEY_BACK KEY_HOMEPAGE KEY_APPSELECT>;
+	};
+};
+
 &blsp1_uart2 {
 	status = "okay";
 };
 
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "longcheer,l8910-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -120,13 +283,33 @@ &sdhc_2 {
 	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
 };
 
+&sound {
+	status = "okay";
+
+	model = "bq-paella";
+	audio-routing =
+		"Speaker Amp IN", "HPH_R_EXT",
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+	aux-devs = <&speaker_amp>;
+};
+
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
 };
 
 &smd_rpm_regulators {
@@ -257,6 +440,55 @@ mag_reset_default: mag-reset-default {
 		bias-disable;
 	};
 
+	mdss {
+		mdss_active: mdss-active {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_suspend: mdss-suspend {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	smb_int_default: smb_int_default {
+		pins = "gpio62";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	spk_ext_pa_default: spk-ext-pa-default {
+		pins = "gpio114";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_int_reset_default: ts-int-reset-default {
+		pins = "gpio12", "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_vcca_default: ts-vcca-default {
+		pins = "gpio78";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	usb_id_default: usb-id-default {
 		pins = "gpio110";
 		function = "gpio";
@@ -264,4 +496,23 @@ usb_id_default: usb-id-default {
 		drive-strength = <8>;
 		bias-pull-up;
 	};
+
+	usb_id_switch_default: usb_id_switch_default {
+		function = "gpio";
+		pins = "gpio121";
+
+		drive-strength = <2>;
+		output-high;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4 {
+		pins = "mpp4";
+		function = "digital";
+
+		output-low;
+		qcom,dtest = <1>;
+		power-source = <PM8916_MPP_VPH>;
+	};
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-modem.dtsi b/arch/arm64/boot/dts/qcom/msm8916-modem.dtsi
new file mode 100644
index 00000000000..b9417c2ec10
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-modem.dtsi
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/sound/qcom,q6voice.h>
+
+&apr {
+	status = "okay";
+};
+
+&bam_dmux {
+	status = "okay";
+};
+
+&bam_dmux_dma {
+	status = "okay";
+};
+
+&lpass {
+	status = "reserved"; /* Controlled by QDSP6 */
+};
+
+&memshare {
+	status = "okay";
+};
+
+&memshare_gps {
+	memory-region = <&gps_mem>;
+};
+
+&mpss {
+	status = "okay";
+};
+
+&q6afedai {
+	dai@16 {
+		reg = <PRIMARY_MI2S_RX>;
+		qcom,sd-lines = <0 1>;
+	};
+	dai@20 {
+		reg = <TERTIARY_MI2S_TX>;
+		qcom,sd-lines = <0 1>;
+	};
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+		direction = <Q6ASM_DAI_RX>;
+	};
+	dai@1 {
+		reg = <1>;
+		direction = <Q6ASM_DAI_TX>;
+	};
+	dai@2 {
+		reg = <2>;
+		direction = <Q6ASM_DAI_RX>;
+	};
+	dai@3 {
+		reg = <3>;
+		direction = <Q6ASM_DAI_RX>;
+		is-compress-dai;
+	};
+};
+
+&sound {
+	compatible = "qcom,msm8916-qdsp6-sndcard";
+	model = "msm8916";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus>;
+
+	dai-link-multimedia1 {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	dai-link-multimedia2 {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	dai-link-multimedia3 {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	dai-link-multimedia4 {
+		link-name = "MultiMedia4";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA4>;
+		};
+	};
+
+	dai-link-cs-voice {
+		link-name = "CS-Voice";
+		cpu {
+			sound-dai = <&q6voicedai CS_VOICE>;
+		};
+	};
+
+	sound_dai_primary: dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&q6afedai PRIMARY_MI2S_RX>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&wcd_codec 0>;
+		};
+	};
+
+	sound_dai_secondary: dai-link-secondary {
+		link-name = "Secondary MI2S";
+		status = "disabled"; /* Needs extra codec configuration */
+		cpu {
+			sound-dai = <&q6afedai SECONDARY_MI2S_RX>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	sound_dai_tertiary: dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&q6afedai TERTIARY_MI2S_TX>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&wcd_codec 1>;
+		};
+	};
+
+	sound_dai_quaternary: dai-link-quaternary {
+		link-name = "Quaternary MI2S";
+		status = "disabled"; /* Needs extra codec configuration */
+		cpu {
+			sound-dai = <&q6afedai QUATERNARY_MI2S_RX>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts
new file mode 100644
index 00000000000..be2f9aba1fb
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts
@@ -0,0 +1,501 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Motorola Moto G4 Play (harpia)";
+	compatible = "motorola,harpia", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&msmgpio 91 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-1 = <&usb_id_sleep>;
+	};
+
+	/*
+	 * harpia uses a NT50358 regulator to drive the display panel.
+	 * This regulator is apparently compatible with the TPS65132, except for
+	 * some differences with the enable lines, according to the downstream
+	 * kernel.
+	 * (https://github.com/MotorolaMobilityLLC/kernel-msm/blob/nougat-7.1.1-release-harpia/arch/arm/boot/dts/qcom/msm8916-harpia.dtsi#L202)
+	 * TODO: figure out what needs to be done to get a proper driver working
+	 * for this regulator. For now, we can just use fixed-regulator, as the
+	 * regulator reads voltages on startup from an onboard EEPROM, and we
+	 * don't need to adjust the regulator's values.
+	 */
+	nt50358_pos: nt50358-pos {
+		compatible = "regulator-fixed";
+		regulator-name = "nt50358-pos";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&msmgpio 97 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_p_en_default>;
+	};
+
+	nt50358_neg: nt50358-neg {
+		compatible = "regulator-fixed";
+		regulator-name = "nt50358-neg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&msmgpio 98 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_n_en_default>;
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	battery@36 {
+		compatible = "maxim,max17050";
+		reg = <0x36>;
+
+		maxim,rsns-microohm = <10000>;
+		maxim,over-heat-temp = <600>;
+		maxim,cold-temp = <(-200)>;
+		maxim,dead-volt = <3200>;
+		maxim,over-volt = <4500>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <62 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&battery_alert_default>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	rmi4@20 {
+		compatible = "syna,rmi4-i2c";
+		reg = <0x20>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l16>;
+		vio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_int_default>;
+
+		syna,startup-delay-ms = <100>;
+
+		rmi4-f01@1 {
+			reg = <1>;
+			syna,nosleep-mode = <1>; // Allow sleeping
+		};
+
+		rmi4-f11@11 {
+			reg = <11>;
+			syna,sensor-type = <1>; // Touchscreen
+		};
+	};
+};
+
+&blsp_i2c4 {
+	status = "okay";
+
+	accelerometer@19 {
+		compatible = "bosch,bma253";
+		reg = <0x19>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>,
+			     <119 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		mount-matrix = "1",  "0", "0",
+			       "0", "-1", "0",
+			       "0",  "0", "1";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+};
+
+&blsp1_uart1 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "motorola,harpia-panel";
+		reg = <0>;
+
+		vsp-supply = <&nt50358_pos>;
+		vsn-supply = <&nt50358_neg>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+		backlight-gpios = <&msmgpio 37 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_bl_en_default>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd>;
+
+	cd-gpios = <&msmgpio 118 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &headset_switch_supply_en
+		     &headset_switch_in>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &headset_switch_supply_en
+		     &headset_switch_in>;
+};
+
+&usb {
+	status = "okay";
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,micbias1-ext-cap;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <3100000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+/* CTS/RTX are not used */
+&blsp1_uart1_default {
+	pins = "gpio0", "gpio1";
+};
+&blsp1_uart1_sleep {
+	pins = "gpio0", "gpio1";
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115", "gpio119";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	battery_alert_default: battery-alert-default {
+		pins = "gpio62";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	headset_switch_in: headset-switch-in {
+		pins = "gpio112";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+		output-low;
+	};
+
+	headset_switch_supply_en: headset-switch-supply-en {
+		pins = "gpio111";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+		output-high;
+	};
+
+	lcd_bl_en_default: lcd-bl-en-default {
+		pins = "gpio37";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_p_en_default: lcd-p-en-default {
+		pins = "gpio97";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_n_en_default: lcd-n-en-default {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	sdc2_cd: sdc2-cd-default {
+		pins = "gpio118";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_int_default: ts-int-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb-id {
+		usb_id_default: id-default {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+		usb_id_sleep: id-sleep {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts
new file mode 100644
index 00000000000..6cc2b286165
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts
@@ -0,0 +1,449 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+
+/ {
+	model = "Motorola Moto G 2015 (osprey)";
+	compatible = "motorola,osprey", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&msmgpio 91 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-1 = <&usb_id_sleep>;
+	};
+
+	reg_panel_vddio: regulator-panel-vddio {
+		compatible = "regulator-fixed";
+		regulator-name = "vddio_panel";
+		gpio = <&msmgpio 36 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_vddio_default>;
+		startup-delay-us = <300>;
+		regulator-boot-on;
+	};
+
+	reg_touch_vdda: regulator-touch-vdda {
+		compatible = "regulator-fixed";
+		regulator-name = "touch_vdda";
+		gpio = <&msmgpio 114 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touch_vdda_default>;
+		startup-delay-us = <300>;
+		vin-supply = <&pm8916_l16>;
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	battery@36 {
+		compatible = "maxim,max17050";
+		reg = <0x36>;
+
+		maxim,rsns-microohm = <10000>;
+		maxim,over-heat-temp = <600>;
+		maxim,cold-temp = <(-200)>;
+		maxim,dead-volt = <3200>;
+		maxim,over-volt = <4500>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <49 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&battery_alert_default>;
+	};
+
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&disp_en_default>;
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&pm8916_gpios 3 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&pm8916_gpios 4 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	rmi4@20 {
+		compatible = "syna,rmi4-i2c";
+		reg = <0x20>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <21 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&reg_touch_vdda>;
+		vio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touch_int_default>;
+
+		syna,startup-delay-ms = <100>;
+
+		rmi4-f01@1 {
+			reg = <1>;
+			syna,nosleep-mode = <1>; // Allow sleeping
+		};
+
+		rmi4-f11@11 {
+			reg = <11>;
+			syna,sensor-type = <1>; // Touchscreen
+		};
+	};
+};
+
+&blsp1_uart1 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "motorola,osprey-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		vddio-supply = <&reg_panel_vddio>;
+
+		reset-gpios = <&msmgpio 78 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC3", "MIC BIAS External1";
+};
+
+&usb {
+	status = "okay";
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias2-ext-cap;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <3100000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+/* CTS/RTX are not used */
+&blsp1_uart1_default {
+	pins = "gpio0", "gpio1";
+};
+&blsp1_uart1_sleep {
+	pins = "gpio0", "gpio1";
+};
+
+&msmgpio {
+	battery_alert_default: battery-alert-default {
+		pins = "gpio49";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio78";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio78";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	panel_vddio_default: panel-vddio-default {
+		pins = "gpio36";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touch_int_default: touch-int-default {
+		pins = "gpio21";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touch_vdda_default: touch-vdda-default {
+		pins = "gpio114";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb-id {
+		usb_id_default: id-default {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+		usb_id_sleep: id-sleep {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+	};
+};
+
+&pm8916_gpios {
+	disp_en_default: disp-en-default {
+		pins = "gpio3", "gpio4";
+		function = PMIC_GPIO_FUNC_NORMAL;
+
+		bias-disable;
+		power-source = <PM8916_GPIO_L2>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts
new file mode 100644
index 00000000000..7848bb35216
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts
@@ -0,0 +1,373 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Motorola Moto E 2015 LTE (surnia)";
+	compatible = "motorola,surnia", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&msmgpio 91 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-1 = <&usb_id_sleep>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	rmi4@20 {
+		compatible = "syna,rmi4-i2c";
+		reg = <0x20>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <21 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l16>;
+		vio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_int_default>;
+
+		syna,startup-delay-ms = <100>;
+
+		rmi4-f01@1 {
+			reg = <1>;
+			syna,nosleep-mode = <1>; // Allow sleeping
+		};
+
+		rmi4-f11@11 {
+			reg = <11>;
+			syna,sensor-type = <1>; // Touchscreen
+		};
+	};
+};
+
+&blsp_i2c4 {
+	status = "okay";
+
+	battery@36 {
+		compatible = "maxim,max17050";
+		reg = <0x36>;
+
+		maxim,rsns-microohm = <10000>;
+		maxim,over-heat-temp = <600>;
+		maxim,cold-temp = <(-200)>;
+		maxim,dead-volt = <3200>;
+		maxim,over-volt = <4500>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&battery_alert_default>;
+	};
+};
+
+&blsp1_uart1 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "motorola,surnia-panel";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 78 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC3", "MIC BIAS External1";
+};
+
+&usb {
+	status = "okay";
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias2-ext-cap;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <3100000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+/* CTS/RTX are not used */
+&blsp1_uart1_default {
+	pins = "gpio0", "gpio1";
+};
+&blsp1_uart1_sleep {
+	pins = "gpio0", "gpio1";
+};
+
+&msmgpio {
+	battery_alert_default: battery-alert-default {
+		pins = "gpio12";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio78";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio78";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	ts_int_default: ts-int-default {
+		pins = "gpio21";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb-id {
+		usb_id_default: id-default {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+		usb_id_sleep: id-sleep {
+			pins = "gpio91";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-oppo-a51f.dts b/arch/arm64/boot/dts/qcom/msm8916-oppo-a51f.dts
new file mode 100644
index 00000000000..fc6f40e07da
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-oppo-a51f.dts
@@ -0,0 +1,537 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	model = "Oppo Mirror 5s (A51f)";
+	compatible = "oppo,a51f", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		volume-down {
+			label = "Volume Down";
+			gpios = <&msmgpio 108 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+
+		label = "GPIO Hall Effect Sensor";
+
+		hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&msmgpio 121 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+
+	reg_lcd_pos: regulator-lcd-pos {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd-pos";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&msmgpio 97 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_p_en_default>;
+	};
+
+	reg_lcd_neg: regulator-lcd-neg {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd-neg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&msmgpio 98 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_n_en_default>;
+	};
+
+	reg_sd_vmmc: regulator-sdcard-vmmc {
+		compatible = "regulator-fixed";
+		regulator-name = "sdcard-vmmc";
+		regulator-min-microvolt = <2950000>;
+		regulator-max-microvolt = <2950000>;
+
+		gpio = <&msmgpio 116 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		startup-delay-us = <200>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&sd_vmmc_en_default>;
+	};
+
+	speaker_amp: audio-amplifier {
+		compatible = "simple-audio-amplifier";
+		VCC-supply = <&reg_speaker_boost>;
+		enable-gpios = <&msmgpio 120 GPIO_ACTIVE_HIGH>;
+		sound-name-prefix = "Speaker Amp";
+
+		gpios = <&msmgpio 120 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&speaker_amp_default>;
+
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&msmgpio 110 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb_id_default>;
+	};
+
+	reg_speaker_boost: regulator-speaker-boost {
+		compatible = "regulator-fixed";
+		regulator-name = "yda145-amp";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpios = <&msmgpio 118 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&speaker_boost_default>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@19 {
+		compatible = "st,lis3dh-accel";
+		reg = <0x19>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <112 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+
+		mount-matrix = "1",  "0", "0",
+			       "0", "-1", "0",
+			       "0",  "0", "1";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	backlight: led-controller@38 {
+		compatible = "ti,lm3630a";
+		reg = <0x38>;
+		enable-gpios = <&msmgpio 69 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&bl_en_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		led@0 {
+			reg = <0>;
+			led-sources = <0 1>;
+			label = "lcd-backlight";
+			default-brightness = <200>;
+			max-brightness = <255>;
+		};
+	};
+
+	rmi4@20 {
+		compatible = "syna,rmi4_i2c";
+		reg = <0x20>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_default>;
+
+		syna,startup-delay-ms = <10>;
+
+		rmi4-f01@1 {
+			reg = <0x1>;
+			syna,nosleep-mode = <1>; // Allow sleeping
+		};
+
+		rmi4-f11@11 {
+			reg = <0x11>;
+			syna,sensor-type = <1>; // Touchscreen
+			syna,clip-x-high = <1100>;
+			syna,clip-y-high = <1770>;
+		};
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "oppo,15009-nt35592-jdi";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&lpass {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+	vmmc-supply = <&reg_sd_vmmc>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_HIGH>;
+};
+
+&sound {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+
+	pinctrl-0 = <&cdc_pdm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus>;
+
+	model = "oppo-a51f";
+	audio-routing =
+			"Speaker Amp INL", "HPH_L_EXT",
+			"Speaker Amp INR", "HPH_L_EXT",
+			"AMIC1", "MIC BIAS External1",
+			"AMIC2", "MIC BIAS External2";
+
+	aux-devs = <&speaker_amp>;
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&wcd_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&wcd_codec 1>;
+		};
+	};
+};
+
+&usb {
+	status = "okay";
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias2-ext-cap;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio112";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	bl_en_default: bl-en-default {
+		pins = "gpio69";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default {
+		pins = "gpio121";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio108";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	lcd_p_en_default: lcd-p-en-default {
+		pins = "gpio97";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_n_en_default: lcd-n-en-default {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	touchscreen_default: touchscreen-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	sd_vmmc_en_default: sd-vmmc-en-default {
+		pins = "gpio116";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	speaker_amp_default: speaker-amp-default {
+		pins = "gpio120";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	speaker_boost_default: speaker-boost-default {
+		pins = "gpio118";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb_id_default: usb-id-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
index 9b4b7de7cec..5f5880874cf 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
@@ -1,10 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-only
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
 
 / {
 	aliases {
@@ -21,6 +24,16 @@ tz-apps@85500000 {
 			reg = <0x0 0x85500000 0x0 0xb00000>;
 			no-map;
 		};
+
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5400000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bc00000 {
+			reg = <0x0 0x8bc00000 0x0 0x200000>;
+			no-map;
+		};
 	};
 
 	gpio-keys {
@@ -155,6 +168,18 @@ nfc@27 {
 	};
 };
 
+&blsp_i2c1 {
+	status = "okay";
+
+	speaker_codec: audio-codec@34 {
+		compatible = "nxp,tfa9895";
+		reg = <0x34>;
+		vddd-supply = <&pm8916_l5>;
+		sound-name-prefix = "Speaker";
+		#sound-dai-cells = <0>;
+	};
+};
+
 &blsp_i2c2 {
 	status = "okay";
 
@@ -204,6 +229,13 @@ &dsi0 {
 	pinctrl-1 = <&mdss_sleep>;
 };
 
+&lpass {
+	dai@3 {
+		reg = <MI2S_QUATERNARY>;
+		qcom,playback-sd-lines = <1>;
+	};
+};
+
 &mdss {
 	status = "okay";
 };
@@ -217,6 +249,13 @@ &pronto {
 	status = "okay";
 };
 
+&q6afedai {
+	dai@22 {
+		reg = <QUATERNARY_MI2S_RX>;
+		qcom,sd-lines = <1>;
+	};
+};
+
 &sdhc_1 {
 	status = "okay";
 
@@ -235,6 +274,28 @@ &sdhc_2 {
 	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
 };
 
+&sound {
+	status = "okay";
+
+	model = "samsung-a2015";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &ext_sec_tlmm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &ext_sec_tlmm_lines_sus>;
+};
+
+&sound_dai_quaternary {
+	status = "okay";
+
+	codec {
+		sound-dai = <&speaker_codec>;
+	};
+};
+
 &usb {
 	status = "okay";
 	extcon = <&muic>, <&muic>;
@@ -244,6 +305,16 @@ &usb_hs_phy {
 	extcon = <&muic>;
 };
 
+&wcd_codec {
+	jack-gpios = <&msmgpio 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
 &smd_rpm_regulators {
 	vdd_l1_l2_l3-supply = <&pm8916_s3>;
 	vdd_l4_l5_l6-supply = <&pm8916_s4>;
@@ -380,6 +451,14 @@ gpio_hall_sensor_default: gpio-hall-sensor-default {
 		bias-disable;
 	};
 
+	jack_default: jack-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	mdss {
 		mdss_default: mdss-default {
 			pins = "gpio25";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a3u-eur.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-a3u-eur.dts
index 6cc2eaeb1d3..4ba11b020f9 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-a3u-eur.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a3u-eur.dts
@@ -7,6 +7,7 @@
 / {
 	model = "Samsung Galaxy A3U (EUR)";
 	compatible = "samsung,a3u-eur", "qcom,msm8916";
+	chassis-type = "handset";
 
 	reg_panel_vdd3: regulator-panel-vdd3 {
 		compatible = "regulator-fixed";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts
new file mode 100644
index 00000000000..ae4a2805390
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-a5u-eur.dts"
+
+/ {
+	model = "Samsung Galaxy A5 (SM-A500YZ)";
+	compatible = "samsung,a5-zt", "samsung,a5u-eur", "qcom,msm8916";
+	chassis-type = "handset";
+
+	/* NOTE: a5-zt doesn't actually have an NFC chip. */
+	i2c-nfc {
+		status = "disabled";
+	};
+};
+
+&accelerometer {
+	mount-matrix = "0", "1", "0",
+			"1", "0", "0",
+			"0", "0", "1";
+};
+
+&reg_touch_key {
+	gpio = <&msmgpio 60 GPIO_ACTIVE_HIGH>;
+};
+
+&tkey_en_default {
+	pins = "gpio60";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
index c2eff5aebf8..f29937f8dbf 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
@@ -7,6 +7,31 @@
 / {
 	model = "Samsung Galaxy A5U (EUR)";
 	compatible = "samsung,a5u-eur", "qcom,msm8916";
+	chassis-type = "handset";
+
+	reg_vlcd_vdd3: regulator-vlcd-vdd3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vdd3";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&pm8916_s4>;
+
+		gpio = <&msmgpio 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_on_default>;
+	};
+
+	reg_vlcd_vci: regulator-vlcd-vci {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vci";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&msmgpio 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
 
 	reg_touch_key: regulator-touch-key {
 		compatible = "regulator-fixed";
@@ -49,6 +74,28 @@ touchscreen@48 {
 	};
 };
 
+&dsi0 {
+	panel@0 {
+		compatible = "samsung,ea8061v-ams497ee01";
+		reg = <0>;
+
+		vdd3-supply = <&reg_vlcd_vdd3>;
+		vci-supply = <&reg_vlcd_vci>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &pronto {
 	iris {
 		compatible = "qcom,wcn3660b";
@@ -61,6 +108,14 @@ &touchkey {
 };
 
 &msmgpio {
+	lcd_on_default: lcd-on-default {
+		pins = "gpio87";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	tkey_en_default: tkey-en-default {
 		pins = "gpio97";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-gprime.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-gprime.dts
new file mode 100644
index 00000000000..f45b4c1f0a6
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-gprime.dts
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Samsung Galaxy Grand Prime";
+	compatible = "samsung,gprime", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	muic: extcon@25 {
+		compatible = "siliconmitus,sm5502-muic";
+
+		reg = <0x25>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&muic_int_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&usb {
+	status = "okay";
+	extcon = <&muic>, <&muic>;
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	muic_int_default: muic-int-default {
+		pins = "gpio12";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi
new file mode 100644
index 00000000000..1aab125b473
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5400000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bc00000 {
+			reg = <0x0 0x8bc00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home {
+			label = "Home";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+
+		label = "GPIO Hall Effect Sensor";
+
+		hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&msmgpio 52 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+};
+
+&blsp_i2c4 {
+	status = "okay";
+
+	fuelgauge@36 {
+		compatible = "maxim,max77849-battery";
+		reg = <0x36>;
+
+		maxim,rsns-microohm = <10000>;
+		maxim,over-heat-temp = <600>;
+		maxim,over-volt = <4400>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <121 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&fuelgauge_int_default>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@1d {
+		compatible = "st,lis2hh12";
+		reg = <0x1d>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l5>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "INT1";
+
+		st,drdy-int-pin = <1>;
+		mount-matrix = "0", "1", "0",
+			      "-1", "0", "0",
+			       "0", "0", "1";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&accel_int_default>;
+	};
+
+	light-sensor@10 {
+		compatible = "capella,cm3323";
+		reg = <0x10>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&lpass {
+	dai@3 {
+		reg = <MI2S_QUATERNARY>;
+		qcom,playback-sd-lines = <1>;
+	};
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+/* FIXME: Replace with MAX77849 MUIC when driver is available */
+&pm8916_usbin {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+
+	iris {
+		compatible = "qcom,wcn3660b";
+	};
+};
+
+&q6afedai {
+	dai@22 {
+		reg = <QUATERNARY_MI2S_RX>;
+		qcom,sd-lines = <1>;
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&sound {
+	status = "okay";
+
+	model = "samsung-gt510";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &ext_sec_tlmm_lines_act>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &ext_sec_tlmm_lines_sus>;
+};
+
+&sound_dai_quaternary {
+	status = "okay";
+
+	codec {
+		sound-dai = <&speaker_codec>;
+	};
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&wcd_codec {
+	jack-gpios = <&msmgpio 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vtreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vtreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	fuelgauge_int_default: fuelgauge-int-default {
+		pins = "gpio121";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default {
+		pins = "gpio52";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	jack_default: jack-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-gt510.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt510.dts
new file mode 100644
index 00000000000..7afc8fced47
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt510.dts
@@ -0,0 +1,177 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-gt5-common.dtsi"
+
+/ {
+	model = "Samsung Galaxy Tab A 9.7 (2015)";
+	compatible = "samsung,gt510", "qcom,msm8916";
+	chassis-type = "tablet";
+
+	speaker_codec: audio-codec {
+		compatible = "maxim,max98357a";
+		sdmode-gpios = <&msmgpio 55 GPIO_ACTIVE_HIGH>;
+		#sound-dai-cells = <0>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&audio_sdmode_default>;
+	};
+
+	reg_lcd_vmipi: regulator-lcd-vmipi {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd_vmipi";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&msmgpio 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_en_default>;
+	};
+
+	reg_vlcd_5p4v: regulator-vlcd-5p4v {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_5p4v";
+		regulator-min-microvolt = <5400000>;
+		regulator-max-microvolt = <5400000>;
+
+		gpio = <&msmgpio 51 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&buckbooster_en_default>;
+	};
+
+	reg_tsp_1p8v: regulator-tsp-1p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_1p8v";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_en_default>;
+	};
+
+	reg_tsp_3p3v: regulator-tsp-3p3v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_3p3v";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@4a {
+		compatible = "atmel,maxtouch";
+		reg = <0x4a>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&reg_tsp_1p8v>;
+		vdda-supply = <&reg_tsp_3p3v>;
+
+		reset-gpios = <&msmgpio 114 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_int_rst_default>;
+	};
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "samsung,s6d7aa0-ltl101at01";
+		reg = <0>;
+
+		vmipi-supply = <&reg_lcd_vmipi>;
+		5p4v-supply = <&reg_vlcd_5p4v>;
+		reset-gpios = <&msmgpio 97 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&msmgpio {
+	audio_sdmode_default: audio-sdmode-default {
+		pins = "gpio55";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	buckbooster_en_default: buckbooster-en-default {
+		pins = "gpio51";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_en_default: lcd-en-default {
+		pins = "gpio8";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio97";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio97";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	tsp_en_default: tsp-en-default {
+		pins = "gpio73";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_rst_default: tsp-int-rst-default {
+		pins = "gpio13", "gpio114";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-gt58.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt58.dts
new file mode 100644
index 00000000000..ac85f4c870a
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt58.dts
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-gt5-common.dtsi"
+
+/ {
+	model = "Samsung Galaxy Tab A 8.0 (2015)";
+	compatible = "samsung,gt58", "qcom,msm8916";
+	chassis-type = "tablet";
+
+	i2c-amplifier {
+		compatible = "i2c-gpio";
+		sda-gpios = <&msmgpio 55 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&msmgpio 56 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&amp_i2c_default>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		speaker_codec: audio-codec@34 {
+			compatible = "nxp,tfa9895";
+			reg = <0x34>;
+			vddd-supply = <&pm8916_l5>;
+			sound-name-prefix = "Speaker";
+			#sound-dai-cells = <0>;
+		};
+	};
+
+	reg_5p4v: regulator-5p4v {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_5p4v";
+		regulator-min-microvolt = <5400000>;
+		regulator-max-microvolt = <5400000>;
+
+		gpio = <&msmgpio 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&buckbooster_en_default>;
+	};
+
+	reg_vdd_tsp: regulator-vdd-tsp {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_tsp";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&reg_tsp_en_default>;
+	};
+
+	vibrator {
+		compatible = "gpio-vibrator";
+		enable-gpios = <&msmgpio 76 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&vibrator_en_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	/*
+	 * Actual IC is Zinitix bt532.
+	 * It seems compatible enough with bt541 for basic functionality.
+	 */
+
+	touchscreen@20 {
+		compatible = "zinitix,bt532", "zinitix,bt541";
+		reg = <0x20>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		touchscreen-size-x = <768>;
+		touchscreen-size-y = <1024>;
+		linux,keycodes = <KEY_APPSELECT KEY_BACK>;
+
+		vdd-supply = <&reg_vdd_tsp>;
+		vddo-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_int_default>;
+	};
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "samsung,s6d7aa0-lsl080al03";
+		reg = <0>;
+
+		5p4v-supply = <&reg_5p4v>;
+		vmipi-supply = <&pm8916_l5>;
+		reset-gpios = <&msmgpio 97 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&sound {
+	/* FIXME: Avoid powering secondary mic permanently */
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cdc_pdm_lines_act &ext_sec_tlmm_lines_act &secondary_mic>;
+	pinctrl-1 = <&cdc_pdm_lines_sus &ext_sec_tlmm_lines_sus &secondary_mic>;
+
+	model = "samsung-a2015";
+};
+
+&msmgpio {
+	amp_i2c_default: amp-i2c-default {
+		pins = "gpio55", "gpio56";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	buckbooster_en_default: buckbooster-en-default {
+		pins = "gpio8";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio97";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+
+		mdss_sleep: mdss-sleep {
+			pins = "gpio97";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	secondary_mic: secondary-mic {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+		output-high;
+	};
+
+	reg_tsp_en_default: reg-tsp-en-default {
+		pins = "gpio73";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_default: tsp-int-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	vibrator_en_default: vibrator-en-default {
+		pins = "gpio76";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts
new file mode 100644
index 00000000000..d0fe73f26f2
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts
@@ -0,0 +1,304 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Samsung Galaxy J5 (2015)";
+	compatible = "samsung,j5", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home-key {
+			lable = "Home Key";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	i2c-sensors {
+		compatible = "i2c-gpio";
+
+		sda-gpios = <&msmgpio 31 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&msmgpio 32 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&sensors_i2c_default>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		accelerometer@1d {
+			compatible = "st,lis2hh12";
+			reg = <0x1d>;
+
+			interrupt-parent = <&msmgpio>;
+			interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "INT1";
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&accel_int_default>;
+
+			vdd-supply = <&pm8916_l17>;
+			vddio-supply = <&pm8916_l5>;
+
+			st,drdy-int-pin = <1>;
+		};
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		reg = <0>;
+
+		compatible = "samsung,s6e8aa5x01-ams497hy01";
+
+		vdd3-supply = <&pm8916_l6>;
+		vci-supply = <&pm8916_l17>;
+
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+/* FIXME: Replace with SM5703 MUIC when driver is available */
+&pm8916_usbin {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+	qcom,init-seq = /bits/ 8 <0x1 0x19 0x2 0x0b>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	accel_int_default: accel-int-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	sensors_i2c_default: sensors-i2c-default {
+		pins = "gpio31", "gpio32";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts
new file mode 100644
index 00000000000..34544bcc8ea
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Samsung Galaxy J5 (2016)";
+	compatible = "samsung,j5x", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home {
+			label = "Home";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+/* FIXME: Replace with SM5703 MUIC when driver is available */
+&pm8916_usbin {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	cd-gpios = <&msmgpio 38 GPIO_ACTIVE_LOW>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <3100000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts
new file mode 100644
index 00000000000..2d7dd1b21c7
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts
@@ -0,0 +1,620 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (C) 2019 Stephan Gerhold
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/*
+ * NOTE: The original firmware from Samsung can only boot ARM32 kernels.
+ * Unfortunately, the firmware is signed and cannot be replaced easily.
+ * There seems to be no way to boot ARM64 kernels on this device at the moment,
+ * even though the hardware would support it.
+ *
+ * However, it is possible to use this device tree by compiling an ARM32 kernel
+ * instead. For clarity and build testing this device tree is maintained next
+ * to the other MSM8916 device trees. However, it is actually used through
+ *   arch/arm/boot/dts/qcom-msm8916-samsung-serranove.dts
+ */
+
+/ {
+	model = "Samsung Galaxy S4 Mini Value Edition";
+	compatible = "samsung,serranove", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5a00000>;
+			no-map;
+		};
+
+		gps_mem: gps@8c200000 {
+			reg = <0x0 0x8c200000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home {
+			label = "Home";
+			gpios = <&msmgpio 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+
+		label = "GPIO Hall Effect Sensor";
+
+		hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&msmgpio 52 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+
+	reg_vdd_tsp: regulator-vdd-tsp {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_tsp";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_en_default>;
+	};
+
+	reg_touch_key: regulator-touch-key {
+		compatible = "regulator-fixed";
+		regulator-name = "touch_key";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+
+		gpio = <&msmgpio 86 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tkey_en_default>;
+	};
+
+	reg_key_led: regulator-key-led {
+		compatible = "regulator-fixed";
+		regulator-name = "key_led";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&msmgpio 60 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tkey_led_en_default>;
+	};
+
+	i2c-muic {
+		compatible = "i2c-gpio";
+		sda-gpios = <&msmgpio 105 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&msmgpio 106 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&muic_i2c_default>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		muic: extcon@14 {
+			compatible = "siliconmitus,sm5504-muic";
+			reg = <0x14>;
+
+			interrupt-parent = <&msmgpio>;
+			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&muic_irq_default>;
+		};
+	};
+
+	i2c-tkey {
+		compatible = "i2c-gpio";
+		sda-gpios = <&msmgpio 16 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&msmgpio 17 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tkey_i2c_default>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		touchkey@20 {
+			compatible = "coreriver,tc360-touchkey";
+			reg = <0x20>;
+
+			interrupt-parent = <&msmgpio>;
+			interrupts = <98 IRQ_TYPE_EDGE_FALLING>;
+
+			vcc-supply = <&reg_touch_key>;
+			vdd-supply = <&reg_key_led>;
+			vddio-supply = <&pm8916_l6>;
+
+			linux,keycodes = <KEY_APPSELECT KEY_BACK>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&tkey_default>;
+		};
+	};
+
+	i2c-nfc {
+		compatible = "i2c-gpio";
+		sda-gpios = <&msmgpio 0 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&msmgpio 1 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&nfc_i2c_default>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		nfc@2b {
+			compatible = "nxp,pn547", "nxp,nxp-nci-i2c";
+			reg = <0x2b>;
+
+			interrupt-parent = <&msmgpio>;
+			interrupts = <21 IRQ_TYPE_EDGE_RISING>;
+
+			enable-gpios = <&msmgpio 20 GPIO_ACTIVE_HIGH>;
+			firmware-gpios = <&msmgpio 49 GPIO_ACTIVE_HIGH>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&nfc_default>;
+		};
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	imu@6b {
+		compatible = "st,lsm6ds3";
+		reg = <0x6b>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&imu_irq_default>;
+	};
+};
+
+&blsp_i2c4 {
+	status = "okay";
+
+	battery@35 {
+		compatible = "richtek,rt5033-battery";
+		reg = <0x35>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <121 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&fg_alert_default>;
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@20 {
+		compatible = "zinitix,bt541";
+		reg = <0x20>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		touchscreen-size-x = <540>;
+		touchscreen-size-y = <960>;
+
+		vdd-supply = <&reg_vdd_tsp>;
+		vddo-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tsp_irq_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "samsung,s6e88a0-ams427ap24";
+		reg = <0>;
+
+		vdd3-supply = <&pm8916_l17>;
+		vci-supply = <&pm8916_l6>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+
+	iris {
+		compatible = "qcom,wcn3660b";
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off>;
+
+	non-removable;
+
+	/*
+	 * FIXME: Disable UHS-I modes since tuning fails with:
+	 *
+	 * sdhci_msm 7864900.sdhci: mmc1: No tuning point found
+	 * mmc1: tuning execution failed: -5
+	 * mmc1: error -5 whilst initialising SD card
+	 *
+	 * This is the quirk used on downstream, which suggests this is
+	 * a hardware limitation. However, probing a card using DDR50 works
+	 * (without tuning), so maybe only tuning is broken?
+	 */
+	no-1-8-v;
+};
+
+&sound {
+	status = "okay";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+};
+
+&usb {
+	status = "okay";
+	extcon = <&muic>, <&muic>;
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&wcd_codec {
+	jack-gpios = <&msmgpio 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	fg_alert_default: fg-alert-default {
+		pins = "gpio121";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default {
+		pins = "gpio52";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	imu_irq_default: imu-irq-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	jack_default: jack-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	muic_i2c_default: muic-i2c-default {
+		pins = "gpio105", "gpio106";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	muic_irq_default: muic-irq-default {
+		pins = "gpio12";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	nfc_default: nfc-default {
+		pins = "gpio20", "gpio49";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+
+		irq {
+			pins = "gpio21";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	nfc_i2c_default: nfc-i2c-default {
+		pins = "gpio0", "gpio1";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tkey_default: tkey-default {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tkey_en_default: tkey-en-default {
+		pins = "gpio86";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tkey_i2c_default: tkey-i2c-default {
+		pins = "gpio16", "gpio17";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tkey_led_en_default: tkey-led-en-default {
+		pins = "gpio60";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en_default: tsp-en-default {
+		pins = "gpio73";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_irq_default: tsp-irq-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts
new file mode 100644
index 00000000000..5ad69e88cf0
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-wingtech-wt865x8.dtsi"
+
+/ {
+	model = "Lenovo A6000 (Wingtech WT86518)";
+	compatible = "wingtech,wt86518", "qcom,msm8916";
+	chassis-type = "handset";
+
+	speaker_amp: audio-amplifier {
+		compatible = "awinic,aw8738";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&spk_ext_pa_default>;
+
+		enable-gpios = <&msmgpio 119 GPIO_ACTIVE_HIGH>;
+		aw8738,mode = <1>;
+		sound-name-prefix = "Speaker Amp";
+	};
+};
+
+&blsp_i2c2 {
+	accelerometer@e {
+		compatible = "kionix,kxcj91008";
+		reg = <0xe>;
+
+		vdd-supply = <&pm8916_l6>;
+		vddio-supply = <&pm8916_l6>;
+
+		mount-matrix = "0", "-1", "0",
+			       "-1", "0", "0",
+			       "0",  "0", "1";
+	};
+};
+
+&gps_mem {
+	status = "disabled";
+};
+
+&headphones_switch {
+	VCC-supply = <&pm8916_l17>;
+};
+
+&memshare {
+	status = "disabled";
+};
+
+&pm8916_charger {
+	status = "okay";
+
+	qcom,vdd-safe = <4300000>;
+	qcom,ibat-safe = <900000>;
+
+	monitored-battery = <&battery>;
+};
+
+&pm8916_bms {
+	power-supplies = <&pm8916_charger>;
+};
+
+&reg_lcd_neg {
+	regulator-min-microvolt = <5400000>;
+	regulator-max-microvolt = <5400000>;
+};
+
+&reg_lcd_pos {
+	regulator-min-microvolt = <5400000>;
+	regulator-max-microvolt = <5400000>;
+};
+
+&sound {
+	status = "okay";
+
+	model = "wt88047";
+	audio-routing =
+		"Speaker Amp IN", "HPH_R_EXT",
+		"Headphones Switch INL", "HPH_L",
+		"Headphones Switch INR", "HPH_R",
+		"AMIC1", "MIC BIAS Internal1",
+		"AMIC2", "MIC BIAS Internal2";
+	aux-devs = <&speaker_amp>, <&headphones_switch>;
+};
+
+&usb {
+	dr_mode = "peripheral";
+	extcon = <&pm8916_charger>;
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_charger>;
+};
+
+&msmgpio {
+	spk_ext_pa_default: spk-ext-pa-default {
+		pins = "gpio119";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts
new file mode 100644
index 00000000000..5ddd31d39cb
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-wingtech-wt865x8.dtsi"
+
+/ {
+	model = "Lenovo A6010 (Wingtech WT86528)";
+	compatible = "wingtech,wt86528", "qcom,msm8916";
+	chassis-type = "handset";
+
+	/* left AW8736 */
+	speaker_amp_left: audio-amplifier-left {
+		compatible = "awinic,aw8738";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&spk_ext_pa_left_default>;
+
+		enable-gpios = <&msmgpio 119 GPIO_ACTIVE_HIGH>;
+		aw8738,mode = <3>;
+		sound-name-prefix = "Speaker Amp L";
+	};
+
+	/* right AW8736 */
+	speaker_amp_right: audio-amplifier-right {
+		compatible = "awinic,aw8738";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&spk_ext_pa_right_default>;
+
+		enable-gpios = <&msmgpio 121 GPIO_ACTIVE_HIGH>;
+		aw8738,mode = <3>;
+		sound-name-prefix = "Speaker Amp R";
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_leds_default>;
+
+		led-0 {
+			gpios = <&msmgpio 16 GPIO_ACTIVE_LOW>;
+			label = "red";
+			default-state = "off";
+			retain-state-suspended;
+		};
+
+		led-1 {
+			gpios = <&msmgpio 17 GPIO_ACTIVE_HIGH>;
+			label = "green";
+			default-state = "off";
+			retain-state-suspended;
+		};
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpios = <&msmgpio 110 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb_id_default>;
+	};
+};
+
+&blsp_i2c2 {
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+
+		vdd-supply = <&pm8916_l17>;
+		vid-supply = <&pm8916_l6>;
+	};
+
+	imu@68 {
+		compatible = "invensense,mpu6880";
+		reg = <0x68>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&imu_default>;
+
+		mount-matrix = "1",  "0", "0",
+			       "0", "-1", "0",
+			       "0",  "0", "1";
+	};
+};
+
+&reg_lcd_neg {
+	regulator-min-microvolt = <5000000>;
+	regulator-max-microvolt = <5000000>;
+};
+
+&reg_lcd_pos {
+	regulator-min-microvolt = <5000000>;
+	regulator-max-microvolt = <5000000>;
+};
+
+&sound {
+	status = "okay";
+
+	model = "wt86528";
+	audio-routing =
+		"Speaker Amp L IN", "HPH_L_EXT",
+		"Speaker Amp R IN", "HPH_R_EXT",
+		"Headphones Switch INL", "HPH_L",
+		"Headphones Switch INR", "HPH_R",
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+	aux-devs = <&speaker_amp_left>, <&speaker_amp_right>, <&headphones_switch>;
+};
+
+&usb {
+	extcon = <&usb_id>, <&usb_id>;
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+};
+
+&msmgpio {
+	gpio_leds_default: gpio-leds-default {
+		pins = "gpio16", "gpio17";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	imu_default: imu-default {
+		pins = "gpio115";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	spk_ext_pa_left_default: spk-ext-pa-left-default {
+		pins = "gpio119";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	spk_ext_pa_right_default: spk-ext-pa-right-default {
+		pins = "gpio121";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb_id_default: usb-id-default {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi
new file mode 100644
index 00000000000..02cf1334b1f
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi
@@ -0,0 +1,395 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		mpss_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5500000>;
+			no-map;
+		};
+
+		gps_mem: gps@8bd00000 {
+			reg = <0x0 0x8bd00000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	headphones_switch: audio-switch {
+		compatible = "simple-audio-amplifier";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&headphones_switch_default>;
+
+		enable-gpios = <&msmgpio 120 GPIO_ACTIVE_HIGH>;
+		sound-name-prefix = "Headphones Switch";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <8740000>;
+		charge-full-design-microamp-hours = <2300000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4328000 100>, <4266000 95>, <4208000 90>,
+			<4154000 85>, <4102000 80>, <4062000 75>, <3992000 70>,
+			<3960000 65>, <3914000 60>, <3870000 55>, <3840000 50>,
+			<3818000 45>, <3800000 40>, <3784000 35>, <3770000 30>,
+			<3756000 25>, <3736000 20>, <3714000 16>, <3696000 13>,
+			<3690000 11>, <3689000 10>, <3688000 9>, <3686000 8>,
+			<3682000 7>, <3670000 6>, <3639000 5>, <3592000 4>,
+			<3530000 3>, <3448000 2>, <3320000 1>, <3000000 0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_default>;
+
+		label = "GPIO Buttons";
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&msmgpio 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&tps65132_en_default>;
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			enable-gpios = <&msmgpio 118 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			enable-gpios = <&msmgpio 117 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@38 {
+		/* actually FT5336 */
+		compatible = "edt,edt-ft5306";
+		reg = <0x38>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vcc-supply = <&pm8916_l17>;
+		iovcc-supply = <&pm8916_l6>;
+
+		reset-gpios = <&msmgpio 12 GPIO_ACTIVE_LOW>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_default>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "wingtech,wt865x8-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+
+		backlight = <&backlight>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm8916_bms {
+	status = "okay";
+	monitored-battery = <&battery>;
+};
+
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
+&pm8916_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&pronto {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off>;
+
+	non-removable;
+};
+
+&usb {
+	status = "okay";
+};
+
+&wcd_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&smd_rpm_regulators {
+	vdd_l1_l2_l3-supply = <&pm8916_s3>;
+	vdd_l4_l5_l6-supply = <&pm8916_s4>;
+	vdd_l7-supply = <&pm8916_s4>;
+
+	s3 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	s4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2100000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1225000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <2050000>;
+		regulator-max-microvolt = <2050000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2800000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l16 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&msmgpio {
+	gpio_keys_default: gpio-keys-default {
+		pins = "gpio107";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	headphones_switch_default: headphones-switch-default {
+		pins = "gpio120";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss {
+		mdss_default: mdss-default {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_sleep: mdss-sleep {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	touchscreen_default: touchscreen-default {
+		pins = "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+
+		reset {
+			pins = "gpio12";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	tps65132_en_default: tps65132-en-default {
+		pins = "gpio117", "gpio118";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4 {
+		pins = "mpp4";
+		function = "digital";
+
+		output-low;
+		qcom,dtest = <1>;
+		power-source = <PM8916_MPP_VPH>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
index 4e20cc0008f..b50a3b86637 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
@@ -4,13 +4,17 @@
 /dts-v1/;
 
 #include "msm8916-pm8916.dtsi"
+#include "msm8916-modem.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "Xiaomi Redmi 2 (Wingtech WT88047)";
 	compatible = "wingtech,wt88047", "qcom,msm8916";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
@@ -20,6 +24,47 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	reserved-memory {
+		mpss_mem: gps_mem: mpss@86800000 {
+			reg = <0x0 0x86800000 0x0 0x5100000>;
+			no-map;
+		};
+	};
+
+	speaker_amp: audio-amplifier {
+		compatible = "simple-audio-amplifier";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&speaker_amp_default>;
+
+		enable-gpios = <&msmgpio 117 GPIO_ACTIVE_HIGH>;
+		sound-name-prefix = "Speaker Amp";
+	};
+
+	/*
+	 * According to the schematics this is actually an analog switch,
+	 * but given that we need to enable the GPIO to get sound on headphones,
+	 * modelling it as simple-audio-amplifier seems to work just fine.
+	 */
+	headphones_switch: audio-switch {
+		compatible = "simple-audio-amplifier";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&headphones_switch_default>;
+
+		enable-gpios = <&msmgpio 8 GPIO_ACTIVE_HIGH>;
+		sound-name-prefix = "Headphones Switch";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	gpio-keys {
 		compatible = "gpio-keys";
 
@@ -65,6 +110,62 @@ imu@68 {
 	};
 };
 
+&blsp_i2c4 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&msmgpio>;
+		interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+
+		/*
+		 * Some properties are battery-specific. Battery detection
+		 * happens in the bootloader, so it will fill those appropriately
+		 * and set status = "okay".
+		 */
+		status = "disabled";
+
+		qcom,rsense-10mohm;
+
+		qcom,float-voltage-mv = <4350>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <192>; /* Not configured in downstream */
+		qcom,chg-inhibit-disabled;
+
+		qcom,fg-batt-capacity-mah = <0>; /* Set by bootloader */
+		qcom,fg-cc-soc-coeff = <0>; /* Set by bootloader */
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-iterm-ma = <150>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4328>;
+		qcom,thermistor-c1-coeff = <0>; /* Set by bootloader */
+		qcom,fg-auto-recharge-soc = <95>; /* 99 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <600>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,soft-jeita-config;
+		qcom,warm-bat-decidegc = <450>;
+		qcom,cool-bat-decidegc = <100>;
+		qcom,soft-jeita-comp-voltage-mv = <4000>;
+		qcom,soft-jeita-comp-current-ma = <600>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <100>;
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <950000>;
+		};
+	};
+};
+
 &blsp_i2c5 {
 	status = "okay";
 
@@ -127,6 +228,57 @@ &blsp1_uart2 {
 	status = "okay";
 };
 
+&dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "wingtech,wt88047-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi_phy0 {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
+/*
+ * The modem firmware sends a "query_size" memshare request for client ID 1,
+ * but basically does not do anything with it. GPS works only if:
+ *   - Memshare is not present or
+ *   - Memshare replies to the request with an error
+ * Overall it seems pointless to enable memshare for this device.
+ */
+&memshare {
+	status = "disabled";
+};
+
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -158,13 +310,36 @@ &sdhc_2 {
 	non-removable;
 };
 
+&sound {
+	status = "okay";
+
+	model = "wt88047";
+	audio-routing =
+		"Speaker Amp INL", "HPH_R_EXT",
+		"Speaker Amp INR", "HPH_R_EXT",
+		"Headphones Switch INL", "HPH_L",
+		"Headphones Switch INR", "HPH_R",
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2";
+	aux-devs = <&speaker_amp>, <&headphones_switch>;
+};
+
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
+};
+
+&wcd_codec {
+	qcom,micbias1-ext-cap;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
 };
 
 &smd_rpm_regulators {
@@ -279,6 +454,14 @@ gpio_keys_default: gpio-keys-default {
 		bias-pull-up;
 	};
 
+	headphones_switch_default: headphones-switch-default {
+		pins = "gpio8";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	imu_default: imu-default {
 		pins = "gpio115";
 		function = "gpio";
@@ -287,6 +470,39 @@ imu_default: imu-default {
 		bias-disable;
 	};
 
+	mdss {
+		mdss_active: mdss-active {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <8>;
+			bias-disable;
+		};
+		mdss_suspend: mdss-suspend {
+			pins = "gpio25";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	smb_int_default: smb_int_default {
+		pins = "gpio62";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	speaker_amp_default: speaker-amp-default {
+		pins = "gpio117";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	touchscreen_default: touchscreen-default {
 		pins = "gpio13";
 		function = "gpio";
@@ -311,3 +527,14 @@ usb_id_default: usb-id-default {
 		bias-pull-up;
 	};
 };
+
+&pm8916_mpps {
+	pwm_out: mpp4 {
+		pins = "mpp4";
+		function = "digital";
+
+		output-low;
+		qcom,dtest = <1>;
+		power-source = <PM8916_MPP_VPH>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916.dtsi b/arch/arm64/boot/dts/qcom/msm8916.dtsi
index 19e201f52b1..cff334a3a78 100644
--- a/arch/arm64/boot/dts/qcom/msm8916.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916.dtsi
@@ -10,6 +10,8 @@
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/power/qcom-rpmpd.h>
 #include <dt-bindings/reset/qcom,gcc-msm8916.h>
+#include <dt-bindings/soc/qcom,apr.h>
+#include <dt-bindings/soc/qcom,memshare.h>
 #include <dt-bindings/thermal/thermal.h>
 
 / {
@@ -79,19 +81,19 @@ mpss_mem: mpss@86800000 {
 			no-map;
 		};
 
-		wcnss_mem: wcnss@89300000 {
-			reg = <0x0 0x89300000 0x0 0x600000>;
+		wcnss_mem: wcnss@8df00000 {
+			reg = <0x0 0x8df00000 0x0 0x600000>;
 			no-map;
 		};
 
-		venus_mem: venus@89900000 {
-			reg = <0x0 0x89900000 0x0 0x600000>;
+		venus_mem: venus@8e500000 {
+			reg = <0x0 0x8e500000 0x0 0x500000>;
 			no-map;
 		};
 
 		mba_mem: mba@8ea00000 {
+			reg = <0x0 0x8ea00000 0x0 0x100000>;
 			no-map;
-			reg = <0 0x8ea00000 0 0x100000>;
 		};
 	};
 
@@ -124,6 +126,8 @@ CPU0: cpu@0 {
 			#cooling-cells = <2>;
 			power-domains = <&CPU_PD0>;
 			power-domain-names = "psci";
+			qcom,acc = <&cpu0_acc>;
+			qcom,saw = <&cpu0_saw>;
 		};
 
 		CPU1: cpu@1 {
@@ -137,6 +141,8 @@ CPU1: cpu@1 {
 			#cooling-cells = <2>;
 			power-domains = <&CPU_PD1>;
 			power-domain-names = "psci";
+			qcom,acc = <&cpu1_acc>;
+			qcom,saw = <&cpu1_saw>;
 		};
 
 		CPU2: cpu@2 {
@@ -150,6 +156,8 @@ CPU2: cpu@2 {
 			#cooling-cells = <2>;
 			power-domains = <&CPU_PD2>;
 			power-domain-names = "psci";
+			qcom,acc = <&cpu2_acc>;
+			qcom,saw = <&cpu2_saw>;
 		};
 
 		CPU3: cpu@3 {
@@ -163,6 +171,8 @@ CPU3: cpu@3 {
 			#cooling-cells = <2>;
 			power-domains = <&CPU_PD3>;
 			power-domain-names = "psci";
+			qcom,acc = <&cpu3_acc>;
+			qcom,saw = <&cpu3_saw>;
 		};
 
 		L2_0: l2-cache {
@@ -235,6 +245,28 @@ scm: scm {
 		};
 	};
 
+	memshare: memshare {
+		compatible = "qcom,memshare";
+		qcom,legacy-client = <&memshare_gps>;
+
+		status = "disabled";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		mpss@0 {
+			reg = <MEMSHARE_PROC_MPSS_V01>;
+			qcom,qrtr-node = <0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			memshare_gps: gps@0 {
+				reg = <0>;
+			};
+		};
+	};
+
 	pmu {
 		compatible = "arm,cortex-a53-pmu";
 		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
@@ -1306,6 +1338,20 @@ spmi_bus: spmi@200f000 {
 			#interrupt-cells = <4>;
 		};
 
+		bam_dmux_dma: dma-controller@4044000 {
+			compatible = "qcom,bam-v1.7.0";
+			reg = <0x04044000 0x19000>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			#dma-cells = <1>;
+			qcom,ee = <0>;
+
+			num-channels = <6>;
+			qcom,num-ees = <1>;
+			qcom,powered-remotely;
+
+			status = "disabled";
+		};
+
 		mpss: remoteproc@4080000 {
 			compatible = "qcom,msm8916-mss-pil", "qcom,q6v5-pil";
 			reg = <0x04080000 0x100>,
@@ -1349,6 +1395,22 @@ mpss {
 				memory-region = <&mpss_mem>;
 			};
 
+			bam_dmux: bam-dmux {
+				compatible = "qcom,bam-dmux";
+
+				interrupt-parent = <&hexagon_smsm>;
+				interrupts = <1 IRQ_TYPE_EDGE_BOTH>, <11 IRQ_TYPE_EDGE_BOTH>;
+				interrupt-names = "pc", "pc-ack";
+
+				qcom,smem-states = <&apps_smsm 1>, <&apps_smsm 11>;
+				qcom,smem-state-names = "pc", "pc-ack";
+
+				dmas = <&bam_dmux_dma 4>, <&bam_dmux_dma 5>;
+				dma-names = "tx", "rx";
+
+				status = "disabled";
+			};
+
 			smd-edge {
 				interrupts = <GIC_SPI 25 IRQ_TYPE_EDGE_RISING>;
 
@@ -1358,6 +1420,71 @@ smd-edge {
 
 				label = "hexagon";
 
+				apr: apr {
+					compatible = "qcom,apr-v2";
+					qcom,smd-channels = "apr_audio_svc";
+					qcom,apr-domain = <APR_DOMAIN_ADSP>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					status = "disabled";
+
+					apr-service@3 {
+						reg = <APR_SVC_ADSP_CORE>;
+						compatible = "qcom,q6core";
+					};
+
+					q6afe: apr-service@4 {
+						compatible = "qcom,q6afe";
+						reg = <APR_SVC_AFE>;
+						q6afedai: dais {
+							compatible = "qcom,q6afe-dais";
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#sound-dai-cells = <1>;
+						};
+					};
+
+					q6asm: apr-service@7 {
+						compatible = "qcom,q6asm";
+						reg = <APR_SVC_ASM>;
+						q6asmdai: dais {
+							compatible = "qcom,q6asm-dais";
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#sound-dai-cells = <1>;
+						};
+					};
+
+					q6adm: apr-service@8 {
+						compatible = "qcom,q6adm";
+						reg = <APR_SVC_ADM>;
+						q6routing: routing {
+							compatible = "qcom,q6adm-routing";
+							#sound-dai-cells = <0>;
+						};
+					};
+
+					q6mvm: apr-service@9 {
+						compatible = "qcom,q6mvm";
+						reg = <APR_SVC_ADSP_MVM>;
+
+						q6voicedai: dais {
+							compatible = "qcom,q6voice-dais";
+							#sound-dai-cells = <0>;
+						};
+					};
+
+					q6cvs: apr-service@a {
+						compatible = "qcom,q6cvs";
+						reg = <APR_SVC_ADSP_CVS>;
+					};
+
+					q6cvp: apr-service@b {
+						compatible = "qcom,q6cvp";
+						reg = <APR_SVC_ADSP_CVP>;
+					};
+				};
+
 				fastrpc {
 					compatible = "qcom,fastrpc";
 					qcom,smd-channels = "fastrpcsmd-apps-dsp";
@@ -1426,7 +1553,7 @@ lpass_codec: audio-codec@771c000 {
 		};
 
 		sdhc_1: sdhci@7824000 {
-			compatible = "qcom,sdhci-msm-v4";
+			compatible = "qcom,msm8916-sdhci", "qcom,sdhci-msm-v4";
 			reg = <0x07824900 0x11c>, <0x07824000 0x800>;
 			reg-names = "hc_mem", "core_mem";
 
@@ -1444,7 +1571,7 @@ sdhc_1: sdhci@7824000 {
 		};
 
 		sdhc_2: sdhci@7864000 {
-			compatible = "qcom,sdhci-msm-v4";
+			compatible = "qcom,msm8916-sdhci", "qcom,sdhci-msm-v4";
 			reg = <0x07864900 0x11c>, <0x07864000 0x800>;
 			reg-names = "hc_mem", "core_mem";
 
@@ -1771,7 +1898,7 @@ smd-edge {
 
 				label = "pronto";
 
-				wcnss {
+				wcnss_ctrl: wcnss {
 					compatible = "qcom,wcnss";
 					qcom,smd-channels = "WCNSS_CTRL";
 
@@ -1877,6 +2004,54 @@ frame@b028000 {
 				status = "disabled";
 			};
 		};
+
+		cpu0_acc: power-manager@b088000 {
+			compatible = "qcom,msm8916-acc";
+			reg = <0x0b088000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu0_saw: power-manager@b089000 {
+			compatible = "qcom,msm8916-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b089000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu1_acc: power-manager@b098000 {
+			compatible = "qcom,msm8916-acc";
+			reg = <0x0b098000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu1_saw: power-manager@b099000 {
+			compatible = "qcom,msm8916-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b099000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu2_acc: power-manager@b0a8000 {
+			compatible = "qcom,msm8916-acc";
+			reg = <0x0b0a8000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu2_saw: power-manager@b0a9000 {
+			compatible = "qcom,msm8916-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b0a9000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu3_acc: power-manager@b0b8000 {
+			compatible = "qcom,msm8916-acc";
+			reg = <0x0b0b8000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
+
+		cpu3_saw: power-manager@b0b9000 {
+			compatible = "qcom,msm8916-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b0b9000 0x1000>;
+			status = "reserved"; /* Controlled by PSCI firmware */
+		};
 	};
 
 	thermal-zones {
diff --git a/arch/arm64/boot/dts/qcom/msm8992-bullhead-rev-101.dts b/arch/arm64/boot/dts/qcom/msm8992-bullhead-rev-101.dts
index c7d191dc6d4..0db13f62e90 100644
--- a/arch/arm64/boot/dts/qcom/msm8992-bullhead-rev-101.dts
+++ b/arch/arm64/boot/dts/qcom/msm8992-bullhead-rev-101.dts
@@ -16,6 +16,8 @@
 / {
 	model = "LG Nexus 5X";
 	compatible = "lg,bullhead", "qcom,msm8992";
+	chassis-type = "handset";
+
 	/* required for bootloader to select correct board */
 	qcom,msm-id = <251 0>, <252 0>;
 	qcom,board-id = <0xb64 0>;
diff --git a/arch/arm64/boot/dts/qcom/msm8992-msft-lumia-octagon-talkman.dts b/arch/arm64/boot/dts/qcom/msm8992-msft-lumia-octagon-talkman.dts
index 5322b9ce583..8933b53694e 100644
--- a/arch/arm64/boot/dts/qcom/msm8992-msft-lumia-octagon-talkman.dts
+++ b/arch/arm64/boot/dts/qcom/msm8992-msft-lumia-octagon-talkman.dts
@@ -12,4 +12,5 @@
 / {
 	model = "Microsoft Lumia 950";
 	compatible = "microsoft,talkman", "qcom,msm8992";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8992-xiaomi-libra.dts b/arch/arm64/boot/dts/qcom/msm8992-xiaomi-libra.dts
index a3d6340a0c5..3c13a888592 100644
--- a/arch/arm64/boot/dts/qcom/msm8992-xiaomi-libra.dts
+++ b/arch/arm64/boot/dts/qcom/msm8992-xiaomi-libra.dts
@@ -14,6 +14,8 @@
 / {
 	model = "Xiaomi Mi 4C";
 	compatible = "xiaomi,libra", "qcom,msm8992";
+	chassis-type = "handset";
+
 	/* required for bootloader to select correct board */
 	qcom,msm-id = <251 0 252 0>;
 	qcom,pmic-id = <65545 65546 0 0>;
diff --git a/arch/arm64/boot/dts/qcom/msm8994-angler-rev-101.dts b/arch/arm64/boot/dts/qcom/msm8994-angler-rev-101.dts
index c096b7758aa..0e3dd48f0db 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-angler-rev-101.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-angler-rev-101.dts
@@ -14,6 +14,7 @@
 / {
 	model = "Huawei Nexus 6P";
 	compatible = "huawei,angler", "qcom,msm8994";
+	chassis-type = "handset";
 	/* required for bootloader to select correct board */
 	qcom,msm-id = <207 0x20000>;
 	qcom,pmic-id = <0x10009 0x1000A 0x0 0x0>;
diff --git a/arch/arm64/boot/dts/qcom/msm8994-msft-lumia-octagon-cityman.dts b/arch/arm64/boot/dts/qcom/msm8994-msft-lumia-octagon-cityman.dts
index d0aaf5750c2..c593418202b 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-msft-lumia-octagon-cityman.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-msft-lumia-octagon-cityman.dts
@@ -12,4 +12,5 @@
 / {
 	model = "Microsoft Lumia 950 XL";
 	compatible = "microsoft,cityman", "qcom,msm8994";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-ivy.dts b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-ivy.dts
index b5e90c85aaf..99388b019a1 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-ivy.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-ivy.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia Z3+/Z4";
 	compatible = "sony,ivy-row", "qcom,msm8994";
+	chassis-type = "handset";
 };
 
 &pm8994_l3 {
diff --git a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-karin.dts b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-karin.dts
index a1d1a075941..71758d2cfd5 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-karin.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-karin.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia Z4 Tablet (LTE)";
 	compatible = "sony,karin-row", "qcom,msm8994";
+	chassis-type = "tablet";
 };
 
 &blsp2_i2c5 {
diff --git a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-satsuki.dts b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-satsuki.dts
index 1385956a69f..69b7df0ed60 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-satsuki.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-satsuki.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia Z5 Premium";
 	compatible = "sony,satsuki-row", "qcom,msm8994";
+	chassis-type = "handset";
 };
 
 &pm8994_l14 {
diff --git a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-sumire.dts b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-sumire.dts
index d3ba9867a36..466508cd823 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-sumire.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-sumire.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia Z5";
 	compatible = "sony,sumire-row", "qcom,msm8994";
+	chassis-type = "handset";
 };
 
 /delete-node/ &pm8994_l19;
diff --git a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-suzuran.dts b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-suzuran.dts
index f129479bbf9..76bf50191f9 100644
--- a/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-suzuran.dts
+++ b/arch/arm64/boot/dts/qcom/msm8994-sony-xperia-kitakami-suzuran.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia Z5 Compact";
 	compatible = "sony,suzuran-row", "qcom,msm8994";
+	chassis-type = "handset";
 };
 
 &pm8994_l14 {
diff --git a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-dora.dts b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-dora.dts
index b4cca54dcb6..4a0645db0ae 100644
--- a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-dora.dts
+++ b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-dora.dts
@@ -12,6 +12,7 @@
 / {
 	model = "Sony Xperia X Performance";
 	compatible = "sony,dora-row", "qcom,msm8996";
+	chassis-type = "handset";
 };
 
 /delete-node/ &tof_sensor;
diff --git a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-kagura.dts b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-kagura.dts
index be6ea855fcc..d3100ddf926 100644
--- a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-kagura.dts
+++ b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-kagura.dts
@@ -12,4 +12,5 @@
 / {
 	model = "Sony Xperia XZ";
 	compatible = "sony,kagura-row", "qcom,msm8996";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-keyaki.dts b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-keyaki.dts
index 1eee7d0fc17..3e5bdaba837 100644
--- a/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-keyaki.dts
+++ b/arch/arm64/boot/dts/qcom/msm8996-sony-xperia-tone-keyaki.dts
@@ -12,6 +12,7 @@
 / {
 	model = "Sony Xperia XZs";
 	compatible = "sony,keyaki-row", "qcom,msm8996";
+	chassis-type = "handset";
 };
 
 &pm8994_l19 {
diff --git a/arch/arm64/boot/dts/qcom/msm8998-asus-novago-tp370ql.dts b/arch/arm64/boot/dts/qcom/msm8998-asus-novago-tp370ql.dts
index db5821be1e2..e204b705044 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-asus-novago-tp370ql.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-asus-novago-tp370ql.dts
@@ -8,6 +8,7 @@
 / {
 	model = "Asus NovaGo TP370QL";
 	compatible = "asus,novago-tp370ql", "qcom,msm8998";
+	chassis-type = "convertible";
 };
 
 &blsp1_i2c6 {
diff --git a/arch/arm64/boot/dts/qcom/msm8998-hp-envy-x2.dts b/arch/arm64/boot/dts/qcom/msm8998-hp-envy-x2.dts
index 24073127091..1eb406b43fd 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-hp-envy-x2.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-hp-envy-x2.dts
@@ -8,6 +8,7 @@
 / {
 	model = "HP Envy x2";
 	compatible = "hp,envy-x2", "qcom,msm8998";
+	chassis-type = "convertible";
 };
 
 &blsp1_i2c6 {
diff --git a/arch/arm64/boot/dts/qcom/msm8998-lenovo-miix-630.dts b/arch/arm64/boot/dts/qcom/msm8998-lenovo-miix-630.dts
index 89492ed5196..f55f6f3e3e5 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-lenovo-miix-630.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-lenovo-miix-630.dts
@@ -8,6 +8,7 @@
 / {
 	model = "Lenovo Miix 630";
 	compatible = "lenovo,miix-630", "qcom,msm8998";
+	chassis-type = "convertible";
 };
 
 &blsp1_i2c6 {
diff --git a/arch/arm64/boot/dts/qcom/msm8998-oneplus-cheeseburger.dts b/arch/arm64/boot/dts/qcom/msm8998-oneplus-cheeseburger.dts
index 66b9297588a..9563eb62db8 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-oneplus-cheeseburger.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-oneplus-cheeseburger.dts
@@ -11,6 +11,7 @@
 / {
 	model = "OnePlus 5";
 	compatible = "oneplus,cheeseburger", "qcom,msm8998";
+	chassis-type = "handset";
 	/* Required for bootloader to select correct board */
 	qcom,board-id = <8 0 16859 23>;
 
diff --git a/arch/arm64/boot/dts/qcom/msm8998-oneplus-dumpling.dts b/arch/arm64/boot/dts/qcom/msm8998-oneplus-dumpling.dts
index 544b9b0ae44..5d0dabbaee4 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-oneplus-dumpling.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-oneplus-dumpling.dts
@@ -10,6 +10,7 @@
 / {
 	model = "OnePlus 5T";
 	compatible = "oneplus,dumpling", "qcom,msm8998";
+	chassis-type = "handset";
 	/* Required for bootloader to select correct board */
 	qcom,board-id = <8 0 17801 43>;
 };
diff --git a/arch/arm64/boot/dts/qcom/pm8916.dtsi b/arch/arm64/boot/dts/qcom/pm8916.dtsi
index 42180f1b5db..ac40081cd70 100644
--- a/arch/arm64/boot/dts/qcom/pm8916.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm8916.dtsi
@@ -41,6 +41,21 @@ watchdog {
 			};
 		};
 
+		pm8916_charger: charger@1000 {
+			compatible = "qcom,pm8916-lbc";
+			reg = <0x1000>, <0x1200>, <0x1300>, <0x1600>;
+			interrupts = <0x0 0x13 1 IRQ_TYPE_EDGE_BOTH>;
+			status = "disabled";
+		};
+
+		pm8916_usbin: extcon@1300 {
+			compatible = "qcom,pm8941-misc";
+			reg = <0x1300>;
+			interrupts = <0x0 0x13 1 IRQ_TYPE_EDGE_BOTH>;
+			interrupt-names = "usb_vbus";
+			status = "disabled";
+		};
+
 		pm8916_temp: temp-alarm@2400 {
 			compatible = "qcom,spmi-temp-alarm";
 			reg = <0x2400>;
@@ -83,6 +98,13 @@ adc-chan@f {
 			};
 		};
 
+		pm8916_bms: vm-bms@4000 {
+			compatible = "qcom,pm8916-bms-vm";
+			reg = <0x4000>;
+			interrupts = <0x0 0x40 4 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+		};
+
 		rtc@6000 {
 			compatible = "qcom,pm8941-rtc";
 			reg = <0x6000>;
@@ -118,6 +140,12 @@ pm8916_1: pmic@1 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		pm8916_pwm: pwm@bc00 {
+			compatible = "qcom,pm8916-pwm";
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
 		pm8916_vib: vibrator@c000 {
 			compatible = "qcom,pm8916-vib";
 			reg = <0xc000>;
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
index a4e1fb8ca52..71b448978e8 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
@@ -11,6 +11,7 @@
 / {
 	model = "Sony Xperia 10";
 	compatible = "sony,kirin-row", "qcom,sdm630";
+	chassis-type = "handset";
 
 	chosen {
 		framebuffer@9d400000 {
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
index c574e430ba6..dd484a9bc7c 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
@@ -11,4 +11,5 @@
 / {
 	model = "Sony Xperia XA2 Ultra";
 	compatible = "sony,discovery-row", "qcom,sdm630";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
index a93ff3ab1b6..2da83cd4118 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
@@ -11,4 +11,5 @@
 / {
 	model = "Sony Xperia XA2";
 	compatible = "sony,pioneer-row", "qcom,sdm630";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
index 59a679c205e..a679d4acee2 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
@@ -11,6 +11,7 @@
 / {
 	model = "Sony Xperia XA2 Plus";
 	compatible = "sony,voyager-row", "qcom,sdm630";
+	chassis-type = "handset";
 
 	chosen {
 		framebuffer@9d400000 {
diff --git a/arch/arm64/boot/dts/qcom/sdm636-sony-xperia-ganges-mermaid.dts b/arch/arm64/boot/dts/qcom/sdm636-sony-xperia-ganges-mermaid.dts
index 0afe9eee025..58f687fc49e 100644
--- a/arch/arm64/boot/dts/qcom/sdm636-sony-xperia-ganges-mermaid.dts
+++ b/arch/arm64/boot/dts/qcom/sdm636-sony-xperia-ganges-mermaid.dts
@@ -11,6 +11,7 @@
 / {
 	model = "Sony Xperia 10 Plus";
 	compatible = "sony,mermaid-row", "qcom,sdm636";
+	chassis-type = "handset";
 
 	/* SDM636 v1 */
 	qcom,msm-id = <345 0>;
diff --git a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
index 3e677fb7cfe..1edc53fd694 100644
--- a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
+++ b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Xiaomi Redmi Note 7";
 	compatible = "xiaomi,lavender", "qcom,sdm660";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &blsp1_uart2;
diff --git a/arch/arm64/boot/dts/qcom/sdm845-oneplus-enchilada.dts b/arch/arm64/boot/dts/qcom/sdm845-oneplus-enchilada.dts
index 72842c88761..73493079d13 100644
--- a/arch/arm64/boot/dts/qcom/sdm845-oneplus-enchilada.dts
+++ b/arch/arm64/boot/dts/qcom/sdm845-oneplus-enchilada.dts
@@ -10,6 +10,7 @@
 / {
 	model = "OnePlus 6";
 	compatible = "oneplus,enchilada", "qcom,sdm845";
+	chassis-type = "handset";
 };
 
 &display_panel {
diff --git a/arch/arm64/boot/dts/qcom/sdm845-oneplus-fajita.dts b/arch/arm64/boot/dts/qcom/sdm845-oneplus-fajita.dts
index 969b36dc9e2..b63ebc48f62 100644
--- a/arch/arm64/boot/dts/qcom/sdm845-oneplus-fajita.dts
+++ b/arch/arm64/boot/dts/qcom/sdm845-oneplus-fajita.dts
@@ -10,6 +10,7 @@
 / {
 	model = "OnePlus 6T";
 	compatible = "oneplus,fajita", "qcom,sdm845";
+	chassis-type = "handset";
 };
 
 &display_panel {
diff --git a/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts b/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
index 736951fabb7..d2935646b73 100644
--- a/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
+++ b/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
@@ -29,6 +29,7 @@
 / {
 	model = "Xiaomi Pocophone F1";
 	compatible = "xiaomi,beryllium", "qcom,sdm845";
+	chassis-type = "handset";
 
 	/* required for bootloader to select correct board */
 	qcom,board-id = <69 0>;
diff --git a/arch/arm64/boot/dts/qcom/sdm850-lenovo-yoga-c630.dts b/arch/arm64/boot/dts/qcom/sdm850-lenovo-yoga-c630.dts
index 617a634ac90..2c129509946 100644
--- a/arch/arm64/boot/dts/qcom/sdm850-lenovo-yoga-c630.dts
+++ b/arch/arm64/boot/dts/qcom/sdm850-lenovo-yoga-c630.dts
@@ -30,6 +30,7 @@
 / {
 	model = "Lenovo Yoga C630";
 	compatible = "lenovo,yoga-c630", "qcom,sdm845";
+	chassis-type = "convertible";
 
 	aliases {
 		hsuart0 = &uart6;
diff --git a/arch/arm64/boot/dts/qcom/sm6125-sony-xperia-seine-pdx201.dts b/arch/arm64/boot/dts/qcom/sm6125-sony-xperia-seine-pdx201.dts
index 47f8e5397eb..8bd27f7f38b 100644
--- a/arch/arm64/boot/dts/qcom/sm6125-sony-xperia-seine-pdx201.dts
+++ b/arch/arm64/boot/dts/qcom/sm6125-sony-xperia-seine-pdx201.dts
@@ -17,6 +17,7 @@ / {
 
 	model = "Sony Xperia 10 II";
 	compatible = "sony,pdx201", "qcom,sm6125";
+	chassis-type = "handset";
 
 	chosen {
 		#address-cells = <2>;
diff --git a/arch/arm64/boot/dts/qcom/sm8150-microsoft-surface-duo.dts b/arch/arm64/boot/dts/qcom/sm8150-microsoft-surface-duo.dts
index 736da9af44e..c99979d0486 100644
--- a/arch/arm64/boot/dts/qcom/sm8150-microsoft-surface-duo.dts
+++ b/arch/arm64/boot/dts/qcom/sm8150-microsoft-surface-duo.dts
@@ -15,6 +15,7 @@
 / {
 	model = "Microsoft Surface Duo";
 	compatible = "microsoft,surface-duo", "qcom,sm8150";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &uart2;
diff --git a/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-bahamut.dts b/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-bahamut.dts
index 3b55fdda767..b2780403255 100644
--- a/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-bahamut.dts
+++ b/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-bahamut.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia 5";
 	compatible = "sony,bahamut-generic", "qcom,sm8150";
+	chassis-type = "handset";
 };
 
 &framebuffer {
diff --git a/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-griffin.dts b/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-griffin.dts
index 6f490ec284b..0d6deceedf4 100644
--- a/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-griffin.dts
+++ b/arch/arm64/boot/dts/qcom/sm8150-sony-xperia-kumano-griffin.dts
@@ -10,4 +10,5 @@
 / {
 	model = "Sony Xperia 1";
 	compatible = "sony,griffin-generic", "qcom,sm8150";
+	chassis-type = "handset";
 };
diff --git a/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx203.dts b/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx203.dts
index 79afeb07f4a..356a8169873 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx203.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx203.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia 1 II";
 	compatible = "sony,pdx203-generic", "qcom,sm8250";
+	chassis-type = "handset";
 };
 
 /delete-node/ &vreg_l7f_1p8;
diff --git a/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx206.dts b/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx206.dts
index 16c96e83853..5ecf7dafb2e 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx206.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-sony-xperia-edo-pdx206.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Sony Xperia 5 II";
 	compatible = "sony,pdx206-generic", "qcom,sm8250";
+	chassis-type = "handset";
 };
 
 &framebuffer {
diff --git a/arch/arm64/configs/msm8916_defconfig b/arch/arm64/configs/msm8916_defconfig
new file mode 100644
index 00000000000..dd0b1460182
--- /dev/null
+++ b/arch/arm64/configs/msm8916_defconfig
@@ -0,0 +1,377 @@
+CONFIG_LOCALVERSION="-msm8916"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_ARCH_QCOM=y
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NR_CPUS=4
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_COMPAT=y
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_EFI is not set
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_ARM_QCOM_SPM_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_SM4_ARM64_CE=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_NHPOLY1305_NEON=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_QRTR=y
+CONFIG_QRTR_SMD=y
+CONFIG_QRTR_TUN=m
+CONFIG_BT=m
+CONFIG_BT_HIDP=m
+CONFIG_BT_LEDS=y
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_QCOMSMD=m
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=y
+CONFIG_NFC=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_NXP_NCI=m
+CONFIG_NFC_NXP_NCI_I2C=m
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_QCOM_EBI2 is not set
+CONFIG_OF_OVERLAY=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_VXLAN=m
+CONFIG_TUN=m
+CONFIG_VETH=m
+CONFIG_RMNET=m
+CONFIG_WCN36XX=m
+CONFIG_WWAN=y
+CONFIG_QCOM_BAM_DMUX=m
+CONFIG_RPMSG_WWAN_CTRL=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_TM2_TOUCHKEY=m
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_MMS114=m
+CONFIG_TOUCHSCREEN_MELFAS_MIP4=m
+CONFIG_TOUCHSCREEN_MSG2638=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_TOUCHSCREEN_ZINITIX=m
+CONFIG_TOUCHSCREEN_HIMAX852X=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+CONFIG_INPUT_PM8XXX_VIBRATOR=m
+CONFIG_INPUT_GPIO_VIBRA=m
+CONFIG_RMI4_CORE=m
+CONFIG_RMI4_I2C=m
+CONFIG_RMI4_F11=y
+CONFIG_RMI4_F12=y
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QUP=y
+CONFIG_I2C_SLAVE=y
+CONFIG_SPI=y
+CONFIG_SPI_MEM=y
+CONFIG_SPI_BITBANG=m
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_MSM8916=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_BATTERY_MAX17042=m
+CONFIG_SMB1360=m
+CONFIG_BATTERY_PM8916_BMS_VM=m
+CONFIG_CHARGER_PM8916_LBC=m
+CONFIG_BATTERY_RT5033=m
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_TEMP_ALARM=y
+CONFIG_WATCHDOG=y
+CONFIG_PM8916_WATCHDOG=y
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_RT5033=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_RT5033=m
+CONFIG_REGULATOR_TPS65132=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_V4L2_FLASH_LED_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_DRM=y
+CONFIG_DRM_MSM=m
+# CONFIG_DRM_MSM_HDMI_HDCP is not set
+# CONFIG_DRM_MSM_DP is not set
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01=m
+CONFIG_DRM_PANEL_MSM8916_GENERATED=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_LEGACY=y
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_SIMPLE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_LM3630A=m
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_APQ8016_SBC=m
+CONFIG_SND_SOC_QDSP6_Q6VOICE=m
+CONFIG_SND_SOC_MSM8916_QDSP6=m
+CONFIG_SND_SOC_AW8738=m
+CONFIG_SND_SOC_MAX98357A=m
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
+CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
+CONFIG_SND_SOC_TFA989X=m
+CONFIG_USB_LED_TRIG=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_GADGET=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=m
+CONFIG_LEDS_CLASS_MULTICOLOR=y
+CONFIG_LEDS_AW2013=m
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_QCOM_LPG=y
+CONFIG_LEDS_SGM3140=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PM8XXX=y
+CONFIG_DMADEVICES=y
+CONFIG_QCOM_BAM_DMA=y
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_QCOM_A53PLL=y
+CONFIG_QCOM_CLK_APCS_MSM8916=y
+CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_MSM_GCC_8916=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+CONFIG_MAILBOX=y
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_ARM_SMMU=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_QCOM_Q6V5_MSS=m
+CONFIG_QCOM_SYSMON=y
+CONFIG_QCOM_WCNSS_PIL=m
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_QCOM_SMD=y
+CONFIG_QCOM_CPR=y
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_QCOM_RPMPD=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SMSM=y
+CONFIG_QCOM_SOCINFO=y
+CONFIG_QCOM_WCNSS_CTRL=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_MEMSHARE_QMI_SERVICE=m
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_EXTCON_QCOM_SPMI_MISC=y
+CONFIG_EXTCON_SM5502=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_MEMORY=y
+CONFIG_IIO=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+CONFIG_BMC150_ACCEL=m
+CONFIG_IIO_ST_ACCEL_3AXIS=m
+CONFIG_KXCJK1013=m
+CONFIG_QCOM_SPMI_VADC=y
+CONFIG_BMG160=m
+CONFIG_BMI160_I2C=m
+CONFIG_INV_MPU6050_I2C=m
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_CM3323=m
+CONFIG_LTR501=m
+CONFIG_STK3310=m
+CONFIG_TSL2772=m
+CONFIG_AK8975=m
+CONFIG_BMC150_MAGN_I2C=m
+CONFIG_PWM=y
+CONFIG_PHY_QCOM_USB_HS=y
+CONFIG_QCOM_QFPROM=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_ZSTD_COMPRESS=y
+CONFIG_PSTORE_ZSTD_COMPRESS_DEFAULT=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_USER_API_AEAD=m
+CONFIG_CRYPTO_DEV_QCOM_RNG=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index 334f83e5612..1895ad49c68 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -107,11 +107,13 @@ config ARM_TEGRA_CPUIDLE
 
 config ARM_QCOM_SPM_CPUIDLE
 	bool "CPU Idle Driver for Qualcomm Subsystem Power Manager (SPM)"
-	depends on (ARCH_QCOM || COMPILE_TEST) && !ARM64 && MMU
+	depends on ARCH_QCOM || (ARCH_SUSPEND_POSSIBLE && COMPILE_TEST)
+	depends on HAVE_ARM_SMCCC
 	select ARM_CPU_SUSPEND
 	select CPU_IDLE_MULTIPLE_DRIVERS
 	select DT_IDLE_STATES
 	select QCOM_SCM
+	select QCOM_SPM
 	help
 	  Select this to enable cpuidle for Qualcomm processors.
 	  The Subsystem Power Manager (SPM) controls low power modes for the
diff --git a/drivers/cpuidle/cpuidle-qcom-spm.c b/drivers/cpuidle/cpuidle-qcom-spm.c
index c0e7971da2d..c4bd1de67e8 100644
--- a/drivers/cpuidle/cpuidle-qcom-spm.c
+++ b/drivers/cpuidle/cpuidle-qcom-spm.c
@@ -18,158 +18,18 @@
 #include <linux/cpuidle.h>
 #include <linux/cpu_pm.h>
 #include <linux/qcom_scm.h>
+#include <soc/qcom/spm.h>
 
 #include <asm/proc-fns.h>
 #include <asm/suspend.h>
 
 #include "dt_idle_states.h"
 
-#define MAX_PMIC_DATA		2
-#define MAX_SEQ_DATA		64
-#define SPM_CTL_INDEX		0x7f
-#define SPM_CTL_INDEX_SHIFT	4
-#define SPM_CTL_EN		BIT(0)
-
-enum pm_sleep_mode {
-	PM_SLEEP_MODE_STBY,
-	PM_SLEEP_MODE_RET,
-	PM_SLEEP_MODE_SPC,
-	PM_SLEEP_MODE_PC,
-	PM_SLEEP_MODE_NR,
-};
-
-enum spm_reg {
-	SPM_REG_CFG,
-	SPM_REG_SPM_CTL,
-	SPM_REG_DLY,
-	SPM_REG_PMIC_DLY,
-	SPM_REG_PMIC_DATA_0,
-	SPM_REG_PMIC_DATA_1,
-	SPM_REG_VCTL,
-	SPM_REG_SEQ_ENTRY,
-	SPM_REG_SPM_STS,
-	SPM_REG_PMIC_STS,
-	SPM_REG_NR,
-};
-
-struct spm_reg_data {
-	const u8 *reg_offset;
-	u32 spm_cfg;
-	u32 spm_dly;
-	u32 pmic_dly;
-	u32 pmic_data[MAX_PMIC_DATA];
-	u8 seq[MAX_SEQ_DATA];
-	u8 start_index[PM_SLEEP_MODE_NR];
-};
-
-struct spm_driver_data {
+struct cpuidle_qcom_spm_data {
 	struct cpuidle_driver cpuidle_driver;
-	void __iomem *reg_base;
-	const struct spm_reg_data *reg_data;
-};
-
-static const u8 spm_reg_offset_v2_1[SPM_REG_NR] = {
-	[SPM_REG_CFG]		= 0x08,
-	[SPM_REG_SPM_CTL]	= 0x30,
-	[SPM_REG_DLY]		= 0x34,
-	[SPM_REG_SEQ_ENTRY]	= 0x80,
-};
-
-/* SPM register data for 8974, 8084 */
-static const struct spm_reg_data spm_reg_8974_8084_cpu  = {
-	.reg_offset = spm_reg_offset_v2_1,
-	.spm_cfg = 0x1,
-	.spm_dly = 0x3C102800,
-	.seq = { 0x03, 0x0B, 0x0F, 0x00, 0x20, 0x80, 0x10, 0xE8, 0x5B, 0x03,
-		0x3B, 0xE8, 0x5B, 0x82, 0x10, 0x0B, 0x30, 0x06, 0x26, 0x30,
-		0x0F },
-	.start_index[PM_SLEEP_MODE_STBY] = 0,
-	.start_index[PM_SLEEP_MODE_SPC] = 3,
+	struct spm_driver_data *spm;
 };
 
-/* SPM register data for 8226 */
-static const struct spm_reg_data spm_reg_8226_cpu  = {
-	.reg_offset = spm_reg_offset_v2_1,
-	.spm_cfg = 0x0,
-	.spm_dly = 0x3C102800,
-	.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,
-		0x5B, 0x60, 0x03, 0x60, 0x3B, 0x76, 0x76, 0x0B, 0x94, 0x5B,
-		0x80, 0x10, 0x26, 0x30, 0x0F },
-	.start_index[PM_SLEEP_MODE_STBY] = 0,
-	.start_index[PM_SLEEP_MODE_SPC] = 5,
-};
-
-static const u8 spm_reg_offset_v1_1[SPM_REG_NR] = {
-	[SPM_REG_CFG]		= 0x08,
-	[SPM_REG_SPM_CTL]	= 0x20,
-	[SPM_REG_PMIC_DLY]	= 0x24,
-	[SPM_REG_PMIC_DATA_0]	= 0x28,
-	[SPM_REG_PMIC_DATA_1]	= 0x2C,
-	[SPM_REG_SEQ_ENTRY]	= 0x80,
-};
-
-/* SPM register data for 8064 */
-static const struct spm_reg_data spm_reg_8064_cpu = {
-	.reg_offset = spm_reg_offset_v1_1,
-	.spm_cfg = 0x1F,
-	.pmic_dly = 0x02020004,
-	.pmic_data[0] = 0x0084009C,
-	.pmic_data[1] = 0x00A4001C,
-	.seq = { 0x03, 0x0F, 0x00, 0x24, 0x54, 0x10, 0x09, 0x03, 0x01,
-		0x10, 0x54, 0x30, 0x0C, 0x24, 0x30, 0x0F },
-	.start_index[PM_SLEEP_MODE_STBY] = 0,
-	.start_index[PM_SLEEP_MODE_SPC] = 2,
-};
-
-static inline void spm_register_write(struct spm_driver_data *drv,
-					enum spm_reg reg, u32 val)
-{
-	if (drv->reg_data->reg_offset[reg])
-		writel_relaxed(val, drv->reg_base +
-				drv->reg_data->reg_offset[reg]);
-}
-
-/* Ensure a guaranteed write, before return */
-static inline void spm_register_write_sync(struct spm_driver_data *drv,
-					enum spm_reg reg, u32 val)
-{
-	u32 ret;
-
-	if (!drv->reg_data->reg_offset[reg])
-		return;
-
-	do {
-		writel_relaxed(val, drv->reg_base +
-				drv->reg_data->reg_offset[reg]);
-		ret = readl_relaxed(drv->reg_base +
-				drv->reg_data->reg_offset[reg]);
-		if (ret == val)
-			break;
-		cpu_relax();
-	} while (1);
-}
-
-static inline u32 spm_register_read(struct spm_driver_data *drv,
-					enum spm_reg reg)
-{
-	return readl_relaxed(drv->reg_base + drv->reg_data->reg_offset[reg]);
-}
-
-static void spm_set_low_power_mode(struct spm_driver_data *drv,
-					enum pm_sleep_mode mode)
-{
-	u32 start_index;
-	u32 ctl_val;
-
-	start_index = drv->reg_data->start_index[mode];
-
-	ctl_val = spm_register_read(drv, SPM_REG_SPM_CTL);
-	ctl_val &= ~(SPM_CTL_INDEX << SPM_CTL_INDEX_SHIFT);
-	ctl_val |= start_index << SPM_CTL_INDEX_SHIFT;
-	ctl_val |= SPM_CTL_EN;
-	spm_register_write_sync(drv, SPM_REG_SPM_CTL, ctl_val);
-}
-
 static int qcom_pm_collapse(unsigned long int unused)
 {
 	qcom_scm_cpu_power_down(QCOM_SCM_CPU_PWR_DOWN_L2_ON);
@@ -201,10 +61,10 @@ static int qcom_cpu_spc(struct spm_driver_data *drv)
 static int spm_enter_idle_state(struct cpuidle_device *dev,
 				struct cpuidle_driver *drv, int idx)
 {
-	struct spm_driver_data *data = container_of(drv, struct spm_driver_data,
-						    cpuidle_driver);
+	struct cpuidle_qcom_spm_data *data = container_of(drv, struct cpuidle_qcom_spm_data,
+							  cpuidle_driver);
 
-	return CPU_PM_CPU_IDLE_ENTER_PARAM(qcom_cpu_spc, idx, data);
+	return CPU_PM_CPU_IDLE_ENTER_PARAM(qcom_cpu_spc, idx, data->spm);
 }
 
 static struct cpuidle_driver qcom_spm_idle_driver = {
@@ -225,134 +85,98 @@ static const struct of_device_id qcom_idle_state_match[] = {
 	{ },
 };
 
-static int spm_cpuidle_init(struct cpuidle_driver *drv, int cpu)
+static int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)
 {
+	struct platform_device *pdev = NULL;
+	struct device_node *cpu_node, *saw_node;
+	struct cpuidle_qcom_spm_data *data = NULL;
+	void *entry;
 	int ret;
 
-	memcpy(drv, &qcom_spm_idle_driver, sizeof(*drv));
-	drv->cpumask = (struct cpumask *)cpumask_of(cpu);
+	cpu_node = of_cpu_device_node_get(cpu);
+	if (!cpu_node)
+		return -ENODEV;
 
-	/* Parse idle states from device tree */
-	ret = dt_init_idle_driver(drv, qcom_idle_state_match, 1);
-	if (ret <= 0)
-		return ret ? : -ENODEV;
+	saw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);
+	if (!saw_node)
+		return -ENODEV;
 
-	/* We have atleast one power down mode */
-	return qcom_scm_set_warm_boot_addr(cpu_resume_arm, drv->cpumask);
-}
+	pdev = of_find_device_by_node(saw_node);
+	of_node_put(saw_node);
+	of_node_put(cpu_node);
+	if (!pdev)
+		return -ENODEV;
 
-static struct spm_driver_data *spm_get_drv(struct platform_device *pdev,
-		int *spm_cpu)
-{
-	struct spm_driver_data *drv = NULL;
-	struct device_node *cpu_node, *saw_node;
-	int cpu;
-	bool found = 0;
+	data = devm_kzalloc(cpuidle_dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
-	for_each_possible_cpu(cpu) {
-		cpu_node = of_cpu_device_node_get(cpu);
-		if (!cpu_node)
-			continue;
-		saw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);
-		found = (saw_node == pdev->dev.of_node);
-		of_node_put(saw_node);
-		of_node_put(cpu_node);
-		if (found)
-			break;
-	}
+	data->spm = dev_get_drvdata(&pdev->dev);
+	if (!data->spm)
+		return -EINVAL;
 
-	if (found) {
-		drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
-		if (drv)
-			*spm_cpu = cpu;
-	}
+	data->cpuidle_driver = qcom_spm_idle_driver;
+	data->cpuidle_driver.cpumask = (struct cpumask *)cpumask_of(cpu);
 
-	return drv;
-}
+	ret = dt_init_idle_driver(&data->cpuidle_driver,
+				  qcom_idle_state_match, 1);
+	if (ret <= 0)
+		return ret ? : -ENODEV;
 
-static const struct of_device_id spm_match_table[] = {
-	{ .compatible = "qcom,msm8226-saw2-v2.1-cpu",
-	  .data = &spm_reg_8226_cpu },
-	{ .compatible = "qcom,msm8974-saw2-v2.1-cpu",
-	  .data = &spm_reg_8974_8084_cpu },
-	{ .compatible = "qcom,apq8084-saw2-v2.1-cpu",
-	  .data = &spm_reg_8974_8084_cpu },
-	{ .compatible = "qcom,apq8064-saw2-v1.1-cpu",
-	  .data = &spm_reg_8064_cpu },
-	{ },
-};
+#ifdef CONFIG_ARM64
+	entry = cpu_resume;
+#else
+	entry = cpu_resume_arm;
+#endif
+	ret = qcom_scm_set_warm_boot_addr(entry, cpumask_of(cpu));
+	if (ret)
+		return ret;
+
+	return cpuidle_register(&data->cpuidle_driver, NULL);
+}
 
-static int spm_dev_probe(struct platform_device *pdev)
+static int spm_cpuidle_drv_probe(struct platform_device *pdev)
 {
-	struct spm_driver_data *drv;
-	struct resource *res;
-	const struct of_device_id *match_id;
-	void __iomem *addr;
 	int cpu, ret;
 
 	if (!qcom_scm_is_available())
 		return -EPROBE_DEFER;
 
-	drv = spm_get_drv(pdev, &cpu);
-	if (!drv)
-		return -EINVAL;
-	platform_set_drvdata(pdev, drv);
+	for_each_possible_cpu(cpu) {
+		ret = spm_cpuidle_register(&pdev->dev, cpu);
+		if (ret && ret != -ENODEV) {
+			dev_err(&pdev->dev,
+				"Cannot register for CPU%d: %d\n", cpu, ret);
+		}
+	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	drv->reg_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(drv->reg_base))
-		return PTR_ERR(drv->reg_base);
+	return 0;
+}
 
-	match_id = of_match_node(spm_match_table, pdev->dev.of_node);
-	if (!match_id)
-		return -ENODEV;
+static struct platform_driver spm_cpuidle_driver = {
+	.probe = spm_cpuidle_drv_probe,
+	.driver = {
+		.name = "qcom-spm-cpuidle",
+		.suppress_bind_attrs = true,
+	},
+};
 
-	drv->reg_data = match_id->data;
+static int __init qcom_spm_cpuidle_init(void)
+{
+	struct platform_device *pdev;
+	int ret;
 
-	ret = spm_cpuidle_init(&drv->cpuidle_driver, cpu);
+	ret = platform_driver_register(&spm_cpuidle_driver);
 	if (ret)
 		return ret;
 
-	/* Write the SPM sequences first.. */
-	addr = drv->reg_base + drv->reg_data->reg_offset[SPM_REG_SEQ_ENTRY];
-	__iowrite32_copy(addr, drv->reg_data->seq,
-			ARRAY_SIZE(drv->reg_data->seq) / 4);
-
-	/*
-	 * ..and then the control registers.
-	 * On some SoC if the control registers are written first and if the
-	 * CPU was held in reset, the reset signal could trigger the SPM state
-	 * machine, before the sequences are completely written.
-	 */
-	spm_register_write(drv, SPM_REG_CFG, drv->reg_data->spm_cfg);
-	spm_register_write(drv, SPM_REG_DLY, drv->reg_data->spm_dly);
-	spm_register_write(drv, SPM_REG_PMIC_DLY, drv->reg_data->pmic_dly);
-	spm_register_write(drv, SPM_REG_PMIC_DATA_0,
-				drv->reg_data->pmic_data[0]);
-	spm_register_write(drv, SPM_REG_PMIC_DATA_1,
-				drv->reg_data->pmic_data[1]);
-
-	/* Set up Standby as the default low power mode */
-	spm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);
-
-	return cpuidle_register(&drv->cpuidle_driver, NULL);
-}
-
-static int spm_dev_remove(struct platform_device *pdev)
-{
-	struct spm_driver_data *drv = platform_get_drvdata(pdev);
+	pdev = platform_device_register_simple("qcom-spm-cpuidle",
+					       -1, NULL, 0);
+	if (IS_ERR(pdev)) {
+		platform_driver_unregister(&spm_cpuidle_driver);
+		return PTR_ERR(pdev);
+	}
 
-	cpuidle_unregister(&drv->cpuidle_driver);
 	return 0;
 }
-
-static struct platform_driver spm_driver = {
-	.probe = spm_dev_probe,
-	.remove = spm_dev_remove,
-	.driver = {
-		.name = "saw",
-		.of_match_table = spm_match_table,
-	},
-};
-
-builtin_platform_driver(spm_driver);
+device_initcall(qcom_spm_cpuidle_init);
diff --git a/drivers/dma/qcom/bam_dma.c b/drivers/dma/qcom/bam_dma.c
index ca8c862c974..2ff787df513 100644
--- a/drivers/dma/qcom/bam_dma.c
+++ b/drivers/dma/qcom/bam_dma.c
@@ -388,6 +388,8 @@ struct bam_device {
 	/* execution environment ID, from DT */
 	u32 ee;
 	bool controlled_remotely;
+	bool powered_remotely;
+	u32 active_channels;
 
 	const struct reg_offset_data *layout;
 
@@ -415,6 +417,44 @@ static inline void __iomem *bam_addr(struct bam_device *bdev, u32 pipe,
 		r.ee_mult * bdev->ee;
 }
 
+/**
+ * bam_reset() - reset and initialize BAM registers
+ * @bdev: bam device
+ */
+static void bam_reset(struct bam_device *bdev)
+{
+	u32 val;
+
+	/* s/w reset bam */
+	/* after reset all pipes are disabled and idle */
+	val = readl_relaxed(bam_addr(bdev, 0, BAM_CTRL));
+	val |= BAM_SW_RST;
+	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
+	val &= ~BAM_SW_RST;
+	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
+
+	/* make sure previous stores are visible before enabling BAM */
+	wmb();
+
+	/* enable bam */
+	val |= BAM_EN;
+	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
+
+	/* set descriptor threshhold, start with 4 bytes */
+	writel_relaxed(DEFAULT_CNT_THRSHLD,
+			bam_addr(bdev, 0, BAM_DESC_CNT_TRSHLD));
+
+	/* Enable default set of h/w workarounds, ie all except BAM_FULL_PIPE */
+	writel_relaxed(BAM_CNFG_BITS_DEFAULT, bam_addr(bdev, 0, BAM_CNFG_BITS));
+
+	/* enable irqs for errors */
+	writel_relaxed(BAM_ERROR_EN | BAM_HRESP_ERR_EN,
+			bam_addr(bdev, 0, BAM_IRQ_EN));
+
+	/* unmask global bam interrupt */
+	writel_relaxed(BAM_IRQ_MSK, bam_addr(bdev, 0, BAM_IRQ_SRCS_MSK_EE));
+}
+
 /**
  * bam_reset_channel - Reset individual BAM DMA channel
  * @bchan: bam channel
@@ -512,6 +552,9 @@ static int bam_alloc_chan(struct dma_chan *chan)
 		return -ENOMEM;
 	}
 
+	if (bdev->active_channels++ == 0 && bdev->powered_remotely)
+		bam_reset(bdev);
+
 	return 0;
 }
 
@@ -557,6 +600,13 @@ static void bam_free_chan(struct dma_chan *chan)
 	/* disable irq */
 	writel_relaxed(0, bam_addr(bdev, bchan->id, BAM_P_IRQ_EN));
 
+	if (--bdev->active_channels == 0 && bdev->powered_remotely) {
+		/* s/w reset bam */
+		val = readl_relaxed(bam_addr(bdev, 0, BAM_CTRL));
+		val |= BAM_SW_RST;
+		writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
+	}
+
 err:
 	pm_runtime_mark_last_busy(bdev->dev);
 	pm_runtime_put_autosuspend(bdev->dev);
@@ -1156,37 +1206,9 @@ static int bam_init(struct bam_device *bdev)
 		bdev->num_channels = val & BAM_NUM_PIPES_MASK;
 	}
 
-	if (bdev->controlled_remotely)
-		return 0;
-
-	/* s/w reset bam */
-	/* after reset all pipes are disabled and idle */
-	val = readl_relaxed(bam_addr(bdev, 0, BAM_CTRL));
-	val |= BAM_SW_RST;
-	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
-	val &= ~BAM_SW_RST;
-	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
-
-	/* make sure previous stores are visible before enabling BAM */
-	wmb();
-
-	/* enable bam */
-	val |= BAM_EN;
-	writel_relaxed(val, bam_addr(bdev, 0, BAM_CTRL));
-
-	/* set descriptor threshhold, start with 4 bytes */
-	writel_relaxed(DEFAULT_CNT_THRSHLD,
-			bam_addr(bdev, 0, BAM_DESC_CNT_TRSHLD));
-
-	/* Enable default set of h/w workarounds, ie all except BAM_FULL_PIPE */
-	writel_relaxed(BAM_CNFG_BITS_DEFAULT, bam_addr(bdev, 0, BAM_CNFG_BITS));
-
-	/* enable irqs for errors */
-	writel_relaxed(BAM_ERROR_EN | BAM_HRESP_ERR_EN,
-			bam_addr(bdev, 0, BAM_IRQ_EN));
-
-	/* unmask global bam interrupt */
-	writel_relaxed(BAM_IRQ_MSK, bam_addr(bdev, 0, BAM_IRQ_SRCS_MSK_EE));
+	/* Reset BAM now if fully controlled locally */
+	if (!bdev->controlled_remotely && !bdev->powered_remotely)
+		bam_reset(bdev);
 
 	return 0;
 }
@@ -1249,8 +1271,10 @@ static int bam_dma_probe(struct platform_device *pdev)
 
 	bdev->controlled_remotely = of_property_read_bool(pdev->dev.of_node,
 						"qcom,controlled-remotely");
+	bdev->powered_remotely = of_property_read_bool(pdev->dev.of_node,
+						"qcom,powered-remotely");
 
-	if (bdev->controlled_remotely) {
+	if (bdev->controlled_remotely || bdev->powered_remotely) {
 		ret = of_property_read_u32(pdev->dev.of_node, "num-channels",
 					   &bdev->num_channels);
 		if (ret)
@@ -1262,7 +1286,7 @@ static int bam_dma_probe(struct platform_device *pdev)
 			dev_err(bdev->dev, "num-ees unspecified in dt\n");
 	}
 
-	if (bdev->controlled_remotely)
+	if (bdev->controlled_remotely || bdev->powered_remotely)
 		bdev->bamclk = devm_clk_get_optional(bdev->dev, "bam_clk");
 	else
 		bdev->bamclk = devm_clk_get(bdev->dev, "bam_clk");
diff --git a/drivers/firmware/qcom_scm.c b/drivers/firmware/qcom_scm.c
index 2b5214d5c0d..dddef08ca04 100644
--- a/drivers/firmware/qcom_scm.c
+++ b/drivers/firmware/qcom_scm.c
@@ -17,6 +17,8 @@
 #include <linux/reset-controller.h>
 #include <linux/arm-smccc.h>
 
+#include <asm/smp_plat.h>
+
 #include "qcom_scm.h"
 
 static bool download_mode = IS_ENABLED(CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT);
@@ -260,15 +262,36 @@ static bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,
 	return ret ? false : !!res.result[0];
 }
 
-/**
- * qcom_scm_set_warm_boot_addr() - Set the warm boot address for cpus
- * @entry: Entry point function for the cpus
- * @cpus: The cpumask of cpus that will use the entry point
- *
- * Set the Linux entry point for the SCM to transfer control to when coming
- * out of a power down. CPU power down may be executed on cpuidle or hotplug.
- */
-int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
+static int __qcom_scm_set_boot_addr_mc(void *entry, const cpumask_t *cpus,
+				       unsigned int flags)
+{
+	struct qcom_scm_desc desc = {
+		.svc = QCOM_SCM_SVC_BOOT,
+		.cmd = QCOM_SCM_BOOT_SET_ADDR_MC,
+		.owner = ARM_SMCCC_OWNER_SIP,
+		.arginfo = QCOM_SCM_ARGS(6),
+	};
+	unsigned int cpu;
+	u64 map;
+
+	/* Need a device for DMA of the additional arguments */
+	if (!__scm || __get_convention() == SMC_CONVENTION_LEGACY)
+		return -EOPNOTSUPP;
+
+	desc.args[0] = virt_to_phys(entry);
+	for_each_cpu(cpu, cpus) {
+		map = cpu_logical_map(cpu);
+		desc.args[1] |= BIT(MPIDR_AFFINITY_LEVEL(map, 0));
+		desc.args[2] |= BIT(MPIDR_AFFINITY_LEVEL(map, 1));
+		desc.args[3] |= BIT(MPIDR_AFFINITY_LEVEL(map, 2));
+	}
+	desc.args[4] = ~0ULL; /* Reserved for affinity level 3 */
+	desc.args[5] = flags;
+
+	return qcom_scm_call(__scm->dev, &desc, NULL);
+}
+
+static int __qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
 {
 	int ret;
 	int flags = 0;
@@ -304,17 +327,28 @@ int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
 
 	return ret;
 }
-EXPORT_SYMBOL(qcom_scm_set_warm_boot_addr);
 
 /**
- * qcom_scm_set_cold_boot_addr() - Set the cold boot address for cpus
+ * qcom_scm_set_warm_boot_addr() - Set the warm boot address for cpus
  * @entry: Entry point function for the cpus
  * @cpus: The cpumask of cpus that will use the entry point
  *
- * Set the cold boot address of the cpus. Any cpu outside the supported
- * range would be removed from the cpu present mask.
+ * Set the Linux entry point for the SCM to transfer control to when coming
+ * out of a power down. CPU power down may be executed on cpuidle or hotplug.
  */
-int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
+int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
+{
+	if (!cpus || cpumask_empty(cpus))
+		return -EINVAL;
+
+	if (__qcom_scm_set_boot_addr_mc(entry, cpus, QCOM_SCM_BOOT_MC_FLAG_WARMBOOT))
+		/* Fallback to old SCM call */
+		return __qcom_scm_set_warm_boot_addr(entry, cpus);
+	return 0;
+}
+EXPORT_SYMBOL(qcom_scm_set_warm_boot_addr);
+
+static int __qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
 {
 	int flags = 0;
 	int cpu;
@@ -331,9 +365,6 @@ int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
 		.owner = ARM_SMCCC_OWNER_SIP,
 	};
 
-	if (!cpus || cpumask_empty(cpus))
-		return -EINVAL;
-
 	for_each_cpu(cpu, cpus) {
 		if (cpu < ARRAY_SIZE(scm_cb_flags))
 			flags |= scm_cb_flags[cpu];
@@ -346,6 +377,25 @@ int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
 
 	return qcom_scm_call_atomic(__scm ? __scm->dev : NULL, &desc, NULL);
 }
+
+/**
+ * qcom_scm_set_cold_boot_addr() - Set the cold boot address for cpus
+ * @entry: Entry point function for the cpus
+ * @cpus: The cpumask of cpus that will use the entry point
+ *
+ * Set the cold boot address of the cpus. Any cpu outside the supported
+ * range would be removed from the cpu present mask.
+ */
+int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
+{
+	if (!cpus || cpumask_empty(cpus))
+		return -EINVAL;
+
+	if (__qcom_scm_set_boot_addr_mc(entry, cpus, QCOM_SCM_BOOT_MC_FLAG_COLDBOOT))
+		/* Fallback to old SCM call */
+		return __qcom_scm_set_cold_boot_addr(entry, cpus);
+	return 0;
+}
 EXPORT_SYMBOL(qcom_scm_set_cold_boot_addr);
 
 /**
diff --git a/drivers/firmware/qcom_scm.h b/drivers/firmware/qcom_scm.h
index d92156ceb3a..2a6a87b7523 100644
--- a/drivers/firmware/qcom_scm.h
+++ b/drivers/firmware/qcom_scm.h
@@ -78,8 +78,12 @@ extern int scm_legacy_call(struct device *dev, const struct qcom_scm_desc *desc,
 #define QCOM_SCM_BOOT_SET_ADDR		0x01
 #define QCOM_SCM_BOOT_TERMINATE_PC	0x02
 #define QCOM_SCM_BOOT_SET_DLOAD_MODE	0x10
+#define QCOM_SCM_BOOT_SET_ADDR_MC	0x11
 #define QCOM_SCM_BOOT_SET_REMOTE_STATE	0x0a
 #define QCOM_SCM_FLUSH_FLAG_MASK	0x3
+#define QCOM_SCM_BOOT_MC_FLAG_AARCH64	BIT(0)
+#define QCOM_SCM_BOOT_MC_FLAG_COLDBOOT	BIT(1)
+#define QCOM_SCM_BOOT_MC_FLAG_WARMBOOT	BIT(2)
 
 #define QCOM_SCM_SVC_PIL		0x02
 #define QCOM_SCM_PIL_PAS_INIT_IMAGE	0x01
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 479ffdb6448..8f29159ee69 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -621,4 +621,9 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
+config DRM_PANEL_MSM8916_GENERATED
+	tristate "MSM8916 panel drivers generated with linux-mdss-dsi-panel-driver-generator"
+	depends on GPIOLIB && OF && REGULATOR
+	depends on DRM_MIPI_DSI
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index c8132050bce..99e0e96e12b 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -64,3 +64,4 @@ obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += msm8916-generated/
diff --git a/drivers/gpu/drm/panel/msm8916-generated/Makefile b/drivers/gpu/drm/panel/msm8916-generated/Makefile
new file mode 100644
index 00000000000..0f79ceb2c92
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/Makefile
@@ -0,0 +1,26 @@
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-alcatel-auo-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-asus-z00l-otm1284a.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-asus-z010d-r69339.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-huawei-tianma-nt35521.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-longcheer-booyi-otm1287.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-longcheer-dijing-ili9881c.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-longcheer-truly-otm1288a.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-longcheer-yushun-nt35520.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-motorola-harpia-boe.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-motorola-harpia-tianma.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-motorola-osprey-inx.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-motorola-surnia-boe.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-oppo-15009-nt35592-jdi.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-ea8061v-ams497ee01.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-nt51017-b4p096wx5vp09.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-s6d7aa0-lsl080al03.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-s6d7aa0-ltl101at01.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-s6e88a0-ams427ap24.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-samsung-tc358764-ltl101al06.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-auo-nt35521.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-auo-r61308.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-boe-nt35521s.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-ebbg-otm1285a.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-sharp-r69431.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-tianma-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_MSM8916_GENERATED) += panel-wingtech-yassy-ili9881.o
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c
new file mode 100644
index 00000000000..457dbae9d2b
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c
@@ -0,0 +1,321 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct hx8394d_auo {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct hx8394d_auo *to_hx8394d_auo(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d_auo, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void hx8394d_auo_reset(struct hx8394d_auo *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int hx8394d_auo_on(struct hx8394d_auo *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	dsi_dcs_write_seq(dsi, 0xba,
+			  0x73, 0x83, 0xa0, 0x65, 0xb2, 0x3f, 0x4f, 0x40, 0x50,
+			  0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb1,
+			  0x6c, 0x12, 0x12, 0x34, 0x04, 0x11, 0xf1, 0x80, 0x9f,
+			  0xa0, 0x23, 0x80, 0xc0, 0xd2, 0x58);
+	dsi_dcs_write_seq(dsi, 0xb2,
+			  0x00, 0x64, 0x05, 0x07, 0x22, 0x1c, 0x08, 0x08, 0x1c,
+			  0x4d, 0x00, 0x03, 0x20, 0x46, 0x48);
+	dsi_dcs_write_seq(dsi, 0xb4,
+			  0x00, 0xff, 0x03, 0x5a, 0x03, 0x5a, 0x03, 0x5a, 0x01,
+			  0x70, 0x01, 0x70);
+	dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+	dsi_dcs_write_seq(dsi, 0xe0,
+			  0x12, 0x2d, 0x36, 0x30, 0x33, 0x39, 0x39, 0x4a, 0x09,
+			  0x0c, 0x0e, 0x18, 0x0f, 0x12, 0x15, 0x13, 0x14, 0x06,
+			  0x10, 0x10, 0x18, 0x12, 0x2d, 0x36, 0x30, 0x33, 0x39,
+			  0x39, 0x4a, 0x09, 0x0c, 0x0e, 0x18, 0x0f, 0x12, 0x15,
+			  0x13, 0x14, 0x0a, 0x16, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xd3,
+			  0x00, 0x06, 0x00, 0x01, 0x01, 0x10, 0x00, 0x32, 0x10,
+			  0x00, 0x00, 0x00, 0x32, 0x15, 0x04, 0x35, 0x04, 0x32,
+			  0x15, 0x14, 0x05, 0x14, 0x37, 0x33, 0x00, 0x00, 0x37,
+			  0x00, 0x07, 0x37);
+	dsi_dcs_write_seq(dsi, 0xd5,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x25, 0x24, 0x27, 0x26,
+			  0x18, 0x18, 0x47, 0x46, 0x43, 0x42, 0x41, 0x40, 0x45,
+			  0x44, 0x05, 0x04, 0x01, 0x00, 0x07, 0x06, 0x03, 0x02,
+			  0x21, 0x20, 0x23, 0x22, 0x18, 0x18, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xd6,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x22, 0x23, 0x20, 0x21,
+			  0x18, 0x18, 0x00, 0x01, 0x04, 0x05, 0x06, 0x07, 0x02,
+			  0x03, 0x02, 0x03, 0x06, 0x07, 0x00, 0x01, 0x04, 0x05,
+			  0x26, 0x27, 0x24, 0x25, 0x18, 0x18, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd8,
+			  0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef,
+			  0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0,
+			  0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef,
+			  0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0);
+	dsi_dcs_write_seq(dsi, 0xbd, 0x02);
+	dsi_dcs_write_seq(dsi, 0xd8,
+			  0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef,
+			  0xff, 0xff, 0xf0);
+	dsi_dcs_write_seq(dsi, 0xcc, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb6, 0x62, 0x62);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x40, 0xc0);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x02);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int hx8394d_auo_off(struct hx8394d_auo *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int hx8394d_auo_prepare(struct drm_panel *panel)
+{
+	struct hx8394d_auo *ctx = to_hx8394d_auo(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_auo_reset(ctx);
+
+	ret = hx8394d_auo_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int hx8394d_auo_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d_auo *ctx = to_hx8394d_auo(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = hx8394d_auo_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_auo_mode = {
+	.clock = (720 + 52 + 24 + 100) * (1280 + 9 + 2 + 5) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 24,
+	.htotal = 720 + 52 + 24 + 100,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 9,
+	.vsync_end = 1280 + 9 + 2,
+	.vtotal = 1280 + 9 + 2 + 5,
+	.width_mm = 59,
+	.height_mm = 104,
+};
+
+static int hx8394d_auo_get_modes(struct drm_panel *panel,
+				 struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &hx8394d_auo_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394d_auo_panel_funcs = {
+	.prepare = hx8394d_auo_prepare,
+	.unprepare = hx8394d_auo_unprepare,
+	.get_modes = hx8394d_auo_get_modes,
+};
+
+static int hx8394d_auo_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d_auo *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_auo_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_auo_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d_auo *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id hx8394d_auo_of_match[] = {
+	{ .compatible = "alcatel,auo-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_auo_of_match);
+
+static struct mipi_dsi_driver hx8394d_auo_driver = {
+	.probe = hx8394d_auo_probe,
+	.remove = hx8394d_auo_remove,
+	.driver = {
+		.name = "panel-hx8394d-auo",
+		.of_match_table = hx8394d_auo_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_auo_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d auo 720p video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c
new file mode 100644
index 00000000000..ef63e13de97
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c
@@ -0,0 +1,323 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct otm1284a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+	bool prepared;
+};
+
+static inline struct otm1284a *to_otm1284a(struct drm_panel *panel)
+{
+	return container_of(panel, struct otm1284a, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void otm1284a_reset(struct otm1284a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int otm1284a_on(struct otm1284a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x84, 0x01);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x84);
+	dsi_generic_write_seq(dsi, 0x00, 0xb1);
+	dsi_generic_write_seq(dsi, 0xc6, 0x02);
+	dsi_generic_write_seq(dsi, 0x00, 0xb4);
+	dsi_generic_write_seq(dsi, 0xc6, 0x10);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(125);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	dsi_generic_write_seq(dsi, 0x53, 0x24);
+	dsi_generic_write_seq(dsi, 0x5e, 0x0d);
+
+	return 0;
+}
+
+static int otm1284a_off(struct otm1284a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0x53, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int otm1284a_prepare(struct drm_panel *panel)
+{
+	struct otm1284a *ctx = to_otm1284a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	otm1284a_reset(ctx);
+
+	ret = otm1284a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int otm1284a_unprepare(struct drm_panel *panel)
+{
+	struct otm1284a *ctx = to_otm1284a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = otm1284a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode otm1284a_mode = {
+	.clock = (720 + 92 + 12 + 64) * (1280 + 10 + 5 + 13) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 92,
+	.hsync_end = 720 + 92 + 12,
+	.htotal = 720 + 92 + 12 + 64,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 10,
+	.vsync_end = 1280 + 10 + 5,
+	.vtotal = 1280 + 10 + 5 + 13,
+	.width_mm = 68,
+	.height_mm = 121,
+};
+
+static int otm1284a_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &otm1284a_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs otm1284a_panel_funcs = {
+	.prepare = otm1284a_prepare,
+	.unprepare = otm1284a_unprepare,
+	.get_modes = otm1284a_get_modes,
+};
+
+static int otm1284a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct otm1284a *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops otm1284a_bl_ops = {
+	.update_status = otm1284a_bl_update_status,
+};
+
+static struct backlight_device *
+otm1284a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &otm1284a_bl_ops, &props);
+}
+
+static int otm1284a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct otm1284a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &otm1284a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = otm1284a_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int otm1284a_remove(struct mipi_dsi_device *dsi)
+{
+	struct otm1284a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id otm1284a_of_match[] = {
+	{ .compatible = "asus,z00l-otm1284a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, otm1284a_of_match);
+
+static struct mipi_dsi_driver otm1284a_driver = {
+	.probe = otm1284a_probe,
+	.remove = otm1284a_remove,
+	.driver = {
+		.name = "panel-otm1284a",
+		.of_match_table = otm1284a_of_match,
+	},
+};
+module_mipi_dsi_driver(otm1284a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for otm1284a 720p video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c
new file mode 100644
index 00000000000..1df88e32392
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct r69339 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct r69339 *to_r69339(struct drm_panel *panel)
+{
+	return container_of(panel, struct r69339, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void r69339_reset(struct r69339 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int r69339_on(struct r69339 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0001);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	return 0;
+}
+
+static int r69339_off(struct r69339 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r69339_prepare(struct drm_panel *panel)
+{
+	struct r69339 *ctx = to_r69339(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r69339_reset(ctx);
+
+	ret = r69339_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int r69339_unprepare(struct drm_panel *panel)
+{
+	struct r69339 *ctx = to_r69339(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = r69339_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode r69339_mode = {
+	.clock = (720 + 100 + 12 + 40) * (1280 + 13 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 100,
+	.hsync_end = 720 + 100 + 12,
+	.htotal = 720 + 100 + 12 + 40,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 13,
+	.vsync_end = 1280 + 13 + 1,
+	.vtotal = 1280 + 13 + 1 + 11,
+	.width_mm = 68,
+	.height_mm = 121,
+};
+
+static int r69339_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &r69339_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs r69339_panel_funcs = {
+	.prepare = r69339_prepare,
+	.unprepare = r69339_unprepare,
+	.get_modes = r69339_get_modes,
+};
+
+static int r69339_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int r69339_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops r69339_bl_ops = {
+	.update_status = r69339_bl_update_status,
+	.get_brightness = r69339_bl_get_brightness,
+};
+
+static struct backlight_device *
+r69339_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &r69339_bl_ops, &props);
+}
+
+static int r69339_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r69339 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r69339_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = r69339_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r69339_remove(struct mipi_dsi_device *dsi)
+{
+	struct r69339 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id r69339_of_match[] = {
+	{ .compatible = "asus,z010d-r69339" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r69339_of_match);
+
+static struct mipi_dsi_driver r69339_driver = {
+	.probe = r69339_probe,
+	.remove = r69339_remove,
+	.driver = {
+		.name = "panel-r69339",
+		.of_match_table = r69339_of_match,
+	},
+};
+module_mipi_dsi_driver(r69339_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for sharp 720p video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c
new file mode 100644
index 00000000000..088ae8d47d2
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c
@@ -0,0 +1,529 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct tianma_nt35521_5p5 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct tianma_nt35521_5p5 *to_tianma_nt35521_5p5(struct drm_panel *panel)
+{
+	return container_of(panel, struct tianma_nt35521_5p5, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void tianma_nt35521_5p5_reset(struct tianma_nt35521_5p5 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int tianma_nt35521_5p5_on(struct tianma_nt35521_5p5 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	dsi_generic_write_seq(dsi, 0x6f, 0x11, 0x00);
+	dsi_generic_write_seq(dsi, 0xf7, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0x6f, 0x11);
+	dsi_generic_write_seq(dsi, 0xf3, 0x01);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0xb1, 0x60);
+	dsi_generic_write_seq(dsi, 0xbd, 0x01, 0xa0, 0x0c, 0x08, 0x01);
+	dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	dsi_generic_write_seq(dsi, 0xb8, 0x01);
+	dsi_generic_write_seq(dsi, 0xbb, 0x11, 0x11);
+	dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xb6, 0x06);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_generic_write_seq(dsi, 0xb0, 0x09, 0x09);
+	dsi_generic_write_seq(dsi, 0xb1, 0x09, 0x09);
+	dsi_generic_write_seq(dsi, 0xb3, 0x28, 0x28);
+	dsi_generic_write_seq(dsi, 0xb4, 0x0f, 0x0f);
+	dsi_generic_write_seq(dsi, 0xb5, 0x03, 0x03);
+	dsi_generic_write_seq(dsi, 0xb9, 0x34, 0x34);
+	dsi_generic_write_seq(dsi, 0xba, 0x15, 0x15);
+	dsi_generic_write_seq(dsi, 0xbc, 0x58, 0x00);
+	dsi_generic_write_seq(dsi, 0xbd, 0x58, 0x00);
+	dsi_generic_write_seq(dsi, 0xc0, 0x04);
+	dsi_generic_write_seq(dsi, 0xca, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	dsi_generic_write_seq(dsi, 0xee, 0x03);
+	dsi_generic_write_seq(dsi, 0xb0,
+			      0x00, 0x05, 0x00, 0x2e, 0x00, 0x43, 0x00, 0x6c,
+			      0x00, 0x86, 0x00, 0xaf, 0x00, 0xd0, 0x01, 0x02);
+	dsi_generic_write_seq(dsi, 0xb1,
+			      0x01, 0x2c, 0x01, 0x67, 0x01, 0x96, 0x01, 0xe4,
+			      0x02, 0x22, 0x02, 0x24, 0x02, 0x60, 0x02, 0x9e);
+	dsi_generic_write_seq(dsi, 0xb2,
+			      0x02, 0xc5, 0x02, 0xf8, 0x03, 0x1d, 0x03, 0x4e,
+			      0x03, 0x68, 0x03, 0x7d, 0x03, 0xa2, 0x03, 0xc7);
+	dsi_generic_write_seq(dsi, 0xb3, 0x03, 0xd7, 0x03, 0xdb);
+	dsi_generic_write_seq(dsi, 0xb4,
+			      0x00, 0x99, 0x00, 0xa3, 0x00, 0xb8, 0x00, 0xc8,
+			      0x00, 0xd7, 0x00, 0xf1, 0x01, 0x07, 0x01, 0x2c);
+	dsi_generic_write_seq(dsi, 0xb5,
+			      0x01, 0x4b, 0x01, 0x7f, 0x01, 0xab, 0x01, 0xf2,
+			      0x02, 0x2b, 0x02, 0x2d, 0x02, 0x64, 0x02, 0xa2);
+	dsi_generic_write_seq(dsi, 0xb6,
+			      0x02, 0xc9, 0x02, 0xfa, 0x03, 0x1c, 0x03, 0x49,
+			      0x03, 0x65, 0x03, 0x78, 0x03, 0x9e, 0x03, 0xc4);
+	dsi_generic_write_seq(dsi, 0xb7, 0x03, 0xda, 0x03, 0xdb);
+	dsi_generic_write_seq(dsi, 0xb8,
+			      0x00, 0x02, 0x00, 0x03, 0x00, 0x11, 0x00, 0x41,
+			      0x00, 0x62, 0x00, 0x92, 0x00, 0xb5, 0x00, 0xec);
+	dsi_generic_write_seq(dsi, 0xb9,
+			      0x01, 0x17, 0x01, 0x58, 0x01, 0x8a, 0x01, 0xdd,
+			      0x02, 0x1e, 0x02, 0x1f, 0x02, 0x5b, 0x02, 0x9b);
+	dsi_generic_write_seq(dsi, 0xba,
+			      0x02, 0xc5, 0x02, 0xf9, 0x03, 0x22, 0x03, 0x5c,
+			      0x03, 0x8f, 0x03, 0xfd, 0x03, 0xfd, 0x03, 0xfd);
+	dsi_generic_write_seq(dsi, 0xbb, 0x03, 0xfe, 0x03, 0xfe);
+	dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	dsi_generic_write_seq(dsi, 0xf7, 0x47);
+	dsi_generic_write_seq(dsi, 0x6f, 0x0a);
+	dsi_generic_write_seq(dsi, 0xf7, 0x02);
+	dsi_generic_write_seq(dsi, 0x6f, 0x17);
+	dsi_generic_write_seq(dsi, 0xf4, 0x70);
+	dsi_generic_write_seq(dsi, 0x6f, 0x11);
+	dsi_generic_write_seq(dsi, 0xf3, 0x01);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xb0, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0xb1, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0xb2, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb3, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb4, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb5, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb6, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb7, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb8, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xb9, 0x05, 0x00, 0x00, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xba, 0x53, 0x01, 0x00, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xbb, 0x53, 0x01, 0x00, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xbc, 0x53, 0x01, 0x00, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xbd, 0x53, 0x01, 0x00, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xc4, 0x60);
+	dsi_generic_write_seq(dsi, 0xc5, 0x40);
+	dsi_generic_write_seq(dsi, 0xc6, 0x60);
+	dsi_generic_write_seq(dsi, 0xc7, 0x40);
+	dsi_generic_write_seq(dsi, 0x6f, 0x01);
+	dsi_generic_write_seq(dsi, 0xf9, 0x46);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xed, 0x30);
+	dsi_generic_write_seq(dsi, 0xe5, 0x00);
+	dsi_generic_write_seq(dsi, 0xb0, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb8, 0x00);
+	dsi_generic_write_seq(dsi, 0xbd, 0x03, 0x03, 0x01, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xb1, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb9, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xb2, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xba, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xb3, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xbb, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xb4, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb5, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb6, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb7, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xe5, 0x06);
+	dsi_generic_write_seq(dsi, 0xe6, 0x06);
+	dsi_generic_write_seq(dsi, 0xe7, 0x06);
+	dsi_generic_write_seq(dsi, 0xe8, 0x06);
+	dsi_generic_write_seq(dsi, 0xe9, 0x06);
+	dsi_generic_write_seq(dsi, 0xea, 0x06);
+	dsi_generic_write_seq(dsi, 0xeb, 0x06);
+	dsi_generic_write_seq(dsi, 0xec, 0x06);
+	dsi_generic_write_seq(dsi, 0xc0, 0x0b);
+	dsi_generic_write_seq(dsi, 0xc1, 0x09);
+	dsi_generic_write_seq(dsi, 0xc2, 0x0b);
+	dsi_generic_write_seq(dsi, 0xc3, 0x09);
+	dsi_generic_write_seq(dsi, 0xc4, 0x10);
+	dsi_generic_write_seq(dsi, 0xc5, 0x10);
+	dsi_generic_write_seq(dsi, 0xc6, 0x10);
+	dsi_generic_write_seq(dsi, 0xc7, 0x10);
+	dsi_generic_write_seq(dsi, 0xc8, 0x08, 0x20);
+	dsi_generic_write_seq(dsi, 0xc9, 0x04, 0x20);
+	dsi_generic_write_seq(dsi, 0xca, 0x07, 0x00);
+	dsi_generic_write_seq(dsi, 0xcb, 0x03, 0x00);
+	dsi_generic_write_seq(dsi, 0xd1, 0x00, 0x05, 0x00, 0x07, 0x10);
+	dsi_generic_write_seq(dsi, 0xd2, 0x00, 0x05, 0x04, 0x07, 0x10);
+	dsi_generic_write_seq(dsi, 0xd3, 0x00, 0x00, 0x0a, 0x07, 0x10);
+	dsi_generic_write_seq(dsi, 0xd4, 0x00, 0x00, 0x0a, 0x07, 0x10);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xd0,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd5,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd6,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd7,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06);
+	dsi_generic_write_seq(dsi, 0xb0, 0x12, 0x10);
+	dsi_generic_write_seq(dsi, 0xb1, 0x18, 0x16);
+	dsi_generic_write_seq(dsi, 0xb2, 0x00, 0x02);
+	dsi_generic_write_seq(dsi, 0xb3, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xb4, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xb5, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xb6, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xb7, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xb8, 0x31, 0x08);
+	dsi_generic_write_seq(dsi, 0xb9, 0x2e, 0x2d);
+	dsi_generic_write_seq(dsi, 0xba, 0x2d, 0x2e);
+	dsi_generic_write_seq(dsi, 0xbb, 0x09, 0x31);
+	dsi_generic_write_seq(dsi, 0xbc, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xbd, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xbe, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xbf, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xc0, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xc1, 0x03, 0x01);
+	dsi_generic_write_seq(dsi, 0xc2, 0x17, 0x19);
+	dsi_generic_write_seq(dsi, 0xc3, 0x11, 0x13);
+	dsi_generic_write_seq(dsi, 0xe5, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xc4, 0x17, 0x19);
+	dsi_generic_write_seq(dsi, 0xc5, 0x11, 0x13);
+	dsi_generic_write_seq(dsi, 0xc6, 0x03, 0x01);
+	dsi_generic_write_seq(dsi, 0xc7, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xc8, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xc9, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xca, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xcb, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xcc, 0x31, 0x09);
+	dsi_generic_write_seq(dsi, 0xcd, 0x2d, 0x2e);
+	dsi_generic_write_seq(dsi, 0xce, 0x2e, 0x2d);
+	dsi_generic_write_seq(dsi, 0xcf, 0x08, 0x31);
+	dsi_generic_write_seq(dsi, 0xd0, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xd1, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xd2, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xd3, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xd4, 0x31, 0x31);
+	dsi_generic_write_seq(dsi, 0xd5, 0x00, 0x02);
+	dsi_generic_write_seq(dsi, 0xd6, 0x12, 0x10);
+	dsi_generic_write_seq(dsi, 0xd7, 0x18, 0x16);
+	dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xe7, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0xe6, 0xff, 0xff, 0xfa, 0xfa);
+	dsi_generic_write_seq(dsi, 0xe8,
+			      0xf3, 0xe8, 0xe0, 0xd8, 0xce, 0xc4, 0xba, 0xb0,
+			      0xa6, 0x9c);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x41, 0x36, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0xa5, 0x05);
+	dsi_generic_write_seq(dsi, 0xd1,
+			      0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03,
+			      0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xd7,
+			      0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd8,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x02, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0xd9, 0x02, 0x09);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x81);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x28);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_off(struct tianma_nt35521_5p5 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_prepare(struct drm_panel *panel)
+{
+	struct tianma_nt35521_5p5 *ctx = to_tianma_nt35521_5p5(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tianma_nt35521_5p5_reset(ctx);
+
+	ret = tianma_nt35521_5p5_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int tianma_nt35521_5p5_unprepare(struct drm_panel *panel)
+{
+	struct tianma_nt35521_5p5 *ctx = to_tianma_nt35521_5p5(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = tianma_nt35521_5p5_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode tianma_nt35521_5p5_mode = {
+	.clock = (720 + 88 + 12 + 88) * (1280 + 20 + 3 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 88,
+	.hsync_end = 720 + 88 + 12,
+	.htotal = 720 + 88 + 12 + 88,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 3,
+	.vtotal = 1280 + 20 + 3 + 20,
+	.width_mm = 68,
+	.height_mm = 121,
+};
+
+static int tianma_nt35521_5p5_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &tianma_nt35521_5p5_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs tianma_nt35521_5p5_panel_funcs = {
+	.prepare = tianma_nt35521_5p5_prepare,
+	.unprepare = tianma_nt35521_5p5_unprepare,
+	.get_modes = tianma_nt35521_5p5_get_modes,
+};
+
+static int tianma_nt35521_5p5_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops tianma_nt35521_5p5_bl_ops = {
+	.update_status = tianma_nt35521_5p5_bl_update_status,
+};
+
+static struct backlight_device *
+tianma_nt35521_5p5_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 250,
+		.max_brightness = 250,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &tianma_nt35521_5p5_bl_ops, &props);
+}
+
+static int tianma_nt35521_5p5_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tianma_nt35521_5p5 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &tianma_nt35521_5p5_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = tianma_nt35521_5p5_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_remove(struct mipi_dsi_device *dsi)
+{
+	struct tianma_nt35521_5p5 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id tianma_nt35521_5p5_of_match[] = {
+	{ .compatible = "huawei,tianma-nt35521" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tianma_nt35521_5p5_of_match);
+
+static struct mipi_dsi_driver tianma_nt35521_5p5_driver = {
+	.probe = tianma_nt35521_5p5_probe,
+	.remove = tianma_nt35521_5p5_remove,
+	.driver = {
+		.name = "panel-tianma-nt35521-5p5",
+		.of_match_table = tianma_nt35521_5p5_of_match,
+	},
+};
+module_mipi_dsi_driver(tianma_nt35521_5p5_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for TIANMA_NT35521_5P5_720P_VIDEO");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c
new file mode 100644
index 00000000000..c1b44c1a363
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct booyi_otm1287 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct booyi_otm1287 *to_booyi_otm1287(struct drm_panel *panel)
+{
+	return container_of(panel, struct booyi_otm1287, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void booyi_otm1287_reset(struct booyi_otm1287 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int booyi_otm1287_on(struct booyi_otm1287 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0x12, 0x87, 0x01);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xff, 0x12, 0x87);
+	dsi_dcs_write_seq(dsi, 0x00, 0x92);
+	dsi_dcs_write_seq(dsi, 0xff, 0x30);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xc0,
+			  0x00, 0x64, 0x00, 0x0f, 0x11, 0x00, 0x64, 0x0f, 0x11);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x00, 0x5c, 0x00, 0x01, 0x00, 0x04);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa4);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb3);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x00, 0x55);
+	dsi_dcs_write_seq(dsi, 0x00, 0x81);
+	dsi_dcs_write_seq(dsi, 0xc1, 0x55);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xf5, 0x02, 0x11, 0x02, 0x15);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x50);
+	dsi_dcs_write_seq(dsi, 0x00, 0x94);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x66);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb2);
+	dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb6);
+	dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x94);
+	dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xd2);
+	dsi_dcs_write_seq(dsi, 0xf5, 0x06, 0x15);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb4);
+	dsi_dcs_write_seq(dsi, 0xc5, 0xcc);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xc4,
+			  0x05, 0x10, 0x06, 0x02, 0x05, 0x15, 0x10, 0x05, 0x10,
+			  0x07, 0x02, 0x05, 0x15, 0x10);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	dsi_dcs_write_seq(dsi, 0xc4, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x91);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x19, 0x52);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xd8, 0xbc, 0xbc);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb3);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x84);
+	dsi_dcs_write_seq(dsi, 0x00, 0xbb);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x8a);
+	dsi_dcs_write_seq(dsi, 0x00, 0x82);
+	dsi_dcs_write_seq(dsi, 0xc4, 0x0a);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xe1,
+			  0x05, 0x44, 0x54, 0x61, 0x72, 0x7f, 0x81, 0xa9, 0x98,
+			  0xb0, 0x55, 0x41, 0x56, 0x38, 0x3a, 0x2e, 0x23, 0x19,
+			  0x0c, 0x05);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xe2,
+			  0x05, 0x44, 0x54, 0x61, 0x72, 0x80, 0x80, 0xa9, 0x99,
+			  0xb0, 0x54, 0x41, 0x56, 0x38, 0x3a, 0x2f, 0x23, 0x1a,
+			  0x0d, 0x05);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xd9, 0x71);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
+			  0x05, 0x05, 0x05, 0x05, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xe0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x05, 0x05);
+	dsi_dcs_write_seq(dsi, 0x00, 0xf0);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+			  0xff, 0xff);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x2d, 0x0a, 0x0c,
+			  0x0e, 0x10, 0x02, 0x04, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x2e, 0x2d);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x10, 0x0e, 0x0c, 0x0a, 0x04, 0x02, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x2e, 0x0f, 0x0d,
+			  0x0b, 0x09, 0x03, 0x01, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x2d, 0x2e);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x8b, 0x03, 0x00, 0x8a, 0x03, 0x00, 0x89, 0x03, 0x00,
+			  0x88, 0x03, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x38, 0x07, 0x84, 0xfc, 0x8b, 0x04, 0x00, 0x38, 0x06,
+			  0x84, 0xfd, 0x8b, 0x04, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x38, 0x05, 0x84, 0xfe, 0x8b, 0x04, 0x00, 0x38, 0x04,
+			  0x84, 0xff, 0x8b, 0x04, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x38, 0x03, 0x85, 0x00, 0x8b, 0x04, 0x00, 0x38, 0x02,
+			  0x85, 0x01, 0x8b, 0x04, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x38, 0x01, 0x85, 0x02, 0x8b, 0x04, 0x00, 0x38, 0x00,
+			  0x85, 0x03, 0x8b, 0x04, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	dsi_dcs_write_seq(dsi, 0xcf,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	dsi_dcs_write_seq(dsi, 0xcf,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xcf,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	dsi_dcs_write_seq(dsi, 0xcf,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xcf,
+			  0x01, 0x01, 0x20, 0x20, 0x00, 0x00, 0x01, 0x01, 0x00,
+			  0x02, 0x02);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb5);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x33, 0xf1, 0xff, 0x33, 0xf1, 0xff);
+	dsi_dcs_write_seq(dsi, 0x00, 0xb1);
+	dsi_dcs_write_seq(dsi, 0xc6, 0x05);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0x35, 0x01);
+	dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int booyi_otm1287_off(struct booyi_otm1287 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int booyi_otm1287_prepare(struct drm_panel *panel)
+{
+	struct booyi_otm1287 *ctx = to_booyi_otm1287(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	booyi_otm1287_reset(ctx);
+
+	ret = booyi_otm1287_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int booyi_otm1287_unprepare(struct drm_panel *panel)
+{
+	struct booyi_otm1287 *ctx = to_booyi_otm1287(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = booyi_otm1287_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode booyi_otm1287_mode = {
+	.clock = (720 + 90 + 10 + 90) * (1280 + 20 + 4 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 90,
+	.hsync_end = 720 + 90 + 10,
+	.htotal = 720 + 90 + 10 + 90,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 16,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int booyi_otm1287_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &booyi_otm1287_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs booyi_otm1287_panel_funcs = {
+	.prepare = booyi_otm1287_prepare,
+	.unprepare = booyi_otm1287_unprepare,
+	.get_modes = booyi_otm1287_get_modes,
+};
+
+static int booyi_otm1287_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct booyi_otm1287 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &booyi_otm1287_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int booyi_otm1287_remove(struct mipi_dsi_device *dsi)
+{
+	struct booyi_otm1287 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id booyi_otm1287_of_match[] = {
+	{ .compatible = "longcheer,booyi-otm1287" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, booyi_otm1287_of_match);
+
+static struct mipi_dsi_driver booyi_otm1287_driver = {
+	.probe = booyi_otm1287_probe,
+	.remove = booyi_otm1287_remove,
+	.driver = {
+		.name = "panel-booyi-otm1287",
+		.of_match_table = booyi_otm1287_of_match,
+	},
+};
+module_mipi_dsi_driver(booyi_otm1287_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for booyi OTM1287 720p video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c
new file mode 100644
index 00000000000..d33d932a42c
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c
@@ -0,0 +1,451 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct dijing_ili9881c {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct dijing_ili9881c *to_dijing_ili9881c(struct drm_panel *panel)
+{
+	return container_of(panel, struct dijing_ili9881c, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void dijing_ili9881c_reset(struct dijing_ili9881c *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int dijing_ili9881c_on(struct dijing_ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x03);
+	dsi_generic_write_seq(dsi, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0x02, 0x00);
+	dsi_generic_write_seq(dsi, 0x03, 0x72);
+	dsi_generic_write_seq(dsi, 0x04, 0x00);
+	dsi_generic_write_seq(dsi, 0x05, 0x00);
+	dsi_generic_write_seq(dsi, 0x06, 0x09);
+	dsi_generic_write_seq(dsi, 0x07, 0x00);
+	dsi_generic_write_seq(dsi, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0x09, 0x01);
+	dsi_generic_write_seq(dsi, 0x0a, 0x00);
+	dsi_generic_write_seq(dsi, 0x0b, 0x00);
+	dsi_generic_write_seq(dsi, 0x0c, 0x01);
+	dsi_generic_write_seq(dsi, 0x0d, 0x00);
+	dsi_generic_write_seq(dsi, 0x0e, 0x00);
+	dsi_generic_write_seq(dsi, 0x0f, 0x14);
+	dsi_generic_write_seq(dsi, 0x10, 0x14);
+	dsi_generic_write_seq(dsi, 0x11, 0x00);
+	dsi_generic_write_seq(dsi, 0x12, 0x00);
+	dsi_generic_write_seq(dsi, 0x13, 0x00);
+	dsi_generic_write_seq(dsi, 0x14, 0x00);
+	dsi_generic_write_seq(dsi, 0x15, 0x00);
+	dsi_generic_write_seq(dsi, 0x16, 0x00);
+	dsi_generic_write_seq(dsi, 0x17, 0x00);
+	dsi_generic_write_seq(dsi, 0x18, 0x00);
+	dsi_generic_write_seq(dsi, 0x19, 0x00);
+	dsi_generic_write_seq(dsi, 0x1a, 0x00);
+	dsi_generic_write_seq(dsi, 0x1b, 0x00);
+	dsi_generic_write_seq(dsi, 0x1c, 0x00);
+	dsi_generic_write_seq(dsi, 0x1d, 0x00);
+	dsi_generic_write_seq(dsi, 0x1e, 0x40);
+	dsi_generic_write_seq(dsi, 0x1f, 0x80);
+	dsi_generic_write_seq(dsi, 0x20, 0x05);
+	dsi_generic_write_seq(dsi, 0x21, 0x02);
+	dsi_generic_write_seq(dsi, 0x22, 0x00);
+	dsi_generic_write_seq(dsi, 0x23, 0x00);
+	dsi_generic_write_seq(dsi, 0x24, 0x00);
+	dsi_generic_write_seq(dsi, 0x25, 0x00);
+	dsi_generic_write_seq(dsi, 0x26, 0x00);
+	dsi_generic_write_seq(dsi, 0x27, 0x00);
+	dsi_generic_write_seq(dsi, 0x28, 0x33);
+	dsi_generic_write_seq(dsi, 0x29, 0x02);
+	dsi_generic_write_seq(dsi, 0x2a, 0x00);
+	dsi_generic_write_seq(dsi, 0x2b, 0x00);
+	dsi_generic_write_seq(dsi, 0x2c, 0x00);
+	dsi_generic_write_seq(dsi, 0x2d, 0x00);
+	dsi_generic_write_seq(dsi, 0x2e, 0x00);
+	dsi_generic_write_seq(dsi, 0x2f, 0x00);
+	dsi_generic_write_seq(dsi, 0x30, 0x00);
+	dsi_generic_write_seq(dsi, 0x31, 0x00);
+	dsi_generic_write_seq(dsi, 0x32, 0x00);
+	dsi_generic_write_seq(dsi, 0x33, 0x00);
+	dsi_generic_write_seq(dsi, 0x34, 0x04);
+	dsi_generic_write_seq(dsi, 0x35, 0x00);
+	dsi_generic_write_seq(dsi, 0x36, 0x00);
+	dsi_generic_write_seq(dsi, 0x37, 0x00);
+	dsi_generic_write_seq(dsi, 0x38, 0x78);
+	dsi_generic_write_seq(dsi, 0x39, 0x00);
+	dsi_generic_write_seq(dsi, 0x3a, 0x40);
+	dsi_generic_write_seq(dsi, 0x3b, 0x40);
+	dsi_generic_write_seq(dsi, 0x3c, 0x00);
+	dsi_generic_write_seq(dsi, 0x3d, 0x00);
+	dsi_generic_write_seq(dsi, 0x3e, 0x00);
+	dsi_generic_write_seq(dsi, 0x3f, 0x00);
+	dsi_generic_write_seq(dsi, 0x40, 0x00);
+	dsi_generic_write_seq(dsi, 0x41, 0x00);
+	dsi_generic_write_seq(dsi, 0x42, 0x00);
+	dsi_generic_write_seq(dsi, 0x43, 0x00);
+	dsi_generic_write_seq(dsi, 0x44, 0x00);
+	dsi_generic_write_seq(dsi, 0x50, 0x01);
+	dsi_generic_write_seq(dsi, 0x51, 0x23);
+	dsi_generic_write_seq(dsi, 0x52, 0x45);
+	dsi_generic_write_seq(dsi, 0x53, 0x67);
+	dsi_generic_write_seq(dsi, 0x54, 0x89);
+	dsi_generic_write_seq(dsi, 0x55, 0xab);
+	dsi_generic_write_seq(dsi, 0x56, 0x01);
+	dsi_generic_write_seq(dsi, 0x57, 0x23);
+	dsi_generic_write_seq(dsi, 0x58, 0x45);
+	dsi_generic_write_seq(dsi, 0x59, 0x67);
+	dsi_generic_write_seq(dsi, 0x5a, 0x89);
+	dsi_generic_write_seq(dsi, 0x5b, 0xab);
+	dsi_generic_write_seq(dsi, 0x5c, 0xcd);
+	dsi_generic_write_seq(dsi, 0x5d, 0xef);
+	dsi_generic_write_seq(dsi, 0x5e, 0x11);
+	dsi_generic_write_seq(dsi, 0x5f, 0x01);
+	dsi_generic_write_seq(dsi, 0x60, 0x00);
+	dsi_generic_write_seq(dsi, 0x61, 0x15);
+	dsi_generic_write_seq(dsi, 0x62, 0x14);
+	dsi_generic_write_seq(dsi, 0x63, 0x0e);
+	dsi_generic_write_seq(dsi, 0x64, 0x0f);
+	dsi_generic_write_seq(dsi, 0x65, 0x0c);
+	dsi_generic_write_seq(dsi, 0x66, 0x0d);
+	dsi_generic_write_seq(dsi, 0x67, 0x06);
+	dsi_generic_write_seq(dsi, 0x68, 0x02);
+	dsi_generic_write_seq(dsi, 0x69, 0x07);
+	dsi_generic_write_seq(dsi, 0x6a, 0x02);
+	dsi_generic_write_seq(dsi, 0x6b, 0x02);
+	dsi_generic_write_seq(dsi, 0x6c, 0x02);
+	dsi_generic_write_seq(dsi, 0x6d, 0x02);
+	dsi_generic_write_seq(dsi, 0x6e, 0x02);
+	dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	dsi_generic_write_seq(dsi, 0x70, 0x02);
+	dsi_generic_write_seq(dsi, 0x71, 0x02);
+	dsi_generic_write_seq(dsi, 0x72, 0x02);
+	dsi_generic_write_seq(dsi, 0x73, 0x02);
+	dsi_generic_write_seq(dsi, 0x74, 0x02);
+	dsi_generic_write_seq(dsi, 0x75, 0x01);
+	dsi_generic_write_seq(dsi, 0x76, 0x00);
+	dsi_generic_write_seq(dsi, 0x77, 0x14);
+	dsi_generic_write_seq(dsi, 0x78, 0x15);
+	dsi_generic_write_seq(dsi, 0x79, 0x0e);
+	dsi_generic_write_seq(dsi, 0x7a, 0x0f);
+	dsi_generic_write_seq(dsi, 0x7b, 0x0c);
+	dsi_generic_write_seq(dsi, 0x7c, 0x0d);
+	dsi_generic_write_seq(dsi, 0x7d, 0x06);
+	dsi_generic_write_seq(dsi, 0x7e, 0x02);
+	dsi_generic_write_seq(dsi, 0x7f, 0x07);
+	dsi_generic_write_seq(dsi, 0x80, 0x02);
+	dsi_generic_write_seq(dsi, 0x81, 0x02);
+	dsi_generic_write_seq(dsi, 0x82, 0x02);
+	dsi_generic_write_seq(dsi, 0x83, 0x02);
+	dsi_generic_write_seq(dsi, 0x84, 0x02);
+	dsi_generic_write_seq(dsi, 0x85, 0x02);
+	dsi_generic_write_seq(dsi, 0x86, 0x02);
+	dsi_generic_write_seq(dsi, 0x87, 0x02);
+	dsi_generic_write_seq(dsi, 0x88, 0x02);
+	dsi_generic_write_seq(dsi, 0x89, 0x02);
+	dsi_generic_write_seq(dsi, 0x8a, 0x02);
+	dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x04);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0x6c, 0x15);
+	dsi_generic_write_seq(dsi, 0x6e, 0x2a);
+	dsi_generic_write_seq(dsi, 0x6f, 0x33);
+	dsi_generic_write_seq(dsi, 0x3a, 0x94);
+	dsi_generic_write_seq(dsi, 0x8d, 0x1a);
+	dsi_generic_write_seq(dsi, 0x87, 0xba);
+	dsi_generic_write_seq(dsi, 0x26, 0x76);
+	dsi_generic_write_seq(dsi, 0xb2, 0xd1);
+	dsi_generic_write_seq(dsi, 0xb5, 0x06);
+	dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	dsi_generic_write_seq(dsi, 0x22, 0x0a);
+	dsi_generic_write_seq(dsi, 0x31, 0x00);
+	dsi_generic_write_seq(dsi, 0x53, 0x81);
+	dsi_generic_write_seq(dsi, 0x55, 0x8f);
+	dsi_generic_write_seq(dsi, 0x50, 0xc0);
+	dsi_generic_write_seq(dsi, 0x51, 0xc0);
+	dsi_generic_write_seq(dsi, 0x60, 0x08);
+	dsi_generic_write_seq(dsi, 0xa0, 0x08);
+	dsi_generic_write_seq(dsi, 0xa1, 0x10);
+	dsi_generic_write_seq(dsi, 0xa2, 0x25);
+	dsi_generic_write_seq(dsi, 0xa3, 0x00);
+	dsi_generic_write_seq(dsi, 0xa4, 0x24);
+	dsi_generic_write_seq(dsi, 0xa5, 0x19);
+	dsi_generic_write_seq(dsi, 0xa6, 0x12);
+	dsi_generic_write_seq(dsi, 0xa7, 0x1b);
+	dsi_generic_write_seq(dsi, 0xa8, 0x77);
+	dsi_generic_write_seq(dsi, 0xa9, 0x19);
+	dsi_generic_write_seq(dsi, 0xaa, 0x25);
+	dsi_generic_write_seq(dsi, 0xab, 0x6e);
+	dsi_generic_write_seq(dsi, 0xac, 0x20);
+	dsi_generic_write_seq(dsi, 0xad, 0x17);
+	dsi_generic_write_seq(dsi, 0xae, 0x54);
+	dsi_generic_write_seq(dsi, 0xaf, 0x24);
+	dsi_generic_write_seq(dsi, 0xb0, 0x27);
+	dsi_generic_write_seq(dsi, 0xb1, 0x52);
+	dsi_generic_write_seq(dsi, 0xb2, 0x63);
+	dsi_generic_write_seq(dsi, 0xb3, 0x39);
+	dsi_generic_write_seq(dsi, 0xc0, 0x08);
+	dsi_generic_write_seq(dsi, 0xc1, 0x20);
+	dsi_generic_write_seq(dsi, 0xc2, 0x23);
+	dsi_generic_write_seq(dsi, 0xc3, 0x22);
+	dsi_generic_write_seq(dsi, 0xc4, 0x06);
+	dsi_generic_write_seq(dsi, 0xc5, 0x34);
+	dsi_generic_write_seq(dsi, 0xc6, 0x25);
+	dsi_generic_write_seq(dsi, 0xc7, 0x20);
+	dsi_generic_write_seq(dsi, 0xc8, 0x86);
+	dsi_generic_write_seq(dsi, 0xc9, 0x1f);
+	dsi_generic_write_seq(dsi, 0xca, 0x2b);
+	dsi_generic_write_seq(dsi, 0xcb, 0x74);
+	dsi_generic_write_seq(dsi, 0xcc, 0x16);
+	dsi_generic_write_seq(dsi, 0xcd, 0x1b);
+	dsi_generic_write_seq(dsi, 0xce, 0x46);
+	dsi_generic_write_seq(dsi, 0xcf, 0x21);
+	dsi_generic_write_seq(dsi, 0xd0, 0x29);
+	dsi_generic_write_seq(dsi, 0xd1, 0x54);
+	dsi_generic_write_seq(dsi, 0xd2, 0x65);
+	dsi_generic_write_seq(dsi, 0xd3, 0x39);
+	dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+	dsi_generic_write_seq(dsi, 0x35, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dijing_ili9881c_off(struct dijing_ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int dijing_ili9881c_prepare(struct drm_panel *panel)
+{
+	struct dijing_ili9881c *ctx = to_dijing_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	dijing_ili9881c_reset(ctx);
+
+	ret = dijing_ili9881c_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int dijing_ili9881c_unprepare(struct drm_panel *panel)
+{
+	struct dijing_ili9881c *ctx = to_dijing_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = dijing_ili9881c_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode dijing_ili9881c_mode = {
+	.clock = (720 + 150 + 10 + 150) * (1280 + 20 + 2 + 19) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 150,
+	.hsync_end = 720 + 150 + 10,
+	.htotal = 720 + 150 + 10 + 150,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 2,
+	.vtotal = 1280 + 20 + 2 + 19,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int dijing_ili9881c_get_modes(struct drm_panel *panel,
+				     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &dijing_ili9881c_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs dijing_ili9881c_panel_funcs = {
+	.prepare = dijing_ili9881c_prepare,
+	.unprepare = dijing_ili9881c_unprepare,
+	.get_modes = dijing_ili9881c_get_modes,
+};
+
+static int dijing_ili9881c_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct dijing_ili9881c *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &dijing_ili9881c_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dijing_ili9881c_remove(struct mipi_dsi_device *dsi)
+{
+	struct dijing_ili9881c *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id dijing_ili9881c_of_match[] = {
+	{ .compatible = "longcheer,dijing-ili9881c" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, dijing_ili9881c_of_match);
+
+static struct mipi_dsi_driver dijing_ili9881c_driver = {
+	.probe = dijing_ili9881c_probe,
+	.remove = dijing_ili9881c_remove,
+	.driver = {
+		.name = "panel-dijing-ili9881c",
+		.of_match_table = dijing_ili9881c_of_match,
+	},
+};
+module_mipi_dsi_driver(dijing_ili9881c_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for dijing ILI9881C 720p video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c
new file mode 100644
index 00000000000..b9b4fd0dbae
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c
@@ -0,0 +1,431 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct truly_otm1288a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct truly_otm1288a *to_truly_otm1288a(struct drm_panel *panel)
+{
+	return container_of(panel, struct truly_otm1288a, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void truly_otm1288a_reset(struct truly_otm1288a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int truly_otm1288a_on(struct truly_otm1288a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x88, 0x01);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x88);
+	/* keep the TE signal for ESD (unneeded for video mode I guess?)
+	 * dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	 * dsi_generic_write_seq(dsi, 0xf6, 0x02); */
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xc0,
+			      0x00, 0x64, 0x00, 0x10, 0x10, 0x00, 0x64, 0x10,
+			      0x10);
+	dsi_generic_write_seq(dsi, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xc0, 0x00, 0x00, 0x00, 0x14, 0x00, 0x1b);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x1c, 0x32); /* 0x00 -> 0x32 for video mode */
+	dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	dsi_generic_write_seq(dsi, 0xb0, 0x4d);
+	dsi_generic_write_seq(dsi, 0x00, 0xa3);
+	dsi_generic_write_seq(dsi, 0xc0, 0x25);
+	dsi_generic_write_seq(dsi, 0x00, 0xb3);
+	dsi_generic_write_seq(dsi, 0xc0, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xc4, 0x43);
+	dsi_generic_write_seq(dsi, 0x00, 0xa2);
+	dsi_generic_write_seq(dsi, 0xc1, 0x41);
+	dsi_generic_write_seq(dsi, 0x00, 0xb6);
+	dsi_generic_write_seq(dsi, 0xb0, 0x18);
+	dsi_generic_write_seq(dsi, 0x00, 0x92);
+	dsi_generic_write_seq(dsi, 0xff, 0x30, 0x02);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xc5, 0x53);
+	dsi_generic_write_seq(dsi, 0x00, 0x93);
+	dsi_generic_write_seq(dsi, 0xc5, 0x66);
+	dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	dsi_generic_write_seq(dsi, 0xc4,
+			      0x05, 0x10, 0x06, 0x02, 0x05, 0x15, 0x10, 0x05,
+			      0x10, 0x07, 0x02, 0x05, 0x15, 0x10);
+	dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	dsi_generic_write_seq(dsi, 0xc4, 0x00, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0x00, 0x91);
+	dsi_generic_write_seq(dsi, 0xc5, 0x3d, 0xa6);
+	dsi_generic_write_seq(dsi, 0x00, 0xc2);
+	dsi_generic_write_seq(dsi, 0xc5, 0xb1);
+	dsi_generic_write_seq(dsi, 0x00, 0xe1);
+	dsi_generic_write_seq(dsi, 0xf5, 0x55);
+	dsi_generic_write_seq(dsi, 0x00, 0xc2);
+	dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc4);
+	dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc6);
+	dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xf3);
+	dsi_generic_write_seq(dsi, 0xcf, 0x34);
+	dsi_generic_write_seq(dsi, 0x00, 0x83);
+	dsi_generic_write_seq(dsi, 0xc5, 0x30);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd0, 0x40);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd1, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+			      0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05,
+			      0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05);
+	dsi_generic_write_seq(dsi, 0x00, 0xe0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x05, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xf0);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+			      0xff, 0xff, 0xff);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x29, 0x2a, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14,
+			      0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x29,
+			      0x2a, 0x09, 0x0b, 0x0d, 0x0f, 0x11, 0x13);
+	dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x01, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x29, 0x2a, 0x13, 0x11, 0x0f, 0x0d, 0x0b, 0x09,
+			      0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x29,
+			      0x2a, 0x14, 0x12, 0x10, 0x0e, 0x0c, 0x0a);
+	dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	dsi_generic_write_seq(dsi, 0xcc,
+			      0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x06, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x87, 0x05, 0x10, 0x86, 0x05, 0x10, 0x00, 0x00,
+			      0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x54, 0xff, 0x10, 0x55, 0x00, 0x10, 0x55, 0x03,
+			      0x10, 0x55, 0x04, 0x10, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x58, 0x05, 0x04, 0xff, 0x00, 0x10, 0x00, 0x58,
+			      0x04, 0x05, 0x00, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x58, 0x03, 0x05, 0x01, 0x00, 0x10, 0x00, 0x58,
+			      0x02, 0x05, 0x02, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x58, 0x01, 0x05, 0x03, 0x00, 0x10, 0x00, 0x58,
+			      0x00, 0x05, 0x04, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x50, 0x00, 0x05, 0x05, 0x00, 0x10, 0x00, 0x50,
+			      0x01, 0x05, 0x06, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xcf,
+			      0x50, 0x02, 0x05, 0x07, 0x00, 0x10, 0x00, 0x50,
+			      0x03, 0x05, 0x08, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x90);
+	dsi_generic_write_seq(dsi, 0xcf,
+			      0x50, 0x04, 0x05, 0x09, 0x00, 0x10, 0x00, 0x50,
+			      0x05, 0x05, 0x0a, 0x00, 0x10, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	dsi_generic_write_seq(dsi, 0xcf,
+			      0x3d, 0x20, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00,
+			      0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0x92);
+	dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x00, 0xc8);
+	dsi_generic_write_seq(dsi, 0xf5, 0x0b, 0x15);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd8, 0xb6, 0xb6);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xe1,
+			      0x02, 0x27, 0x35, 0x45, 0x54, 0x62, 0x64, 0x8c,
+			      0x7b, 0x93, 0x72, 0x5d, 0x6e, 0x48, 0x45, 0x3a,
+			      0x2d, 0x27, 0x21, 0x1f);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xe2,
+			      0x02, 0x27, 0x35, 0x45, 0x54, 0x62, 0x64, 0x8c,
+			      0x7b, 0x93, 0x72, 0x5d, 0x6e, 0x48, 0x45, 0x3a,
+			      0x2d, 0x27, 0x21, 0x1f);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_otm1288a_off(struct truly_otm1288a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int truly_otm1288a_prepare(struct drm_panel *panel)
+{
+	struct truly_otm1288a *ctx = to_truly_otm1288a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	truly_otm1288a_reset(ctx);
+
+	ret = truly_otm1288a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int truly_otm1288a_unprepare(struct drm_panel *panel)
+{
+	struct truly_otm1288a *ctx = to_truly_otm1288a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = truly_otm1288a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode truly_otm1288a_mode = {
+	.clock = (720 + 40 + 12 + 30) * (1280 + 40 + 2 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 40,
+	.hsync_end = 720 + 40 + 12,
+	.htotal = 720 + 40 + 12 + 30,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 40,
+	.vsync_end = 1280 + 40 + 2,
+	.vtotal = 1280 + 40 + 2 + 11,
+	.width_mm = 62,
+	.height_mm = 111,
+};
+
+static int truly_otm1288a_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &truly_otm1288a_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs truly_otm1288a_panel_funcs = {
+	.prepare = truly_otm1288a_prepare,
+	.unprepare = truly_otm1288a_unprepare,
+	.get_modes = truly_otm1288a_get_modes,
+};
+
+static int truly_otm1288a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct truly_otm1288a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &truly_otm1288a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_otm1288a_remove(struct mipi_dsi_device *dsi)
+{
+	struct truly_otm1288a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id truly_otm1288a_of_match[] = {
+	{ .compatible = "longcheer,truly-otm1288a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, truly_otm1288a_of_match);
+
+static struct mipi_dsi_driver truly_otm1288a_driver = {
+	.probe = truly_otm1288a_probe,
+	.remove = truly_otm1288a_remove,
+	.driver = {
+		.name = "panel-truly-otm1288a",
+		.of_match_table = truly_otm1288a_of_match,
+	},
+};
+module_mipi_dsi_driver(truly_otm1288a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for truly OTM1288A command mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c
new file mode 100644
index 00000000000..c5fa6e8b932
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c
@@ -0,0 +1,470 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+/* From panel-novatek-nt35510.c */
+#define NT35520_DOPCTR_0_DSIM BIT(4) /* Enable video mode on DSI */
+
+struct yushun_nt35520 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct yushun_nt35520 *to_yushun_nt35520(struct drm_panel *panel)
+{
+	return container_of(panel, struct yushun_nt35520, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void yushun_nt35520_reset(struct yushun_nt35520 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int yushun_nt35520_on(struct yushun_nt35520 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	dsi_generic_write_seq(dsi, 0x6f, 0x13);
+	dsi_generic_write_seq(dsi, 0xf7, 0x00);
+	dsi_generic_write_seq(dsi, 0x6f, 0x01);
+	dsi_generic_write_seq(dsi, 0xf3, 0x00);
+	dsi_generic_write_seq(dsi, 0xb1, 0x68 | NT35520_DOPCTR_0_DSIM, 0x21);
+	dsi_generic_write_seq(dsi, 0xbd, 0x02, 0x67, 0x20, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	dsi_generic_write_seq(dsi, 0xb8, 0x08);
+	dsi_generic_write_seq(dsi, 0xbb, 0x11, 0x11);
+	dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xb6, 0x01);
+	dsi_generic_write_seq(dsi, 0xc8, 0x83);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_generic_write_seq(dsi, 0xb0, 0x0f, 0x0f);
+	dsi_generic_write_seq(dsi, 0xb1, 0x0f, 0x0f);
+	dsi_generic_write_seq(dsi, 0xce, 0x66);
+	dsi_generic_write_seq(dsi, 0xc0, 0x0c);
+	dsi_generic_write_seq(dsi, 0xb5, 0x05, 0x05);
+	dsi_generic_write_seq(dsi, 0xbe, 0x3e);
+	dsi_generic_write_seq(dsi, 0xb3, 0x28, 0x28);
+	dsi_generic_write_seq(dsi, 0xb4, 0x19, 0x19);
+	dsi_generic_write_seq(dsi, 0xb9, 0x34, 0x34);
+	dsi_generic_write_seq(dsi, 0xba, 0x24, 0x24);
+	dsi_generic_write_seq(dsi, 0xbc, 0x70, 0x00);
+	dsi_generic_write_seq(dsi, 0xbd, 0x70, 0x00);
+	dsi_generic_write_seq(dsi, 0xca, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	dsi_generic_write_seq(dsi, 0xee, 0x00);
+	dsi_generic_write_seq(dsi, 0xb0,
+			      0x00, 0xd2, 0x00, 0xde, 0x00, 0xf0, 0x01, 0x01,
+			      0x01, 0x11, 0x01, 0x29, 0x01, 0x41, 0x01, 0x68);
+	dsi_generic_write_seq(dsi, 0xb1,
+			      0x01, 0x87, 0x01, 0xb8, 0x01, 0xe2, 0x02, 0x23,
+			      0x02, 0x57, 0x02, 0x5a, 0x02, 0x8e, 0x02, 0xc6);
+	dsi_generic_write_seq(dsi, 0xb2,
+			      0x02, 0xef, 0x03, 0x20, 0x03, 0x3e, 0x03, 0x63,
+			      0x03, 0x7e, 0x03, 0x9c, 0x03, 0xaf, 0x03, 0xbf);
+	dsi_generic_write_seq(dsi, 0xb3, 0x03, 0xfc, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xb4,
+			      0x00, 0x07, 0x00, 0x50, 0x00, 0x84, 0x00, 0xa6,
+			      0x00, 0xc1, 0x00, 0xe7, 0x01, 0x08, 0x01, 0x3b);
+	dsi_generic_write_seq(dsi, 0xb5,
+			      0x01, 0x63, 0x01, 0xa0, 0x01, 0xcf, 0x02, 0x18,
+			      0x02, 0x50, 0x02, 0x52, 0x02, 0x88, 0x02, 0xc1);
+	dsi_generic_write_seq(dsi, 0xb6,
+			      0x02, 0xea, 0x03, 0x1b, 0x03, 0x3a, 0x03, 0x60,
+			      0x03, 0x79, 0x03, 0x98, 0x03, 0xa9, 0x03, 0xc6);
+	dsi_generic_write_seq(dsi, 0xb7, 0x03, 0xd6, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xb8,
+			      0x00, 0xb6, 0x00, 0xc1, 0x00, 0xd3, 0x00, 0xe5,
+			      0x00, 0xf5, 0x01, 0x0f, 0x01, 0x29, 0x01, 0x51);
+	dsi_generic_write_seq(dsi, 0xb9,
+			      0x01, 0x73, 0x01, 0xa9, 0x01, 0xd6, 0x02, 0x1c,
+			      0x02, 0x52, 0x02, 0x55, 0x02, 0x8a, 0x02, 0xc4);
+	dsi_generic_write_seq(dsi, 0xba,
+			      0x02, 0xef, 0x03, 0x24, 0x03, 0x4b, 0x03, 0x73,
+			      0x03, 0x87, 0x03, 0x9f, 0x03, 0xa3, 0x03, 0xbd);
+	dsi_generic_write_seq(dsi, 0xbb, 0x03, 0xf2, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xbc,
+			      0x00, 0xd2, 0x00, 0xde, 0x00, 0xf0, 0x01, 0x01,
+			      0x01, 0x11, 0x01, 0x29, 0x01, 0x41, 0x01, 0x68);
+	dsi_generic_write_seq(dsi, 0xbd,
+			      0x01, 0x87, 0x01, 0xb8, 0x01, 0xe2, 0x02, 0x23,
+			      0x02, 0x57, 0x02, 0x5a, 0x02, 0x8e, 0x02, 0xc6);
+	dsi_generic_write_seq(dsi, 0xbe,
+			      0x02, 0xef, 0x03, 0x20, 0x03, 0x3e, 0x03, 0x63,
+			      0x03, 0x7e, 0x03, 0x9c, 0x03, 0xaf, 0x03, 0xbf);
+	dsi_generic_write_seq(dsi, 0xbf, 0x03, 0xfc, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xc0,
+			      0x00, 0x07, 0x00, 0x50, 0x00, 0x84, 0x00, 0xa6,
+			      0x00, 0xc1, 0x00, 0xe7, 0x01, 0x08, 0x01, 0x3b);
+	dsi_generic_write_seq(dsi, 0xc1,
+			      0x01, 0x63, 0x01, 0xa0, 0x01, 0xcf, 0x02, 0x18,
+			      0x02, 0x50, 0x02, 0x52, 0x02, 0x88, 0x02, 0xc1);
+	dsi_generic_write_seq(dsi, 0xc2,
+			      0x02, 0xea, 0x03, 0x1b, 0x03, 0x3a, 0x03, 0x60,
+			      0x03, 0x79, 0x03, 0x98, 0x03, 0xa9, 0x03, 0xc6);
+	dsi_generic_write_seq(dsi, 0xc3, 0x03, 0xd6, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xc4,
+			      0x00, 0xb6, 0x00, 0xc1, 0x00, 0xd3, 0x00, 0xe5,
+			      0x00, 0xf5, 0x01, 0x0f, 0x01, 0x29, 0x01, 0x51);
+	dsi_generic_write_seq(dsi, 0xc5,
+			      0x01, 0x73, 0x01, 0xa9, 0x01, 0xd6, 0x02, 0x1c,
+			      0x02, 0x52, 0x02, 0x55, 0x02, 0x8a, 0x02, 0xc4);
+	dsi_generic_write_seq(dsi, 0xc6,
+			      0x02, 0xef, 0x03, 0x24, 0x03, 0x4b, 0x03, 0x73,
+			      0x03, 0x87, 0x03, 0x9f, 0x03, 0xa3, 0x03, 0xbd);
+	dsi_generic_write_seq(dsi, 0xc7, 0x03, 0xf2, 0x03, 0xff);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06);
+	dsi_generic_write_seq(dsi, 0xb0, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xb1, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xb2, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xb3, 0x2e, 0x09);
+	dsi_generic_write_seq(dsi, 0xb4, 0x0b, 0x23);
+	dsi_generic_write_seq(dsi, 0xb5, 0x1d, 0x1f);
+	dsi_generic_write_seq(dsi, 0xb6, 0x11, 0x17);
+	dsi_generic_write_seq(dsi, 0xb7, 0x13, 0x19);
+	dsi_generic_write_seq(dsi, 0xb8, 0x01, 0x03);
+	dsi_generic_write_seq(dsi, 0xb9, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xba, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xbb, 0x02, 0x00);
+	dsi_generic_write_seq(dsi, 0xbc, 0x18, 0x12);
+	dsi_generic_write_seq(dsi, 0xbd, 0x16, 0x10);
+	dsi_generic_write_seq(dsi, 0xbe, 0x1e, 0x1c);
+	dsi_generic_write_seq(dsi, 0xbf, 0x22, 0x0a);
+	dsi_generic_write_seq(dsi, 0xc0, 0x08, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc1, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc2, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc3, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xe5, 0x25, 0x24);
+	dsi_generic_write_seq(dsi, 0xc4, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc5, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc6, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xc7, 0x2e, 0x02);
+	dsi_generic_write_seq(dsi, 0xc8, 0x00, 0x24);
+	dsi_generic_write_seq(dsi, 0xc9, 0x1e, 0x1c);
+	dsi_generic_write_seq(dsi, 0xca, 0x18, 0x12);
+	dsi_generic_write_seq(dsi, 0xcb, 0x16, 0x10);
+	dsi_generic_write_seq(dsi, 0xcc, 0x0a, 0x08);
+	dsi_generic_write_seq(dsi, 0xcd, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xce, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xcf, 0x09, 0x0b);
+	dsi_generic_write_seq(dsi, 0xd0, 0x11, 0x17);
+	dsi_generic_write_seq(dsi, 0xd1, 0x13, 0x19);
+	dsi_generic_write_seq(dsi, 0xd2, 0x1d, 0x1f);
+	dsi_generic_write_seq(dsi, 0xd3, 0x25, 0x01);
+	dsi_generic_write_seq(dsi, 0xd4, 0x03, 0x2e);
+	dsi_generic_write_seq(dsi, 0xd5, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xd6, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xd7, 0x2e, 0x2e);
+	dsi_generic_write_seq(dsi, 0xe6, 0x22, 0x23);
+	dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xe7, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xed, 0x30);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xb0, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0xb1, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xb0, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb8, 0x00);
+	dsi_generic_write_seq(dsi, 0xbd, 0x0f, 0x03, 0x03, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xb1, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb9, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xb2, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xba, 0x00, 0x03);
+	dsi_generic_write_seq(dsi, 0xb3, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xbb, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xb4, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb5, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb6, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xb7, 0x17, 0x06);
+	dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x01);
+	dsi_generic_write_seq(dsi, 0xe5, 0x06);
+	dsi_generic_write_seq(dsi, 0xe6, 0x06);
+	dsi_generic_write_seq(dsi, 0xe7, 0x06);
+	dsi_generic_write_seq(dsi, 0xe8, 0x06);
+	dsi_generic_write_seq(dsi, 0xe9, 0x0a);
+	dsi_generic_write_seq(dsi, 0xea, 0x06);
+	dsi_generic_write_seq(dsi, 0xeb, 0x06);
+	dsi_generic_write_seq(dsi, 0xec, 0x06);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xc0, 0x07);
+	dsi_generic_write_seq(dsi, 0xc1, 0x05);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xb2, 0x04, 0x00, 0x52, 0x01, 0xce);
+	dsi_generic_write_seq(dsi, 0xb3, 0x04, 0x00, 0x52, 0x01, 0xce);
+	msleep(120);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xc4, 0x82);
+	dsi_generic_write_seq(dsi, 0xc5, 0x80);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xb6, 0x04, 0x00, 0x52, 0x01, 0xce);
+	dsi_generic_write_seq(dsi, 0xb7, 0x04, 0x00, 0x52, 0x01, 0xce);
+	msleep(120);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xc8, 0x03, 0x20);
+	dsi_generic_write_seq(dsi, 0xc9, 0x01, 0x21);
+	dsi_generic_write_seq(dsi, 0xca, 0x03, 0x20);
+	dsi_generic_write_seq(dsi, 0xcb, 0x07, 0x20);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xc4, 0x60);
+	dsi_generic_write_seq(dsi, 0xc5, 0x40);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xba, 0x44, 0x00, 0x4b, 0x01, 0xbe);
+	dsi_generic_write_seq(dsi, 0xbb, 0x44, 0x00, 0x4b, 0x01, 0xbe);
+	dsi_generic_write_seq(dsi, 0xbc, 0x53, 0x00, 0x03, 0x00, 0x4b);
+	dsi_generic_write_seq(dsi, 0xbd, 0x53, 0x00, 0x03, 0x00, 0x4b);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_generic_write_seq(dsi, 0xd1,
+			      0x03, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd2,
+			      0x03, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd3,
+			      0x03, 0x05, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xd4,
+			      0x03, 0x05, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00,
+			      0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	dsi_generic_write_seq(dsi, 0xc4, 0x40);
+	dsi_generic_write_seq(dsi, 0xc5, 0x40);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35520_off(struct yushun_nt35520 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int yushun_nt35520_prepare(struct drm_panel *panel)
+{
+	struct yushun_nt35520 *ctx = to_yushun_nt35520(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	yushun_nt35520_reset(ctx);
+
+	ret = yushun_nt35520_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int yushun_nt35520_unprepare(struct drm_panel *panel)
+{
+	struct yushun_nt35520 *ctx = to_yushun_nt35520(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = yushun_nt35520_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode yushun_nt35520_mode = {
+	.clock = (720 + 90 + 12 + 88) * (1280 + 20 + 4 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 90,
+	.hsync_end = 720 + 90 + 12,
+	.htotal = 720 + 90 + 12 + 88,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 16,
+	.width_mm = 62,
+	.height_mm = 111,
+};
+
+static int yushun_nt35520_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &yushun_nt35520_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs yushun_nt35520_panel_funcs = {
+	.prepare = yushun_nt35520_prepare,
+	.unprepare = yushun_nt35520_unprepare,
+	.get_modes = yushun_nt35520_get_modes,
+};
+
+static int yushun_nt35520_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct yushun_nt35520 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &yushun_nt35520_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35520_remove(struct mipi_dsi_device *dsi)
+{
+	struct yushun_nt35520 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id yushun_nt35520_of_match[] = {
+	{ .compatible = "longcheer,yushun-nt35520" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, yushun_nt35520_of_match);
+
+static struct mipi_dsi_driver yushun_nt35520_driver = {
+	.probe = yushun_nt35520_probe,
+	.remove = yushun_nt35520_remove,
+	.driver = {
+		.name = "panel-yushun-nt35520",
+		.of_match_table = yushun_nt35520_of_match,
+	},
+};
+module_mipi_dsi_driver(yushun_nt35520_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for yushun NT35520 720p command mode panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c
new file mode 100644
index 00000000000..22c7e6a8be6
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c
@@ -0,0 +1,327 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct boe_499_v1 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+	bool prepared;
+};
+
+static inline struct boe_499_v1 *to_boe_499_v1(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_499_v1, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void boe_499_v1_reset(struct boe_499_v1 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+}
+
+static int boe_499_v1_on(struct boe_499_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	dsi_dcs_write_seq(dsi, 0xc9,
+			  0x13, 0x00, 0x00, 0x14, 0xb1, 0x1e, 0x00, 0x91, 0x00);
+	usleep_range(5000, 6000);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	usleep_range(5000, 6000);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int boe_499_v1_off(struct boe_499_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int boe_499_v1_prepare(struct drm_panel *panel)
+{
+	struct boe_499_v1 *ctx = to_boe_499_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	boe_499_v1_reset(ctx);
+
+	ret = boe_499_v1_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int boe_499_v1_unprepare(struct drm_panel *panel)
+{
+	struct boe_499_v1 *ctx = to_boe_499_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = boe_499_v1_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode boe_499_v1_mode = {
+	.clock = (720 + 52 + 20 + 84) * (1280 + 20 + 8 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 20,
+	.htotal = 720 + 52 + 20 + 84,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 8,
+	.vtotal = 1280 + 20 + 8 + 20,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int boe_499_v1_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &boe_499_v1_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs boe_499_v1_panel_funcs = {
+	.prepare = boe_499_v1_prepare,
+	.unprepare = boe_499_v1_unprepare,
+	.get_modes = boe_499_v1_get_modes,
+};
+
+static int boe_499_v1_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct boe_499_v1 *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops boe_499_v1_bl_ops = {
+	.update_status = boe_499_v1_bl_update_status,
+};
+
+static struct backlight_device *
+boe_499_v1_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &boe_499_v1_bl_ops, &props);
+}
+
+static int boe_499_v1_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct boe_499_v1 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &boe_499_v1_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = boe_499_v1_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int boe_499_v1_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_499_v1 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id boe_499_v1_of_match[] = {
+	{ .compatible = "motorola,harpia-panel-boe" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_499_v1_of_match);
+
+static struct mipi_dsi_driver boe_499_v1_driver = {
+	.probe = boe_499_v1_probe,
+	.remove = boe_499_v1_remove,
+	.driver = {
+		.name = "panel-boe-499-v1",
+		.of_match_table = boe_499_v1_of_match,
+	},
+};
+module_mipi_dsi_driver(boe_499_v1_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_boe_720p_499");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c
new file mode 100644
index 00000000000..6d63cf3aecc
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c
@@ -0,0 +1,324 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct tianma_499_v2 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+	bool prepared;
+};
+
+static inline struct tianma_499_v2 *to_tianma_499_v2(struct drm_panel *panel)
+{
+	return container_of(panel, struct tianma_499_v2, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void tianma_499_v2_reset(struct tianma_499_v2 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int tianma_499_v2_on(struct tianma_499_v2 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	dsi_dcs_write_seq(dsi, 0x68, 0x06);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int tianma_499_v2_off(struct tianma_499_v2 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int tianma_499_v2_prepare(struct drm_panel *panel)
+{
+	struct tianma_499_v2 *ctx = to_tianma_499_v2(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tianma_499_v2_reset(ctx);
+
+	ret = tianma_499_v2_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int tianma_499_v2_unprepare(struct drm_panel *panel)
+{
+	struct tianma_499_v2 *ctx = to_tianma_499_v2(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = tianma_499_v2_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode tianma_499_v2_mode = {
+	.clock = (720 + 52 + 20 + 84) * (1280 + 20 + 8 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 20,
+	.htotal = 720 + 52 + 20 + 84,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 8,
+	.vtotal = 1280 + 20 + 8 + 20,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int tianma_499_v2_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &tianma_499_v2_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs tianma_499_v2_panel_funcs = {
+	.prepare = tianma_499_v2_prepare,
+	.unprepare = tianma_499_v2_unprepare,
+	.get_modes = tianma_499_v2_get_modes,
+};
+
+static int tianma_499_v2_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct tianma_499_v2 *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	// This panel needs the high and low bytes swapped for the brightness value
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, swab16(brightness));
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops tianma_499_v2_bl_ops = {
+	.update_status = tianma_499_v2_bl_update_status,
+};
+
+static struct backlight_device *
+tianma_499_v2_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 4095,
+		.max_brightness = 4095,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &tianma_499_v2_bl_ops, &props);
+}
+
+static int tianma_499_v2_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tianma_499_v2 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &tianma_499_v2_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = tianma_499_v2_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tianma_499_v2_remove(struct mipi_dsi_device *dsi)
+{
+	struct tianma_499_v2 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id tianma_499_v2_of_match[] = {
+	{ .compatible = "motorola,harpia-panel-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tianma_499_v2_of_match);
+
+static struct mipi_dsi_driver tianma_499_v2_driver = {
+	.probe = tianma_499_v2_probe,
+	.remove = tianma_499_v2_remove,
+	.driver = {
+		.name = "panel-tianma-499-v2",
+		.of_match_table = tianma_499_v2_of_match,
+	},
+};
+module_mipi_dsi_driver(tianma_499_v2_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_tianma_720p_499");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c
new file mode 100644
index 00000000000..cba1d371392
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c
@@ -0,0 +1,291 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct inx_500_v0 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[3];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct inx_500_v0 *to_inx_500_v0(struct drm_panel *panel)
+{
+	return container_of(panel, struct inx_500_v0, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void inx_500_v0_reset(struct inx_500_v0 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int inx_500_v0_on(struct inx_500_v0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0xe8,
+			      0xf3, 0xd9, 0xcc, 0xc0, 0xb8, 0xb0, 0xa0, 0xa0,
+			      0xa0, 0x9c);
+	dsi_generic_write_seq(dsi, 0xd9, 0x03, 0x06);
+	dsi_generic_write_seq(dsi, 0xea, 0x09);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00cf);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_off(struct inx_500_v0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(17000, 18000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_prepare(struct drm_panel *panel)
+{
+	struct inx_500_v0 *ctx = to_inx_500_v0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	inx_500_v0_reset(ctx);
+
+	ret = inx_500_v0_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int inx_500_v0_unprepare(struct drm_panel *panel)
+{
+	struct inx_500_v0 *ctx = to_inx_500_v0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = inx_500_v0_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode inx_500_v0_mode = {
+	.clock = (720 + 48 + 8 + 68) * (1280 + 52 + 6 + 50) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 48,
+	.hsync_end = 720 + 48 + 8,
+	.htotal = 720 + 48 + 8 + 68,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 52,
+	.vsync_end = 1280 + 52 + 6,
+	.vtotal = 1280 + 52 + 6 + 50,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int inx_500_v0_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &inx_500_v0_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs inx_500_v0_panel_funcs = {
+	.prepare = inx_500_v0_prepare,
+	.unprepare = inx_500_v0_unprepare,
+	.get_modes = inx_500_v0_get_modes,
+};
+
+static int inx_500_v0_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct inx_500_v0 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ctx->supplies[2].supply = "vddio";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &inx_500_v0_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_remove(struct mipi_dsi_device *dsi)
+{
+	struct inx_500_v0 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id inx_500_v0_of_match[] = {
+	{ .compatible = "motorola,osprey-panel-inx" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, inx_500_v0_of_match);
+
+static struct mipi_dsi_driver inx_500_v0_driver = {
+	.probe = inx_500_v0_probe,
+	.remove = inx_500_v0_remove,
+	.driver = {
+		.name = "panel-inx-500-v0",
+		.of_match_table = inx_500_v0_of_match,
+	},
+};
+module_mipi_dsi_driver(inx_500_v0_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_inx_720p_500_v0");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c
new file mode 100644
index 00000000000..56408e12d5c
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c
@@ -0,0 +1,271 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct boe_450_v3 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct boe_450_v3 *to_boe_450_v3(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_450_v3, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void boe_450_v3_reset(struct boe_450_v3 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(21);
+}
+
+static int boe_450_v3_on(struct boe_450_v3 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x02);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00ff);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(40);
+
+	return 0;
+}
+
+static int boe_450_v3_off(struct boe_450_v3 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int boe_450_v3_prepare(struct drm_panel *panel)
+{
+	struct boe_450_v3 *ctx = to_boe_450_v3(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	boe_450_v3_reset(ctx);
+
+	ret = boe_450_v3_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int boe_450_v3_unprepare(struct drm_panel *panel)
+{
+	struct boe_450_v3 *ctx = to_boe_450_v3(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = boe_450_v3_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode boe_450_v3_mode = {
+	.clock = (540 + 24 + 4 + 40) * (960 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 24,
+	.hsync_end = 540 + 24 + 4,
+	.htotal = 540 + 24 + 4 + 40,
+	.vdisplay = 960,
+	.vsync_start = 960 + 16,
+	.vsync_end = 960 + 16 + 2,
+	.vtotal = 960 + 16 + 2 + 16,
+	.width_mm = 55,
+	.height_mm = 99,
+};
+
+static int boe_450_v3_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &boe_450_v3_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs boe_450_v3_panel_funcs = {
+	.prepare = boe_450_v3_prepare,
+	.unprepare = boe_450_v3_unprepare,
+	.get_modes = boe_450_v3_get_modes,
+};
+
+static int boe_450_v3_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct boe_450_v3 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &boe_450_v3_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int boe_450_v3_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_450_v3 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id boe_450_v3_of_match[] = {
+	{ .compatible = "motorola,surnia-panel-boe" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_450_v3_of_match);
+
+static struct mipi_dsi_driver boe_450_v3_driver = {
+	.probe = boe_450_v3_probe,
+	.remove = boe_450_v3_remove,
+	.driver = {
+		.name = "panel-boe-450-v3",
+		.of_match_table = boe_450_v3_of_match,
+	},
+};
+module_mipi_dsi_driver(boe_450_v3_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_boe_qhd_450_v3");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-oppo-15009-nt35592-jdi.c b/drivers/gpu/drm/panel/msm8916-generated/panel-oppo-15009-nt35592-jdi.c
new file mode 100644
index 00000000000..429244bbc8a
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-oppo-15009-nt35592-jdi.c
@@ -0,0 +1,746 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct oppo15009jdi_nt35592 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct oppo15009jdi_nt35592 *to_oppo15009jdi_nt35592(struct drm_panel *panel)
+{
+	return container_of(panel, struct oppo15009jdi_nt35592, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void oppo15009jdi_nt35592_reset(struct oppo15009jdi_nt35592 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(15000, 16000);
+}
+
+static int oppo15009jdi_nt35592_on(struct oppo15009jdi_nt35592 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0xff, 0x01);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x00, 0x1a);
+	dsi_generic_write_seq(dsi, 0x02, 0x43);
+	dsi_generic_write_seq(dsi, 0x04, 0x43);
+	dsi_generic_write_seq(dsi, 0x08, 0x56);
+	dsi_generic_write_seq(dsi, 0x09, 0x00);
+	dsi_generic_write_seq(dsi, 0x0b, 0xb3);
+	dsi_generic_write_seq(dsi, 0x0c, 0xb3);
+	dsi_generic_write_seq(dsi, 0x0d, 0x2f);
+	dsi_generic_write_seq(dsi, 0x0e, 0x1b);
+	dsi_generic_write_seq(dsi, 0x0f, 0xa2);
+	dsi_generic_write_seq(dsi, 0x11, 0x7a);
+	dsi_generic_write_seq(dsi, 0x12, 0x03);
+	dsi_generic_write_seq(dsi, 0x37, 0x02);
+	dsi_generic_write_seq(dsi, 0x23, 0x00);
+	dsi_generic_write_seq(dsi, 0x24, 0x00);
+	dsi_generic_write_seq(dsi, 0x25, 0x00);
+	dsi_generic_write_seq(dsi, 0x26, 0x00);
+	dsi_generic_write_seq(dsi, 0x27, 0x00);
+	dsi_generic_write_seq(dsi, 0x28, 0x00);
+	dsi_generic_write_seq(dsi, 0x36, 0x00);
+	dsi_generic_write_seq(dsi, 0x6f, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x05);
+	dsi_generic_write_seq(dsi, 0x02, 0x82);
+	dsi_generic_write_seq(dsi, 0x03, 0x82);
+	dsi_generic_write_seq(dsi, 0x04, 0x82);
+	dsi_generic_write_seq(dsi, 0x01, 0x00);
+	dsi_generic_write_seq(dsi, 0x05, 0x30);
+	dsi_generic_write_seq(dsi, 0x06, 0x33);
+	dsi_generic_write_seq(dsi, 0x07, 0x70);
+	dsi_generic_write_seq(dsi, 0x08, 0x00);
+	dsi_generic_write_seq(dsi, 0x11, 0x00);
+	dsi_generic_write_seq(dsi, 0x09, 0x00);
+	dsi_generic_write_seq(dsi, 0x0a, 0x01);
+	dsi_generic_write_seq(dsi, 0x0b, 0x70);
+	dsi_generic_write_seq(dsi, 0x0d, 0x04);
+	dsi_generic_write_seq(dsi, 0x0e, 0x1b);
+	dsi_generic_write_seq(dsi, 0x0f, 0x02);
+	dsi_generic_write_seq(dsi, 0x10, 0x32);
+	dsi_generic_write_seq(dsi, 0x12, 0x00);
+	dsi_generic_write_seq(dsi, 0x14, 0x00);
+	dsi_generic_write_seq(dsi, 0x16, 0x04);
+	dsi_generic_write_seq(dsi, 0x19, 0xff);
+	dsi_generic_write_seq(dsi, 0x1a, 0xff);
+	dsi_generic_write_seq(dsi, 0x1b, 0xff);
+	dsi_generic_write_seq(dsi, 0x1c, 0x80);
+	dsi_generic_write_seq(dsi, 0x1d, 0x00);
+	dsi_generic_write_seq(dsi, 0x1e, 0x00);
+	dsi_generic_write_seq(dsi, 0x1f, 0x77);
+	dsi_generic_write_seq(dsi, 0x21, 0x20);
+	dsi_generic_write_seq(dsi, 0x22, 0x55);
+	dsi_generic_write_seq(dsi, 0x23, 0x0d);
+	dsi_generic_write_seq(dsi, 0x24, 0x03);
+	dsi_generic_write_seq(dsi, 0x25, 0x53);
+	dsi_generic_write_seq(dsi, 0x26, 0x55);
+	dsi_generic_write_seq(dsi, 0x27, 0x35);
+	dsi_generic_write_seq(dsi, 0x28, 0x00);
+	dsi_generic_write_seq(dsi, 0x29, 0x01);
+	dsi_generic_write_seq(dsi, 0x2a, 0x11);
+	dsi_generic_write_seq(dsi, 0x2d, 0x02);
+	dsi_generic_write_seq(dsi, 0x2f, 0x00);
+	dsi_generic_write_seq(dsi, 0x30, 0x11);
+	dsi_generic_write_seq(dsi, 0x31, 0x20);
+	dsi_generic_write_seq(dsi, 0x32, 0x09);
+	dsi_generic_write_seq(dsi, 0x35, 0x0d);
+	dsi_generic_write_seq(dsi, 0x36, 0x00);
+	dsi_generic_write_seq(dsi, 0x37, 0x09);
+	dsi_generic_write_seq(dsi, 0x48, 0x40);
+	dsi_generic_write_seq(dsi, 0x49, 0x23);
+	dsi_generic_write_seq(dsi, 0x4a, 0xc1);
+	dsi_generic_write_seq(dsi, 0x6f, 0x25);
+	dsi_generic_write_seq(dsi, 0x7b, 0x00);
+	dsi_generic_write_seq(dsi, 0x7c, 0x00);
+	dsi_generic_write_seq(dsi, 0x7d, 0x03);
+	dsi_generic_write_seq(dsi, 0x83, 0x00);
+	dsi_generic_write_seq(dsi, 0x8d, 0x00);
+	dsi_generic_write_seq(dsi, 0xa4, 0x8d);
+	dsi_generic_write_seq(dsi, 0xa6, 0x00);
+	dsi_generic_write_seq(dsi, 0xbb, 0x0a);
+	dsi_generic_write_seq(dsi, 0xbc, 0x06);
+	dsi_generic_write_seq(dsi, 0xd7, 0x61);
+	dsi_generic_write_seq(dsi, 0xd8, 0x13);
+	dsi_generic_write_seq(dsi, 0xf5, 0x00);
+	dsi_generic_write_seq(dsi, 0xf6, 0x01);
+	dsi_generic_write_seq(dsi, 0x89, 0xc1);
+	dsi_generic_write_seq(dsi, 0x91, 0x91);
+	dsi_generic_write_seq(dsi, 0xa2, 0x10);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0xff, 0x01);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x75, 0x00);
+	dsi_generic_write_seq(dsi, 0x76, 0x24);
+	dsi_generic_write_seq(dsi, 0x77, 0x00);
+	dsi_generic_write_seq(dsi, 0x78, 0x25);
+	dsi_generic_write_seq(dsi, 0x79, 0x00);
+	dsi_generic_write_seq(dsi, 0x7a, 0x43);
+	dsi_generic_write_seq(dsi, 0x7b, 0x00);
+	dsi_generic_write_seq(dsi, 0x7c, 0x5a);
+	dsi_generic_write_seq(dsi, 0x7d, 0x00);
+	dsi_generic_write_seq(dsi, 0x7e, 0x8f);
+	dsi_generic_write_seq(dsi, 0x7f, 0x00);
+	dsi_generic_write_seq(dsi, 0x80, 0xa6);
+	dsi_generic_write_seq(dsi, 0x81, 0x00);
+	dsi_generic_write_seq(dsi, 0x82, 0xb9);
+	dsi_generic_write_seq(dsi, 0x83, 0x00);
+	dsi_generic_write_seq(dsi, 0x84, 0xc9);
+	dsi_generic_write_seq(dsi, 0x85, 0x00);
+	dsi_generic_write_seq(dsi, 0x86, 0xd9);
+	dsi_generic_write_seq(dsi, 0x87, 0x01);
+	dsi_generic_write_seq(dsi, 0x88, 0x0c);
+	dsi_generic_write_seq(dsi, 0x89, 0x01);
+	dsi_generic_write_seq(dsi, 0x8a, 0x30);
+	dsi_generic_write_seq(dsi, 0x8b, 0x01);
+	dsi_generic_write_seq(dsi, 0x8c, 0x69);
+	dsi_generic_write_seq(dsi, 0x8d, 0x01);
+	dsi_generic_write_seq(dsi, 0x8e, 0x91);
+	dsi_generic_write_seq(dsi, 0x8f, 0x01);
+	dsi_generic_write_seq(dsi, 0x90, 0xd5);
+	dsi_generic_write_seq(dsi, 0x91, 0x02);
+	dsi_generic_write_seq(dsi, 0x92, 0x0d);
+	dsi_generic_write_seq(dsi, 0x93, 0x02);
+	dsi_generic_write_seq(dsi, 0x94, 0x10);
+	dsi_generic_write_seq(dsi, 0x95, 0x02);
+	dsi_generic_write_seq(dsi, 0x96, 0x3f);
+	dsi_generic_write_seq(dsi, 0x97, 0x02);
+	dsi_generic_write_seq(dsi, 0x98, 0x77);
+	dsi_generic_write_seq(dsi, 0x99, 0x02);
+	dsi_generic_write_seq(dsi, 0x9a, 0x9a);
+	dsi_generic_write_seq(dsi, 0x9b, 0x02);
+	dsi_generic_write_seq(dsi, 0x9c, 0xcf);
+	dsi_generic_write_seq(dsi, 0x9d, 0x02);
+	dsi_generic_write_seq(dsi, 0x9e, 0xf1);
+	dsi_generic_write_seq(dsi, 0x9f, 0x03);
+	dsi_generic_write_seq(dsi, 0xa0, 0x1f);
+	dsi_generic_write_seq(dsi, 0xa2, 0x03);
+	dsi_generic_write_seq(dsi, 0xa3, 0x2e);
+	dsi_generic_write_seq(dsi, 0xa4, 0x03);
+	dsi_generic_write_seq(dsi, 0xa5, 0x3e);
+	dsi_generic_write_seq(dsi, 0xa6, 0x03);
+	dsi_generic_write_seq(dsi, 0xa7, 0x4e);
+	dsi_generic_write_seq(dsi, 0xa9, 0x03);
+	dsi_generic_write_seq(dsi, 0xaa, 0x5d);
+	dsi_generic_write_seq(dsi, 0xab, 0x03);
+	dsi_generic_write_seq(dsi, 0xac, 0x8b);
+	dsi_generic_write_seq(dsi, 0xad, 0x03);
+	dsi_generic_write_seq(dsi, 0xae, 0x8e);
+	dsi_generic_write_seq(dsi, 0xaf, 0x03);
+	dsi_generic_write_seq(dsi, 0xb0, 0xb7);
+	dsi_generic_write_seq(dsi, 0xb1, 0x03);
+	dsi_generic_write_seq(dsi, 0xb2, 0xe3);
+	dsi_generic_write_seq(dsi, 0xb3, 0x00);
+	dsi_generic_write_seq(dsi, 0xb4, 0x24);
+	dsi_generic_write_seq(dsi, 0xb5, 0x00);
+	dsi_generic_write_seq(dsi, 0xb6, 0x25);
+	dsi_generic_write_seq(dsi, 0xb7, 0x00);
+	dsi_generic_write_seq(dsi, 0xb8, 0x43);
+	dsi_generic_write_seq(dsi, 0xb9, 0x00);
+	dsi_generic_write_seq(dsi, 0xba, 0x5a);
+	dsi_generic_write_seq(dsi, 0xbb, 0x00);
+	dsi_generic_write_seq(dsi, 0xbc, 0x8f);
+	dsi_generic_write_seq(dsi, 0xbd, 0x00);
+	dsi_generic_write_seq(dsi, 0xbe, 0xa6);
+	dsi_generic_write_seq(dsi, 0xbf, 0x00);
+	dsi_generic_write_seq(dsi, 0xc0, 0xb9);
+	dsi_generic_write_seq(dsi, 0xc1, 0x00);
+	dsi_generic_write_seq(dsi, 0xc2, 0xc9);
+	dsi_generic_write_seq(dsi, 0xc3, 0x00);
+	dsi_generic_write_seq(dsi, 0xc4, 0xd9);
+	dsi_generic_write_seq(dsi, 0xc5, 0x01);
+	dsi_generic_write_seq(dsi, 0xc6, 0x0c);
+	dsi_generic_write_seq(dsi, 0xc7, 0x01);
+	dsi_generic_write_seq(dsi, 0xc8, 0x30);
+	dsi_generic_write_seq(dsi, 0xc9, 0x01);
+	dsi_generic_write_seq(dsi, 0xca, 0x69);
+	dsi_generic_write_seq(dsi, 0xcb, 0x01);
+	dsi_generic_write_seq(dsi, 0xcc, 0x91);
+	dsi_generic_write_seq(dsi, 0xcd, 0x01);
+	dsi_generic_write_seq(dsi, 0xce, 0xd5);
+	dsi_generic_write_seq(dsi, 0xcf, 0x02);
+	dsi_generic_write_seq(dsi, 0xd0, 0x0d);
+	dsi_generic_write_seq(dsi, 0xd1, 0x02);
+	dsi_generic_write_seq(dsi, 0xd2, 0x10);
+	dsi_generic_write_seq(dsi, 0xd3, 0x02);
+	dsi_generic_write_seq(dsi, 0xd4, 0x3f);
+	dsi_generic_write_seq(dsi, 0xd5, 0x02);
+	dsi_generic_write_seq(dsi, 0xd6, 0x77);
+	dsi_generic_write_seq(dsi, 0xd7, 0x02);
+	dsi_generic_write_seq(dsi, 0xd8, 0x9a);
+	dsi_generic_write_seq(dsi, 0xd9, 0x02);
+	dsi_generic_write_seq(dsi, 0xda, 0xcf);
+	dsi_generic_write_seq(dsi, 0xdb, 0x02);
+	dsi_generic_write_seq(dsi, 0xdc, 0xf1);
+	dsi_generic_write_seq(dsi, 0xdd, 0x03);
+	dsi_generic_write_seq(dsi, 0xde, 0x1f);
+	dsi_generic_write_seq(dsi, 0xdf, 0x03);
+	dsi_generic_write_seq(dsi, 0xe0, 0x2e);
+	dsi_generic_write_seq(dsi, 0xe1, 0x03);
+	dsi_generic_write_seq(dsi, 0xe2, 0x3e);
+	dsi_generic_write_seq(dsi, 0xe3, 0x03);
+	dsi_generic_write_seq(dsi, 0xe4, 0x4e);
+	dsi_generic_write_seq(dsi, 0xe5, 0x03);
+	dsi_generic_write_seq(dsi, 0xe6, 0x5d);
+	dsi_generic_write_seq(dsi, 0xe7, 0x03);
+	dsi_generic_write_seq(dsi, 0xe8, 0x8b);
+	dsi_generic_write_seq(dsi, 0xe9, 0x03);
+	dsi_generic_write_seq(dsi, 0xea, 0x8e);
+	dsi_generic_write_seq(dsi, 0xeb, 0x03);
+	dsi_generic_write_seq(dsi, 0xec, 0xb7);
+	dsi_generic_write_seq(dsi, 0xed, 0x03);
+	dsi_generic_write_seq(dsi, 0xee, 0xe3);
+	dsi_generic_write_seq(dsi, 0xef, 0x00);
+	dsi_generic_write_seq(dsi, 0xf0, 0xf5);
+	dsi_generic_write_seq(dsi, 0xf1, 0x00);
+	dsi_generic_write_seq(dsi, 0xf2, 0xfb);
+	dsi_generic_write_seq(dsi, 0xf3, 0x01);
+	dsi_generic_write_seq(dsi, 0xf4, 0x08);
+	dsi_generic_write_seq(dsi, 0xf5, 0x01);
+	dsi_generic_write_seq(dsi, 0xf6, 0x13);
+	dsi_generic_write_seq(dsi, 0xf7, 0x01);
+	dsi_generic_write_seq(dsi, 0xf8, 0x1b);
+	dsi_generic_write_seq(dsi, 0xf9, 0x01);
+	dsi_generic_write_seq(dsi, 0xfa, 0x24);
+	dsi_generic_write_seq(dsi, 0xff, 0x02);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x00, 0x01);
+	dsi_generic_write_seq(dsi, 0x01, 0x2c);
+	dsi_generic_write_seq(dsi, 0x02, 0x01);
+	dsi_generic_write_seq(dsi, 0x03, 0x34);
+	dsi_generic_write_seq(dsi, 0x04, 0x01);
+	dsi_generic_write_seq(dsi, 0x05, 0x3b);
+	dsi_generic_write_seq(dsi, 0x06, 0x01);
+	dsi_generic_write_seq(dsi, 0x07, 0x55);
+	dsi_generic_write_seq(dsi, 0x08, 0x01);
+	dsi_generic_write_seq(dsi, 0x09, 0x6c);
+	dsi_generic_write_seq(dsi, 0x0a, 0x01);
+	dsi_generic_write_seq(dsi, 0x0b, 0x93);
+	dsi_generic_write_seq(dsi, 0x0c, 0x01);
+	dsi_generic_write_seq(dsi, 0x0d, 0xb5);
+	dsi_generic_write_seq(dsi, 0x0e, 0x01);
+	dsi_generic_write_seq(dsi, 0x0f, 0xec);
+	dsi_generic_write_seq(dsi, 0x10, 0x02);
+	dsi_generic_write_seq(dsi, 0x11, 0x1b);
+	dsi_generic_write_seq(dsi, 0x12, 0x02);
+	dsi_generic_write_seq(dsi, 0x13, 0x1c);
+	dsi_generic_write_seq(dsi, 0x14, 0x02);
+	dsi_generic_write_seq(dsi, 0x15, 0x4b);
+	dsi_generic_write_seq(dsi, 0x16, 0x02);
+	dsi_generic_write_seq(dsi, 0x17, 0x82);
+	dsi_generic_write_seq(dsi, 0x18, 0x02);
+	dsi_generic_write_seq(dsi, 0x19, 0xa7);
+	dsi_generic_write_seq(dsi, 0x1a, 0x02);
+	dsi_generic_write_seq(dsi, 0x1b, 0xd9);
+	dsi_generic_write_seq(dsi, 0x1c, 0x02);
+	dsi_generic_write_seq(dsi, 0x1d, 0xfc);
+	dsi_generic_write_seq(dsi, 0x1e, 0x03);
+	dsi_generic_write_seq(dsi, 0x1f, 0x2a);
+	dsi_generic_write_seq(dsi, 0x20, 0x03);
+	dsi_generic_write_seq(dsi, 0x21, 0x38);
+	dsi_generic_write_seq(dsi, 0x22, 0x03);
+	dsi_generic_write_seq(dsi, 0x23, 0x47);
+	dsi_generic_write_seq(dsi, 0x24, 0x03);
+	dsi_generic_write_seq(dsi, 0x25, 0x59);
+	dsi_generic_write_seq(dsi, 0x26, 0x03);
+	dsi_generic_write_seq(dsi, 0x27, 0x65);
+	dsi_generic_write_seq(dsi, 0x28, 0x03);
+	dsi_generic_write_seq(dsi, 0x29, 0x91);
+	dsi_generic_write_seq(dsi, 0x2a, 0x03);
+	dsi_generic_write_seq(dsi, 0x2b, 0xaf);
+	dsi_generic_write_seq(dsi, 0x2d, 0x03);
+	dsi_generic_write_seq(dsi, 0x2f, 0xef);
+	dsi_generic_write_seq(dsi, 0x30, 0x03);
+	dsi_generic_write_seq(dsi, 0x31, 0xf5);
+	dsi_generic_write_seq(dsi, 0x32, 0x00);
+	dsi_generic_write_seq(dsi, 0x33, 0xf5);
+	dsi_generic_write_seq(dsi, 0x34, 0x00);
+	dsi_generic_write_seq(dsi, 0x35, 0xfb);
+	dsi_generic_write_seq(dsi, 0x36, 0x01);
+	dsi_generic_write_seq(dsi, 0x37, 0x08);
+	dsi_generic_write_seq(dsi, 0x38, 0x01);
+	dsi_generic_write_seq(dsi, 0x39, 0x13);
+	dsi_generic_write_seq(dsi, 0x3a, 0x01);
+	dsi_generic_write_seq(dsi, 0x3b, 0x1b);
+	dsi_generic_write_seq(dsi, 0x3d, 0x01);
+	dsi_generic_write_seq(dsi, 0x3f, 0x24);
+	dsi_generic_write_seq(dsi, 0x40, 0x01);
+	dsi_generic_write_seq(dsi, 0x41, 0x2c);
+	dsi_generic_write_seq(dsi, 0x42, 0x01);
+	dsi_generic_write_seq(dsi, 0x43, 0x34);
+	dsi_generic_write_seq(dsi, 0x44, 0x01);
+	dsi_generic_write_seq(dsi, 0x45, 0x3b);
+	dsi_generic_write_seq(dsi, 0x46, 0x01);
+	dsi_generic_write_seq(dsi, 0x47, 0x55);
+	dsi_generic_write_seq(dsi, 0x48, 0x01);
+	dsi_generic_write_seq(dsi, 0x49, 0x6c);
+	dsi_generic_write_seq(dsi, 0x4a, 0x01);
+	dsi_generic_write_seq(dsi, 0x4b, 0x93);
+	dsi_generic_write_seq(dsi, 0x4c, 0x01);
+	dsi_generic_write_seq(dsi, 0x4d, 0xb5);
+	dsi_generic_write_seq(dsi, 0x4e, 0x01);
+	dsi_generic_write_seq(dsi, 0x4f, 0xec);
+	dsi_generic_write_seq(dsi, 0x50, 0x02);
+	dsi_generic_write_seq(dsi, 0x51, 0x1b);
+	dsi_generic_write_seq(dsi, 0x52, 0x02);
+	dsi_generic_write_seq(dsi, 0x53, 0x1c);
+	dsi_generic_write_seq(dsi, 0x54, 0x02);
+	dsi_generic_write_seq(dsi, 0x55, 0x4b);
+	dsi_generic_write_seq(dsi, 0x56, 0x02);
+	dsi_generic_write_seq(dsi, 0x58, 0x82);
+	dsi_generic_write_seq(dsi, 0x59, 0x02);
+	dsi_generic_write_seq(dsi, 0x5a, 0xa7);
+	dsi_generic_write_seq(dsi, 0x5b, 0x02);
+	dsi_generic_write_seq(dsi, 0x5c, 0xd9);
+	dsi_generic_write_seq(dsi, 0x5d, 0x02);
+	dsi_generic_write_seq(dsi, 0x5e, 0xfc);
+	dsi_generic_write_seq(dsi, 0x5f, 0x03);
+	dsi_generic_write_seq(dsi, 0x60, 0x2a);
+	dsi_generic_write_seq(dsi, 0x61, 0x03);
+	dsi_generic_write_seq(dsi, 0x62, 0x38);
+	dsi_generic_write_seq(dsi, 0x63, 0x03);
+	dsi_generic_write_seq(dsi, 0x64, 0x47);
+	dsi_generic_write_seq(dsi, 0x65, 0x03);
+	dsi_generic_write_seq(dsi, 0x66, 0x59);
+	dsi_generic_write_seq(dsi, 0x67, 0x03);
+	dsi_generic_write_seq(dsi, 0x68, 0x65);
+	dsi_generic_write_seq(dsi, 0x69, 0x03);
+	dsi_generic_write_seq(dsi, 0x6a, 0x91);
+	dsi_generic_write_seq(dsi, 0x6b, 0x03);
+	dsi_generic_write_seq(dsi, 0x6c, 0xaf);
+	dsi_generic_write_seq(dsi, 0x6d, 0x03);
+	dsi_generic_write_seq(dsi, 0x6e, 0xef);
+	dsi_generic_write_seq(dsi, 0x6f, 0x03);
+	dsi_generic_write_seq(dsi, 0x70, 0xf5);
+	dsi_generic_write_seq(dsi, 0x71, 0x00);
+	dsi_generic_write_seq(dsi, 0x72, 0x01);
+	dsi_generic_write_seq(dsi, 0x73, 0x00);
+	dsi_generic_write_seq(dsi, 0x74, 0x02);
+	dsi_generic_write_seq(dsi, 0x75, 0x00);
+	dsi_generic_write_seq(dsi, 0x76, 0x41);
+	dsi_generic_write_seq(dsi, 0x77, 0x00);
+	dsi_generic_write_seq(dsi, 0x78, 0x6c);
+	dsi_generic_write_seq(dsi, 0x79, 0x00);
+	dsi_generic_write_seq(dsi, 0x7a, 0x88);
+	dsi_generic_write_seq(dsi, 0x7b, 0x00);
+	dsi_generic_write_seq(dsi, 0x7c, 0x9e);
+	dsi_generic_write_seq(dsi, 0x7d, 0x00);
+	dsi_generic_write_seq(dsi, 0x7e, 0xb1);
+	dsi_generic_write_seq(dsi, 0x7f, 0x00);
+	dsi_generic_write_seq(dsi, 0x80, 0xc1);
+	dsi_generic_write_seq(dsi, 0x81, 0x00);
+	dsi_generic_write_seq(dsi, 0x82, 0xcf);
+	dsi_generic_write_seq(dsi, 0x83, 0x01);
+	dsi_generic_write_seq(dsi, 0x84, 0x02);
+	dsi_generic_write_seq(dsi, 0x85, 0x01);
+	dsi_generic_write_seq(dsi, 0x86, 0x26);
+	dsi_generic_write_seq(dsi, 0x87, 0x01);
+	dsi_generic_write_seq(dsi, 0x88, 0x60);
+	dsi_generic_write_seq(dsi, 0x89, 0x01);
+	dsi_generic_write_seq(dsi, 0x8a, 0x8c);
+	dsi_generic_write_seq(dsi, 0x8b, 0x01);
+	dsi_generic_write_seq(dsi, 0x8c, 0xd2);
+	dsi_generic_write_seq(dsi, 0x8d, 0x02);
+	dsi_generic_write_seq(dsi, 0x8e, 0x09);
+	dsi_generic_write_seq(dsi, 0x8f, 0x02);
+	dsi_generic_write_seq(dsi, 0x90, 0x0b);
+	dsi_generic_write_seq(dsi, 0x91, 0x02);
+	dsi_generic_write_seq(dsi, 0x92, 0x3d);
+	dsi_generic_write_seq(dsi, 0x93, 0x02);
+	dsi_generic_write_seq(dsi, 0x94, 0x76);
+	dsi_generic_write_seq(dsi, 0x95, 0x02);
+	dsi_generic_write_seq(dsi, 0x96, 0x9b);
+	dsi_generic_write_seq(dsi, 0x97, 0x02);
+	dsi_generic_write_seq(dsi, 0x98, 0xd0);
+	dsi_generic_write_seq(dsi, 0x99, 0x02);
+	dsi_generic_write_seq(dsi, 0x9a, 0xf6);
+	dsi_generic_write_seq(dsi, 0x9b, 0x03);
+	dsi_generic_write_seq(dsi, 0x9c, 0x2d);
+	dsi_generic_write_seq(dsi, 0x9d, 0x03);
+	dsi_generic_write_seq(dsi, 0x9e, 0x40);
+	dsi_generic_write_seq(dsi, 0x9f, 0x03);
+	dsi_generic_write_seq(dsi, 0xa0, 0x5a);
+	dsi_generic_write_seq(dsi, 0xa2, 0x03);
+	dsi_generic_write_seq(dsi, 0xa3, 0x7f);
+	dsi_generic_write_seq(dsi, 0xa4, 0x03);
+	dsi_generic_write_seq(dsi, 0xa5, 0xfa);
+	dsi_generic_write_seq(dsi, 0xa6, 0x03);
+	dsi_generic_write_seq(dsi, 0xa7, 0xfb);
+	dsi_generic_write_seq(dsi, 0xa9, 0x03);
+	dsi_generic_write_seq(dsi, 0xaa, 0xfe);
+	dsi_generic_write_seq(dsi, 0xab, 0x03);
+	dsi_generic_write_seq(dsi, 0xac, 0xfe);
+	dsi_generic_write_seq(dsi, 0xad, 0x03);
+	dsi_generic_write_seq(dsi, 0xae, 0xfe);
+	dsi_generic_write_seq(dsi, 0xaf, 0x00);
+	dsi_generic_write_seq(dsi, 0xb0, 0x01);
+	dsi_generic_write_seq(dsi, 0xb1, 0x00);
+	dsi_generic_write_seq(dsi, 0xb2, 0x02);
+	dsi_generic_write_seq(dsi, 0xb3, 0x00);
+	dsi_generic_write_seq(dsi, 0xb4, 0x41);
+	dsi_generic_write_seq(dsi, 0xb5, 0x00);
+	dsi_generic_write_seq(dsi, 0xb6, 0x6c);
+	dsi_generic_write_seq(dsi, 0xb7, 0x00);
+	dsi_generic_write_seq(dsi, 0xb8, 0x88);
+	dsi_generic_write_seq(dsi, 0xb9, 0x00);
+	dsi_generic_write_seq(dsi, 0xba, 0x9e);
+	dsi_generic_write_seq(dsi, 0xbb, 0x00);
+	dsi_generic_write_seq(dsi, 0xbc, 0xb1);
+	dsi_generic_write_seq(dsi, 0xbd, 0x00);
+	dsi_generic_write_seq(dsi, 0xbe, 0xc1);
+	dsi_generic_write_seq(dsi, 0xbf, 0x00);
+	dsi_generic_write_seq(dsi, 0xc0, 0xcf);
+	dsi_generic_write_seq(dsi, 0xc1, 0x01);
+	dsi_generic_write_seq(dsi, 0xc2, 0x02);
+	dsi_generic_write_seq(dsi, 0xc3, 0x01);
+	dsi_generic_write_seq(dsi, 0xc4, 0x26);
+	dsi_generic_write_seq(dsi, 0xc5, 0x01);
+	dsi_generic_write_seq(dsi, 0xc6, 0x60);
+	dsi_generic_write_seq(dsi, 0xc7, 0x01);
+	dsi_generic_write_seq(dsi, 0xc8, 0x8c);
+	dsi_generic_write_seq(dsi, 0xc9, 0x01);
+	dsi_generic_write_seq(dsi, 0xca, 0xd2);
+	dsi_generic_write_seq(dsi, 0xcb, 0x02);
+	dsi_generic_write_seq(dsi, 0xcc, 0x09);
+	dsi_generic_write_seq(dsi, 0xcd, 0x02);
+	dsi_generic_write_seq(dsi, 0xce, 0x0b);
+	dsi_generic_write_seq(dsi, 0xcf, 0x02);
+	dsi_generic_write_seq(dsi, 0xd0, 0x3d);
+	dsi_generic_write_seq(dsi, 0xd1, 0x02);
+	dsi_generic_write_seq(dsi, 0xd2, 0x76);
+	dsi_generic_write_seq(dsi, 0xd3, 0x02);
+	dsi_generic_write_seq(dsi, 0xd4, 0x9b);
+	dsi_generic_write_seq(dsi, 0xd5, 0x02);
+	dsi_generic_write_seq(dsi, 0xd6, 0xd0);
+	dsi_generic_write_seq(dsi, 0xd7, 0x02);
+	dsi_generic_write_seq(dsi, 0xd8, 0xf6);
+	dsi_generic_write_seq(dsi, 0xd9, 0x03);
+	dsi_generic_write_seq(dsi, 0xda, 0x2d);
+	dsi_generic_write_seq(dsi, 0xdb, 0x03);
+	dsi_generic_write_seq(dsi, 0xdc, 0x40);
+	dsi_generic_write_seq(dsi, 0xdd, 0x03);
+	dsi_generic_write_seq(dsi, 0xde, 0x5a);
+	dsi_generic_write_seq(dsi, 0xdf, 0x03);
+	dsi_generic_write_seq(dsi, 0xe0, 0x7f);
+	dsi_generic_write_seq(dsi, 0xe1, 0x03);
+	dsi_generic_write_seq(dsi, 0xe2, 0xfa);
+	dsi_generic_write_seq(dsi, 0xe3, 0x03);
+	dsi_generic_write_seq(dsi, 0xe4, 0xfb);
+	dsi_generic_write_seq(dsi, 0xe5, 0x03);
+	dsi_generic_write_seq(dsi, 0xe6, 0xfe);
+	dsi_generic_write_seq(dsi, 0xe7, 0x03);
+	dsi_generic_write_seq(dsi, 0xe8, 0xfe);
+	dsi_generic_write_seq(dsi, 0xe9, 0x03);
+	dsi_generic_write_seq(dsi, 0xea, 0xfe);
+	dsi_generic_write_seq(dsi, 0xff, 0x03);
+	dsi_generic_write_seq(dsi, 0x56, 0x00);
+	dsi_generic_write_seq(dsi, 0x68, 0x00);
+	dsi_generic_write_seq(dsi, 0x1a, 0x07);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0xff, 0x00);
+	dsi_generic_write_seq(dsi, 0x55, 0x93);
+	dsi_generic_write_seq(dsi, 0x35, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x01);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x36, 0x7b);
+	dsi_generic_write_seq(dsi, 0x6d, 0x33);
+	dsi_generic_write_seq(dsi, 0x6f, 0x03);
+	dsi_generic_write_seq(dsi, 0xff, 0x01);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x4b, 0x83);
+	dsi_generic_write_seq(dsi, 0xff, 0xff);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x3f, 0x09);
+	dsi_generic_write_seq(dsi, 0xca, 0x80);
+	dsi_generic_write_seq(dsi, 0xff, 0xee);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x2a, 0xa9);
+	dsi_generic_write_seq(dsi, 0xff, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x04);
+	dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	dsi_generic_write_seq(dsi, 0x21, 0xd9);
+	dsi_generic_write_seq(dsi, 0x22, 0xd9);
+	dsi_generic_write_seq(dsi, 0x23, 0xd9);
+	dsi_generic_write_seq(dsi, 0xff, 0x00);
+	dsi_generic_write_seq(dsi, 0x51, 0xff);
+	usleep_range(1000, 2000);
+	dsi_generic_write_seq(dsi, 0x55, 0x93);
+	usleep_range(1000, 2000);
+	dsi_generic_write_seq(dsi, 0x53, 0x24);
+	usleep_range(1000, 2000);
+	dsi_generic_write_seq(dsi, 0x11, 0x00);
+	msleep(150);
+	dsi_generic_write_seq(dsi, 0x29, 0x00);
+	msleep(64);
+
+	return 0;
+}
+
+static int oppo15009jdi_nt35592_off(struct oppo15009jdi_nt35592 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int oppo15009jdi_nt35592_prepare(struct drm_panel *panel)
+{
+	struct oppo15009jdi_nt35592 *ctx = to_oppo15009jdi_nt35592(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	oppo15009jdi_nt35592_reset(ctx);
+
+	ret = oppo15009jdi_nt35592_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int oppo15009jdi_nt35592_unprepare(struct drm_panel *panel)
+{
+	struct oppo15009jdi_nt35592 *ctx = to_oppo15009jdi_nt35592(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = oppo15009jdi_nt35592_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode oppo15009jdi_nt35592_mode = {
+	.clock = (720 + 160 + 2 + 160) * (1280 + 6 + 1 + 4) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 160,
+	.hsync_end = 720 + 160 + 2,
+	.htotal = 720 + 160 + 2 + 160,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 6,
+	.vsync_end = 1280 + 6 + 1,
+	.vtotal = 1280 + 6 + 1 + 4,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int oppo15009jdi_nt35592_get_modes(struct drm_panel *panel,
+					  struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &oppo15009jdi_nt35592_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs oppo15009jdi_nt35592_panel_funcs = {
+	.prepare = oppo15009jdi_nt35592_prepare,
+	.unprepare = oppo15009jdi_nt35592_unprepare,
+	.get_modes = oppo15009jdi_nt35592_get_modes,
+};
+
+static int oppo15009jdi_nt35592_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct oppo15009jdi_nt35592 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &oppo15009jdi_nt35592_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int oppo15009jdi_nt35592_remove(struct mipi_dsi_device *dsi)
+{
+	struct oppo15009jdi_nt35592 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id oppo15009jdi_nt35592_of_match[] = {
+	{ .compatible = "oppo,15009-nt35592-jdi" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, oppo15009jdi_nt35592_of_match);
+
+static struct mipi_dsi_driver oppo15009jdi_nt35592_driver = {
+	.probe = oppo15009jdi_nt35592_probe,
+	.remove = oppo15009jdi_nt35592_remove,
+	.driver = {
+		.name = "panel-oppo15009jdi-nt35592",
+		.of_match_table = oppo15009jdi_nt35592_of_match,
+	},
+};
+module_mipi_dsi_driver(oppo15009jdi_nt35592_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for oppo15009jdi nt35592 720p video video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c
new file mode 100644
index 00000000000..c5ab266aea9
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct ea8061v_ams497ee01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct ea8061v_ams497ee01 *to_ea8061v_ams497ee01(struct drm_panel *panel)
+{
+	return container_of(panel, struct ea8061v_ams497ee01, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void ea8061v_ams497ee01_reset(struct ea8061v_ams497ee01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int ea8061v_ams497ee01_on(struct ea8061v_ams497ee01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xb8, 0x19, 0x10);
+	dsi_dcs_write_seq(dsi, 0xba, 0x57);
+	dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x85);
+	dsi_dcs_write_seq(dsi, 0xcb, 0x70);
+	dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xca,
+			  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x00, 0x00, 0x00, 0x0a);
+	dsi_dcs_write_seq(dsi, 0xb6, 0x5c, 0x8a);
+	dsi_dcs_write_seq(dsi, 0xf7, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_off(struct ea8061v_ams497ee01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(100);
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_prepare(struct drm_panel *panel)
+{
+	struct ea8061v_ams497ee01 *ctx = to_ea8061v_ams497ee01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ea8061v_ams497ee01_reset(ctx);
+
+	ret = ea8061v_ams497ee01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int ea8061v_ams497ee01_unprepare(struct drm_panel *panel)
+{
+	struct ea8061v_ams497ee01 *ctx = to_ea8061v_ams497ee01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = ea8061v_ams497ee01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ea8061v_ams497ee01_mode = {
+	.clock = (720 + 80 + 96 + 128) * (1280 + 14 + 2 + 8) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 80,
+	.hsync_end = 720 + 80 + 96,
+	.htotal = 720 + 80 + 96 + 128,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 14,
+	.vsync_end = 1280 + 14 + 2,
+	.vtotal = 1280 + 14 + 2 + 8,
+	.width_mm = 62,
+	.height_mm = 110,
+};
+
+static int ea8061v_ams497ee01_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ea8061v_ams497ee01_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ea8061v_ams497ee01_panel_funcs = {
+	.prepare = ea8061v_ams497ee01_prepare,
+	.unprepare = ea8061v_ams497ee01_unprepare,
+	.get_modes = ea8061v_ams497ee01_get_modes,
+};
+
+static int ea8061v_ams497ee01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ea8061v_ams497ee01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &ea8061v_ams497ee01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_remove(struct mipi_dsi_device *dsi)
+{
+	struct ea8061v_ams497ee01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id ea8061v_ams497ee01_of_match[] = {
+	{ .compatible = "samsung,ea8061v-ams497ee01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ea8061v_ams497ee01_of_match);
+
+static struct mipi_dsi_driver ea8061v_ams497ee01_driver = {
+	.probe = ea8061v_ams497ee01_probe,
+	.remove = ea8061v_ams497ee01_remove,
+	.driver = {
+		.name = "panel-ea8061v-ams497ee01",
+		.of_match_table = ea8061v_ams497ee01_of_match,
+	},
+};
+module_mipi_dsi_driver(ea8061v_ams497ee01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_EA8061V_AMS497EE01_HD");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c
new file mode 100644
index 00000000000..2f308dcf889
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c
@@ -0,0 +1,219 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt51017 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	bool prepared;
+};
+
+static inline struct nt51017 *to_nt51017(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt51017, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static int nt51017_on(struct nt51017 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi_dcs_write_seq(dsi, 0x83, 0x96);
+	dsi_dcs_write_seq(dsi, 0x84, 0x69);
+	dsi_dcs_write_seq(dsi, 0x92, 0x19);
+	dsi_dcs_write_seq(dsi, 0x95, 0x00);
+	dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	dsi_dcs_write_seq(dsi, 0x84, 0x00);
+	dsi_dcs_write_seq(dsi, 0x90, 0x77);
+	dsi_dcs_write_seq(dsi, 0x94, 0xff);
+	dsi_dcs_write_seq(dsi, 0x96, 0xff);
+	dsi_dcs_write_seq(dsi, 0x91, 0xfd);
+	dsi_dcs_write_seq(dsi, 0x90, 0x77);
+
+	return 0;
+}
+
+static int nt51017_off(struct nt51017 *ctx)
+{
+	return 0;
+}
+
+static int nt51017_prepare(struct drm_panel *panel)
+{
+	struct nt51017 *ctx = to_nt51017(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	msleep(30);
+
+	ret = nt51017_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt51017_unprepare(struct drm_panel *panel)
+{
+	struct nt51017 *ctx = to_nt51017(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt51017_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt51017_mode = {
+	.clock = (800 + 152 + 8 + 128) * (1280 + 18 + 1 + 23) * 60 / 1000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 152,
+	.hsync_end = 800 + 152 + 8,
+	.htotal = 800 + 152 + 8 + 128,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 18,
+	.vsync_end = 1280 + 18 + 1,
+	.vtotal = 1280 + 18 + 1 + 23,
+	.width_mm = 129,
+	.height_mm = 206,
+};
+
+static int nt51017_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt51017_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt51017_panel_funcs = {
+	.prepare = nt51017_prepare,
+	.unprepare = nt51017_unprepare,
+	.get_modes = nt51017_get_modes,
+};
+
+static int nt51017_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt51017 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "lcd");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get lcd regulator\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &nt51017_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt51017_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt51017 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id nt51017_of_match[] = {
+	{ .compatible = "samsung,nt51017-b4p096wx5vp09" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt51017_of_match);
+
+static struct mipi_dsi_driver nt51017_driver = {
+	.probe = nt51017_probe,
+	.remove = nt51017_remove,
+	.driver = {
+		.name = "panel-nt51017",
+		.of_match_table = nt51017_of_match,
+	},
+};
+module_mipi_dsi_driver(nt51017_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for NT51017 wxga video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-lsl080al03.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-lsl080al03.c
new file mode 100644
index 00000000000..15a9ba743ef
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-lsl080al03.c
@@ -0,0 +1,359 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct s6d7aa0_lsl080al03 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct s6d7aa0_lsl080al03 *to_s6d7aa0_lsl080al03(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d7aa0_lsl080al03, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void s6d7aa0_lsl080al03_reset(struct s6d7aa0_lsl080al03 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int s6d7aa0_lsl080al03_on(struct s6d7aa0_lsl080al03 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xd0, 0x00, 0x10);
+	dsi_dcs_write_seq(dsi, 0xc3, 0xc7, 0x00, 0x29);
+	dsi_dcs_write_seq(dsi, 0xbc, 0x01, 0x4e, 0xa0);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x16, 0x10, 0x11, 0x23, 0x09);
+	dsi_dcs_write_seq(dsi, 0xfe, 0x00, 0x02, 0x03, 0x21, 0x80, 0x78);
+	dsi_dcs_write_seq(dsi, 0xb3, 0x51);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, 0xf2, 0x02, 0x08, 0x08);
+	usleep_range(10000, 11000);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x80, 0x80, 0x30);
+	dsi_dcs_write_seq(dsi, 0xcd,
+			  0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+			  0x2e, 0x2e, 0x2e, 0x2e);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc1, 0x03);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int s6d7aa0_lsl080al03_off(struct s6d7aa0_lsl080al03 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0x22, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(64);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int s6d7aa0_lsl080al03_prepare(struct drm_panel *panel)
+{
+	struct s6d7aa0_lsl080al03 *ctx = to_s6d7aa0_lsl080al03(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6d7aa0_lsl080al03_reset(ctx);
+
+	ret = s6d7aa0_lsl080al03_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int s6d7aa0_lsl080al03_unprepare(struct drm_panel *panel)
+{
+	struct s6d7aa0_lsl080al03 *ctx = to_s6d7aa0_lsl080al03(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = s6d7aa0_lsl080al03_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode s6d7aa0_lsl080al03_mode = {
+	.clock = (768 + 18 + 16 + 126) * (1024 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 768,
+	.hsync_start = 768 + 18,
+	.hsync_end = 768 + 18 + 16,
+	.htotal = 768 + 18 + 16 + 126,
+	.vdisplay = 1024,
+	.vsync_start = 1024 + 8,
+	.vsync_end = 1024 + 8 + 2,
+	.vtotal = 1024 + 8 + 2 + 6,
+	.width_mm = 122,
+	.height_mm = 163,
+};
+
+static int s6d7aa0_lsl080al03_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &s6d7aa0_lsl080al03_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs s6d7aa0_lsl080al03_panel_funcs = {
+	.prepare = s6d7aa0_lsl080al03_prepare,
+	.unprepare = s6d7aa0_lsl080al03_unprepare,
+	.get_modes = s6d7aa0_lsl080al03_get_modes,
+};
+
+static int s6d7aa0_lsl080al03_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int s6d7aa0_lsl080al03_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops s6d7aa0_lsl080al03_bl_ops = {
+	.update_status = s6d7aa0_lsl080al03_bl_update_status,
+	.get_brightness = s6d7aa0_lsl080al03_bl_get_brightness,
+};
+
+static struct backlight_device *
+s6d7aa0_lsl080al03_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &s6d7aa0_lsl080al03_bl_ops, &props);
+}
+
+static int s6d7aa0_lsl080al03_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d7aa0_lsl080al03 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "5p4v";
+	ctx->supplies[1].supply = "vmipi";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &s6d7aa0_lsl080al03_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = s6d7aa0_lsl080al03_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d7aa0_lsl080al03_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d7aa0_lsl080al03 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id s6d7aa0_lsl080al03_of_match[] = {
+	{ .compatible = "samsung,s6d7aa0-lsl080al03" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d7aa0_lsl080al03_of_match);
+
+static struct mipi_dsi_driver s6d7aa0_lsl080al03_driver = {
+	.probe = s6d7aa0_lsl080al03_probe,
+	.remove = s6d7aa0_lsl080al03_remove,
+	.driver = {
+		.name = "panel-s6d7aa0-lsl080al03",
+		.of_match_table = s6d7aa0_lsl080al03_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d7aa0_lsl080al03_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for S6D7AA0 LSL080AL03 wxga video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-ltl101at01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-ltl101at01.c
new file mode 100644
index 00000000000..8978f1cbf88
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d7aa0-ltl101at01.c
@@ -0,0 +1,359 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct s6d7aa0_ltl101at01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct s6d7aa0_ltl101at01 *to_s6d7aa0_ltl101at01(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d7aa0_ltl101at01, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void s6d7aa0_ltl101at01_reset(struct s6d7aa0_ltl101at01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int s6d7aa0_ltl101at01_on(struct s6d7aa0_ltl101at01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xd0, 0x00, 0x10);
+	dsi_dcs_write_seq(dsi, 0xc3, 0x40, 0x00, 0x08);
+	dsi_dcs_write_seq(dsi, 0xbc, 0x01, 0x4e, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x16, 0x10, 0x11, 0x23, 0x09);
+	dsi_dcs_write_seq(dsi, 0xfe, 0x00, 0x02, 0x03, 0x21, 0x80, 0x68);
+	dsi_dcs_write_seq(dsi, 0xb3, 0x51);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, 0xf2, 0x02, 0x08, 0x08);
+	usleep_range(10000, 11000);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x80, 0x80, 0x30);
+	dsi_dcs_write_seq(dsi, 0xcd,
+			  0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+			  0x2e, 0x2e, 0x2e, 0x2e);
+	dsi_dcs_write_seq(dsi, 0xce,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc1, 0x03);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int s6d7aa0_ltl101at01_off(struct s6d7aa0_ltl101at01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0x22, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(64);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int s6d7aa0_ltl101at01_prepare(struct drm_panel *panel)
+{
+	struct s6d7aa0_ltl101at01 *ctx = to_s6d7aa0_ltl101at01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6d7aa0_ltl101at01_reset(ctx);
+
+	ret = s6d7aa0_ltl101at01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int s6d7aa0_ltl101at01_unprepare(struct drm_panel *panel)
+{
+	struct s6d7aa0_ltl101at01 *ctx = to_s6d7aa0_ltl101at01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = s6d7aa0_ltl101at01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode s6d7aa0_ltl101at01_mode = {
+	.clock = (768 + 96 + 16 + 184) * (1024 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 768,
+	.hsync_start = 768 + 96,
+	.hsync_end = 768 + 96 + 16,
+	.htotal = 768 + 96 + 16 + 184,
+	.vdisplay = 1024,
+	.vsync_start = 1024 + 8,
+	.vsync_end = 1024 + 8 + 2,
+	.vtotal = 1024 + 8 + 2 + 6,
+	.width_mm = 148,
+	.height_mm = 197,
+};
+
+static int s6d7aa0_ltl101at01_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &s6d7aa0_ltl101at01_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs s6d7aa0_ltl101at01_panel_funcs = {
+	.prepare = s6d7aa0_ltl101at01_prepare,
+	.unprepare = s6d7aa0_ltl101at01_unprepare,
+	.get_modes = s6d7aa0_ltl101at01_get_modes,
+};
+
+static int s6d7aa0_ltl101at01_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int s6d7aa0_ltl101at01_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops s6d7aa0_ltl101at01_bl_ops = {
+	.update_status = s6d7aa0_ltl101at01_bl_update_status,
+	.get_brightness = s6d7aa0_ltl101at01_bl_get_brightness,
+};
+
+static struct backlight_device *
+s6d7aa0_ltl101at01_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &s6d7aa0_ltl101at01_bl_ops, &props);
+}
+
+static int s6d7aa0_ltl101at01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d7aa0_ltl101at01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vmipi";
+	ctx->supplies[1].supply = "5p4v";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &s6d7aa0_ltl101at01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = s6d7aa0_ltl101at01_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d7aa0_ltl101at01_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d7aa0_ltl101at01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id s6d7aa0_ltl101at01_of_match[] = {
+	{ .compatible = "samsung,s6d7aa0-ltl101at01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d7aa0_ltl101at01_of_match);
+
+static struct mipi_dsi_driver s6d7aa0_ltl101at01_driver = {
+	.probe = s6d7aa0_ltl101at01_probe,
+	.remove = s6d7aa0_ltl101at01_remove,
+	.driver = {
+		.name = "panel-s6d7aa0-ltl101at01",
+		.of_match_table = s6d7aa0_ltl101at01_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d7aa0_ltl101at01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for S6D7AA0 xga video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c
new file mode 100644
index 00000000000..ad7da7f5bee
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c
@@ -0,0 +1,288 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct s6e88a0_ams427ap24 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct s6e88a0_ams427ap24 *to_s6e88a0_ams427ap24(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6e88a0_ams427ap24, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void s6e88a0_ams427ap24_reset(struct s6e88a0_ams427ap24 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(18000, 19000);
+}
+
+static int s6e88a0_ams427ap24_on(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x11);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x11);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x13);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x18);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x02);
+	dsi_dcs_write_seq(dsi, 0xb8, 0x30);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0xcc, 0x4c);
+	dsi_dcs_write_seq(dsi, 0xf2, 0x03, 0x0d);
+	dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xca,
+			  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			  0x80, 0x80, 0x80, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x40, 0x08, 0x20, 0x00, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb6, 0x28, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xf7, 0x03);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_off(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_prepare(struct drm_panel *panel)
+{
+	struct s6e88a0_ams427ap24 *ctx = to_s6e88a0_ams427ap24(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6e88a0_ams427ap24_reset(ctx);
+
+	ret = s6e88a0_ams427ap24_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_unprepare(struct drm_panel *panel)
+{
+	struct s6e88a0_ams427ap24 *ctx = to_s6e88a0_ams427ap24(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = s6e88a0_ams427ap24_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode s6e88a0_ams427ap24_mode = {
+	.clock = (540 + 94 + 4 + 18) * (960 + 12 + 1 + 3) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 94,
+	.hsync_end = 540 + 94 + 4,
+	.htotal = 540 + 94 + 4 + 18,
+	.vdisplay = 960,
+	.vsync_start = 960 + 12,
+	.vsync_end = 960 + 12 + 1,
+	.vtotal = 960 + 12 + 1 + 3,
+	.width_mm = 55,
+	.height_mm = 95,
+};
+
+static int s6e88a0_ams427ap24_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &s6e88a0_ams427ap24_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs s6e88a0_ams427ap24_panel_funcs = {
+	.prepare = s6e88a0_ams427ap24_prepare,
+	.unprepare = s6e88a0_ams427ap24_unprepare,
+	.get_modes = s6e88a0_ams427ap24_get_modes,
+};
+
+static int s6e88a0_ams427ap24_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6e88a0_ams427ap24 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &s6e88a0_ams427ap24_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6e88a0_ams427ap24 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id s6e88a0_ams427ap24_of_match[] = {
+	{ .compatible = "samsung,s6e88a0-ams427ap24" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6e88a0_ams427ap24_of_match);
+
+static struct mipi_dsi_driver s6e88a0_ams427ap24_driver = {
+	.probe = s6e88a0_ams427ap24_probe,
+	.remove = s6e88a0_ams427ap24_remove,
+	.driver = {
+		.name = "panel-s6e88a0-ams427ap24",
+		.of_match_table = s6e88a0_ams427ap24_of_match,
+	},
+};
+module_mipi_dsi_driver(s6e88a0_ams427ap24_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_S6E88A0_AMS427AP24_QHD");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-tc358764-ltl101al06.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-tc358764-ltl101al06.c
new file mode 100644
index 00000000000..eccd52e6a35
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-tc358764-ltl101al06.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct tc358764_ltl101a106 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	struct clk *pwm_clk;
+	bool prepared;
+};
+
+static inline
+struct tc358764_ltl101a106 *to_tc358764_ltl101a106(struct drm_panel *panel)
+{
+	return container_of(panel, struct tc358764_ltl101a106, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+/* FIXME: Fix panel initialization */
+
+static void tc358764_ltl101a106_reset(struct tc358764_ltl101a106 *ctx)
+{
+#if 0
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+#endif
+}
+
+static int tc358764_ltl101a106_on(struct tc358764_ltl101a106 *ctx)
+{
+#if 0
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0x3c, 0x01, 0x06, 0x00, 0x05, 0x00);
+	dsi_generic_write_seq(dsi, 0x14, 0x01, 0x04, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x64, 0x01, 0x04, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x68, 0x01, 0x04, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x6c, 0x01, 0x04, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x70, 0x01, 0x04, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x34, 0x01, 0x1f, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x10, 0x02, 0x1f, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x50, 0x04, 0x20, 0x01, 0xf0, 0x03);
+	dsi_generic_write_seq(dsi, 0x54, 0x04, 0x02, 0x00, 0x30, 0x00);
+	dsi_generic_write_seq(dsi, 0x58, 0x04, 0x20, 0x03, 0x30, 0x00);
+	dsi_generic_write_seq(dsi, 0x5c, 0x04, 0x02, 0x00, 0x40, 0x00);
+	dsi_generic_write_seq(dsi, 0x60, 0x04, 0x00, 0x05, 0x20, 0x00);
+	dsi_generic_write_seq(dsi, 0x64, 0x04, 0x01, 0x00, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xa0, 0x04, 0x06, 0x80, 0x44, 0x00);
+	usleep_range(2000, 3000);
+	dsi_generic_write_seq(dsi, 0xa0, 0x04, 0x06, 0x80, 0x04, 0x00);
+	usleep_range(2000, 3000);
+	dsi_generic_write_seq(dsi, 0x04, 0x05, 0x04, 0x00, 0x00, 0x00);
+	usleep_range(2000, 3000);
+	dsi_generic_write_seq(dsi, 0x80, 0x04, 0x00, 0x01, 0x02, 0x03);
+	dsi_generic_write_seq(dsi, 0x84, 0x04, 0x04, 0x07, 0x05, 0x08);
+	dsi_generic_write_seq(dsi, 0x88, 0x04, 0x09, 0x0a, 0x0e, 0x0f);
+	dsi_generic_write_seq(dsi, 0x8c, 0x04, 0x0b, 0x0c, 0x0d, 0x10);
+	dsi_generic_write_seq(dsi, 0x90, 0x04, 0x16, 0x17, 0x11, 0x12);
+	dsi_generic_write_seq(dsi, 0x94, 0x04, 0x13, 0x14, 0x15, 0x1b);
+	dsi_generic_write_seq(dsi, 0x98, 0x04, 0x18, 0x19, 0x1a, 0x06);
+	dsi_generic_write_seq(dsi, 0x9c, 0x04, 0x01, 0x00, 0x00, 0x00);
+#endif
+
+	return 0;
+}
+
+static int tc358764_ltl101a106_off(struct tc358764_ltl101a106 *ctx)
+{
+#if 0
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0xa0, 0x04, 0x01, 0x00, 0x00, 0x00);
+	usleep_range(1000, 2000);
+	dsi_generic_write_seq(dsi, 0x9c, 0x04, 0x00, 0x00, 0x00, 0x00);
+#endif
+
+	return 0;
+}
+
+static int tc358764_ltl101a106_prepare(struct drm_panel *panel)
+{
+	struct tc358764_ltl101a106 *ctx = to_tc358764_ltl101a106(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tc358764_ltl101a106_reset(ctx);
+
+	ret = tc358764_ltl101a106_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->pwm_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable pwm clock: %d\n", ret);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int tc358764_ltl101a106_unprepare(struct drm_panel *panel)
+{
+	struct tc358764_ltl101a106 *ctx = to_tc358764_ltl101a106(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	clk_disable_unprepare(ctx->pwm_clk);
+
+	ret = tc358764_ltl101a106_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode tc358764_ltl101a106_mode = {
+	.clock = (1280 + 52 + 4 + 48) * (800 + 32 + 6 + 64) * 60 / 1000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 52,
+	.hsync_end = 1280 + 52 + 4,
+	.htotal = 1280 + 52 + 4 + 48,
+	.vdisplay = 800,
+	.vsync_start = 800 + 32,
+	.vsync_end = 800 + 32 + 6,
+	.vtotal = 800 + 32 + 6 + 64,
+	.width_mm = 228,
+	.height_mm = 149,
+};
+
+static int tc358764_ltl101a106_get_modes(struct drm_panel *panel,
+					 struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &tc358764_ltl101a106_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs tc358764_ltl101a106_panel_funcs = {
+	.prepare = tc358764_ltl101a106_prepare,
+	.unprepare = tc358764_ltl101a106_unprepare,
+	.get_modes = tc358764_ltl101a106_get_modes,
+};
+
+static int tc358764_ltl101a106_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tc358764_ltl101a106 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "lcd";
+	ctx->supplies[1].supply = "lvds";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_ASIS);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->pwm_clk = devm_clk_get(dev, "pwm");
+	if (IS_ERR(ctx->pwm_clk))
+		return dev_err_probe(dev, PTR_ERR(ctx->pwm_clk),
+				     "Failed to get pwm clock\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &tc358764_ltl101a106_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tc358764_ltl101a106_remove(struct mipi_dsi_device *dsi)
+{
+	struct tc358764_ltl101a106 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id tc358764_ltl101a106_of_match[] = {
+	{ .compatible = "samsung,tc358764-ltl101al06" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tc358764_ltl101a106_of_match);
+
+static struct mipi_dsi_driver tc358764_ltl101a106_driver = {
+	.probe = tc358764_ltl101a106_probe,
+	.remove = tc358764_ltl101a106_remove,
+	.driver = {
+		.name = "panel-tc358764-ltl101a106",
+		.of_match_table = tc358764_ltl101a106_of_match,
+	},
+};
+module_mipi_dsi_driver(tc358764_ltl101a106_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_TC358764_LTL101A106_WXGA");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c
new file mode 100644
index 00000000000..532c031ee2c
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c
@@ -0,0 +1,271 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt35521 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct nt35521 *to_nt35521(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt35521, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void nt35521_reset(struct nt35521 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int nt35521_on(struct nt35521 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc8, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	dsi_dcs_write_seq(dsi, 0xef, 0x11, 0x08, 0x16, 0x19);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x04, 0x04);
+	dsi_dcs_write_seq(dsi, 0xb9, 0x35, 0x35);
+	dsi_dcs_write_seq(dsi, 0xba, 0x25, 0x25);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_off(struct nt35521 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_prepare(struct drm_panel *panel)
+{
+	struct nt35521 *ctx = to_nt35521(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt35521_reset(ctx);
+
+	ret = nt35521_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt35521_unprepare(struct drm_panel *panel)
+{
+	struct nt35521 *ctx = to_nt35521(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt35521_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt35521_mode = {
+	.clock = (720 + 160 + 20 + 160) * (1280 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 160,
+	.hsync_end = 720 + 160 + 20,
+	.htotal = 720 + 160 + 20 + 160,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 2,
+	.vtotal = 1280 + 16 + 2 + 16,
+	.width_mm = 58,
+	.height_mm = 103,
+};
+
+static int nt35521_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt35521_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt35521_panel_funcs = {
+	.prepare = nt35521_prepare,
+	.unprepare = nt35521_unprepare,
+	.get_modes = nt35521_get_modes,
+};
+
+static int nt35521_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt35521 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt35521_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt35521 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id nt35521_of_match[] = {
+	{ .compatible = "wingtech,auo-nt35521" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt35521_of_match);
+
+static struct mipi_dsi_driver nt35521_driver = {
+	.probe = nt35521_probe,
+	.remove = nt35521_remove,
+	.driver = {
+		.name = "panel-nt35521",
+		.of_match_table = nt35521_of_match,
+	},
+};
+module_mipi_dsi_driver(nt35521_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt35521_HD720p_video_AUO5");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c
new file mode 100644
index 00000000000..e5849050f17
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct r61308 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct r61308 *to_r61308(struct drm_panel *panel)
+{
+	return container_of(panel, struct r61308, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void r61308_reset(struct r61308 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int r61308_on(struct r61308 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x07);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	dsi_generic_write_seq(dsi, 0xb0, 0x04);
+	dsi_generic_write_seq(dsi, 0xc1,
+			      0x50, 0x02, 0x22, 0x00, 0x00, 0xed, 0x11);
+	dsi_generic_write_seq(dsi, 0xc8,
+			      0x1a, 0x24, 0x29, 0x2d, 0x32, 0x37, 0x14, 0x13,
+			      0x10, 0x0c, 0x0a, 0x06, 0x1a, 0x24, 0x28, 0x2d,
+			      0x32, 0x37, 0x14, 0x13, 0x10, 0x0c, 0x0a, 0x06);
+	dsi_generic_write_seq(dsi, 0xcb,
+			      0x10, 0x20, 0x40, 0x80, 0xa0, 0xc0, 0xd0, 0xe0);
+	dsi_generic_write_seq(dsi, 0xcc, 0xc8, 0xd8, 0xff);
+	dsi_generic_write_seq(dsi, 0xcd,
+			      0x1c, 0x1e, 0x1e, 0x1d, 0x1c, 0x1e, 0x1e);
+	dsi_generic_write_seq(dsi, 0xce,
+			      0x1e, 0x1e, 0x1e, 0x1d, 0x1d, 0x1e, 0x1e);
+	dsi_generic_write_seq(dsi, 0xcf,
+			      0x1e, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x21);
+	dsi_generic_write_seq(dsi, 0xb0, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int r61308_off(struct r61308 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r61308_prepare(struct drm_panel *panel)
+{
+	struct r61308 *ctx = to_r61308(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r61308_reset(ctx);
+
+	ret = r61308_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int r61308_unprepare(struct drm_panel *panel)
+{
+	struct r61308 *ctx = to_r61308(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = r61308_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode r61308_mode = {
+	.clock = (720 + 120 + 2 + 50) * (1280 + 6 + 1 + 14) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 120,
+	.hsync_end = 720 + 120 + 2,
+	.htotal = 720 + 120 + 2 + 50,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 6,
+	.vsync_end = 1280 + 6 + 1,
+	.vtotal = 1280 + 6 + 1 + 14,
+	.width_mm = 58,
+	.height_mm = 103,
+};
+
+static int r61308_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &r61308_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs r61308_panel_funcs = {
+	.prepare = r61308_prepare,
+	.unprepare = r61308_unprepare,
+	.get_modes = r61308_get_modes,
+};
+
+static int r61308_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r61308 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r61308_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r61308_remove(struct mipi_dsi_device *dsi)
+{
+	struct r61308 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id r61308_of_match[] = {
+	{ .compatible = "wingtech,auo-r61308" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r61308_of_match);
+
+static struct mipi_dsi_driver r61308_driver = {
+	.probe = r61308_probe,
+	.remove = r61308_remove,
+	.driver = {
+		.name = "panel-r61308",
+		.of_match_table = r61308_of_match,
+	},
+};
+module_mipi_dsi_driver(r61308_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for r61308_HD720p_video_AUO3.5");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c
new file mode 100644
index 00000000000..775ebce1d9e
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c
@@ -0,0 +1,271 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt35521s {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct nt35521s *to_nt35521s(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt35521s, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void nt35521s_reset(struct nt35521s *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int nt35521s_on(struct nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0x25, 0x01);
+	dsi_generic_write_seq(dsi, 0x6f, 0x21);
+	dsi_generic_write_seq(dsi, 0xf7, 0x01);
+	dsi_generic_write_seq(dsi, 0x6f, 0x21);
+	dsi_generic_write_seq(dsi, 0xf7, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0x25, 0x00);
+	dsi_generic_write_seq(dsi, 0x35, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521s_off(struct nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int nt35521s_prepare(struct drm_panel *panel)
+{
+	struct nt35521s *ctx = to_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt35521s_reset(ctx);
+
+	ret = nt35521s_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt35521s_unprepare(struct drm_panel *panel)
+{
+	struct nt35521s *ctx = to_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt35521s_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt35521s_mode = {
+	.clock = (720 + 160 + 20 + 160) * (1280 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 160,
+	.hsync_end = 720 + 160 + 20,
+	.htotal = 720 + 160 + 20 + 160,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 2,
+	.vtotal = 1280 + 16 + 2 + 16,
+	.width_mm = 58,
+	.height_mm = 103,
+};
+
+static int nt35521s_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt35521s_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt35521s_panel_funcs = {
+	.prepare = nt35521s_prepare,
+	.unprepare = nt35521s_unprepare,
+	.get_modes = nt35521s_get_modes,
+};
+
+static int nt35521s_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt35521s *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt35521s_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521s_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt35521s *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id nt35521s_of_match[] = {
+	{ .compatible = "wingtech,boe-nt35521s" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt35521s_of_match);
+
+static struct mipi_dsi_driver nt35521s_driver = {
+	.probe = nt35521s_probe,
+	.remove = nt35521s_remove,
+	.driver = {
+		.name = "panel-nt35521s",
+		.of_match_table = nt35521s_of_match,
+	},
+};
+module_mipi_dsi_driver(nt35521s_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt35521s_HD720p_video_BOE");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c
new file mode 100644
index 00000000000..c0e577442f2
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c
@@ -0,0 +1,259 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct otm1285a_otp {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct otm1285a_otp *to_otm1285a_otp(struct drm_panel *panel)
+{
+	return container_of(panel, struct otm1285a_otp, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void otm1285a_otp_reset(struct otm1285a_otp *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int otm1285a_otp_on(struct otm1285a_otp *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x85, 0x01);
+	dsi_generic_write_seq(dsi, 0x00, 0x80);
+	dsi_generic_write_seq(dsi, 0xff, 0x12, 0x85);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x11);
+	msleep(120);
+	dsi_generic_write_seq(dsi, 0x00, 0x00);
+	dsi_generic_write_seq(dsi, 0x29);
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int otm1285a_otp_off(struct otm1285a_otp *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int otm1285a_otp_prepare(struct drm_panel *panel)
+{
+	struct otm1285a_otp *ctx = to_otm1285a_otp(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	otm1285a_otp_reset(ctx);
+
+	ret = otm1285a_otp_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int otm1285a_otp_unprepare(struct drm_panel *panel)
+{
+	struct otm1285a_otp *ctx = to_otm1285a_otp(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = otm1285a_otp_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode otm1285a_otp_mode = {
+	.clock = (720 + 28 + 2 + 28) * (1280 + 30 + 2 + 30) * 59 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 28,
+	.hsync_end = 720 + 28 + 2,
+	.htotal = 720 + 28 + 2 + 28,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 30,
+	.vsync_end = 1280 + 30 + 2,
+	.vtotal = 1280 + 30 + 2 + 30,
+	.width_mm = 58,
+	.height_mm = 103,
+};
+
+static int otm1285a_otp_get_modes(struct drm_panel *panel,
+				  struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &otm1285a_otp_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs otm1285a_otp_panel_funcs = {
+	.prepare = otm1285a_otp_prepare,
+	.unprepare = otm1285a_otp_unprepare,
+	.get_modes = otm1285a_otp_get_modes,
+};
+
+static int otm1285a_otp_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct otm1285a_otp *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &otm1285a_otp_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int otm1285a_otp_remove(struct mipi_dsi_device *dsi)
+{
+	struct otm1285a_otp *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id otm1285a_otp_of_match[] = {
+	{ .compatible = "wingtech,ebbg-otm1285a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, otm1285a_otp_of_match);
+
+static struct mipi_dsi_driver otm1285a_otp_driver = {
+	.probe = otm1285a_otp_probe,
+	.remove = otm1285a_otp_remove,
+	.driver = {
+		.name = "panel-otm1285a-otp",
+		.of_match_table = otm1285a_otp_of_match,
+	},
+};
+module_mipi_dsi_driver(otm1285a_otp_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for otm1285a_otp_720p_video_EBBG");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c
new file mode 100644
index 00000000000..cddd51585a8
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct r69431 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct r69431 *to_r69431(struct drm_panel *panel)
+{
+	return container_of(panel, struct r69431, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void r69431_reset(struct r69431 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int r69431_on(struct r69431 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_generic_write_seq(dsi, 0xb0, 0x00);
+	dsi_generic_write_seq(dsi, 0xd6, 0x01);
+	dsi_generic_write_seq(dsi, 0xb3, 0x1c);
+	dsi_generic_write_seq(dsi, 0xb0, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r69431_off(struct r69431 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(220);
+
+	return 0;
+}
+
+static int r69431_prepare(struct drm_panel *panel)
+{
+	struct r69431 *ctx = to_r69431(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r69431_reset(ctx);
+
+	ret = r69431_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int r69431_unprepare(struct drm_panel *panel)
+{
+	struct r69431 *ctx = to_r69431(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = r69431_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode r69431_mode = {
+	.clock = (720 + 120 + 10 + 20) * (1280 + 13 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 120,
+	.hsync_end = 720 + 120 + 10,
+	.htotal = 720 + 120 + 10 + 20,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 13,
+	.vsync_end = 1280 + 13 + 1,
+	.vtotal = 1280 + 13 + 1 + 11,
+	.width_mm = 58,
+	.height_mm = 103,
+};
+
+static int r69431_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &r69431_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs r69431_panel_funcs = {
+	.prepare = r69431_prepare,
+	.unprepare = r69431_unprepare,
+	.get_modes = r69431_get_modes,
+};
+
+static int r69431_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r69431 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r69431_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r69431_remove(struct mipi_dsi_device *dsi)
+{
+	struct r69431 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id r69431_of_match[] = {
+	{ .compatible = "wingtech,sharp-r69431" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r69431_of_match);
+
+static struct mipi_dsi_driver r69431_driver = {
+	.probe = r69431_probe,
+	.remove = r69431_remove,
+	.driver = {
+		.name = "panel-r69431",
+		.of_match_table = r69431_of_match,
+	},
+};
+module_mipi_dsi_driver(r69431_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for r69431_HD720p_video_sharp");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c
new file mode 100644
index 00000000000..35b21484890
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c
@@ -0,0 +1,328 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct hx8394d {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct hx8394d *to_hx8394d(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void hx8394d_reset(struct hx8394d *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+}
+
+static int hx8394d_on(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	dsi_dcs_write_seq(dsi, 0xba, 0x33, 0x83, 0x20, 0x65, 0xb2, 0x09);
+	dsi_dcs_write_seq(dsi, 0xb1,
+			  0x6c, 0x11, 0x11, 0x37, 0x04, 0x11, 0xf1, 0x80, 0xdf,
+			  0x94, 0x23, 0x80, 0xc0, 0xd2, 0x18);
+	dsi_dcs_write_seq(dsi, 0xb2,
+			  0x00, 0x64, 0x0e, 0x0d, 0x32, 0x23, 0x08, 0x08, 0x1c,
+			  0x4d, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb4,
+			  0x00, 0xff, 0x03, 0x46, 0x03, 0x46, 0x03, 0x46, 0x01,
+			  0x6a, 0x01, 0x6a);
+	dsi_dcs_write_seq(dsi, 0xbf, 0x41, 0x0e, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd3,
+			  0x00, 0x07, 0x00, 0x00, 0x00, 0x10, 0x00, 0x32, 0x10,
+			  0x05, 0x00, 0x05, 0x32, 0x10, 0x00, 0x00, 0x00, 0x32,
+			  0x10, 0x00, 0x00, 0x00, 0x36, 0x03, 0x09, 0x09, 0x37,
+			  0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,
+			  0x01);
+	dsi_dcs_write_seq(dsi, 0xd5,
+			  0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 0x20,
+			  0x21, 0x22, 0x23, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x24, 0x25, 0x18, 0x18, 0x19, 0x19);
+	dsi_dcs_write_seq(dsi, 0xd6,
+			  0x05, 0x04, 0x07, 0x06, 0x01, 0x00, 0x03, 0x02, 0x23,
+			  0x22, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x58, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			  0x18, 0x18, 0x25, 0x24, 0x19, 0x19, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xe0,
+			  0x02, 0x10, 0x14, 0x2c, 0x2f, 0x3f, 0x22, 0x40, 0x06,
+			  0x0a, 0x0c, 0x17, 0x0e, 0x12, 0x14, 0x13, 0x14, 0x08,
+			  0x12, 0x14, 0x1b, 0x02, 0x10, 0x14, 0x2c, 0x2f, 0x3f,
+			  0x22, 0x40, 0x06, 0x0a, 0x0c, 0x17, 0x0e, 0x12, 0x14,
+			  0x13, 0x14, 0x08, 0x12, 0x14, 0x1b);
+	dsi_dcs_write_seq(dsi, 0xcc, 0x09);
+	dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x40, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00ff);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	dsi_dcs_write_seq(dsi, 0xe4, 0x51, 0x00);
+	dsi_dcs_write_seq(dsi, 0xe6,
+			  0x00, 0x00, 0x00, 0x05, 0x05, 0x10, 0x0a, 0x08, 0x10,
+			  0x20, 0x20, 0x0c, 0x08, 0x0f, 0x20, 0x20, 0x20);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(200);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_off(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int hx8394d_prepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_reset(ctx);
+
+	ret = hx8394d_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int hx8394d_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = hx8394d_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_mode = {
+	.clock = (720 + 168 + 24 + 240) * (1280 + 20 + 4 + 12) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 168,
+	.hsync_end = 720 + 168 + 24,
+	.htotal = 720 + 168 + 24 + 240,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 12,
+	.width_mm = 59,
+	.height_mm = 104,
+};
+
+static int hx8394d_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &hx8394d_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394d_panel_funcs = {
+	.prepare = hx8394d_prepare,
+	.unprepare = hx8394d_unprepare,
+	.get_modes = hx8394d_get_modes,
+};
+
+static int hx8394d_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id hx8394d_of_match[] = {
+	{ .compatible = "wingtech,tianma-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_of_match);
+
+static struct mipi_dsi_driver hx8394d_driver = {
+	.probe = hx8394d_probe,
+	.remove = hx8394d_remove,
+	.driver = {
+		.name = "panel-hx8394d",
+		.of_match_table = hx8394d_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d_HD720p_video_Tianma");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c
new file mode 100644
index 00000000000..47c50cfdfaf
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2021 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct ili9881 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct ili9881 *to_ili9881(struct drm_panel *panel)
+{
+	return container_of(panel, struct ili9881, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void ili9881_reset(struct ili9881 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int ili9881_on(struct ili9881 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x07);
+	dsi_dcs_write_seq(dsi, 0x03, 0x20);
+	dsi_dcs_write_seq(dsi, 0x04, 0x06);
+	dsi_dcs_write_seq(dsi, 0x05, 0x00);
+	dsi_dcs_write_seq(dsi, 0x06, 0x01);
+	dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0x09, 0x00);
+	dsi_dcs_write_seq(dsi, 0x0a, 0x00);
+	dsi_dcs_write_seq(dsi, 0x0b, 0x2f);
+	dsi_dcs_write_seq(dsi, 0x0c, 0x00);
+	dsi_dcs_write_seq(dsi, 0x0d, 0x00);
+	dsi_dcs_write_seq(dsi, 0x0e, 0x00);
+	dsi_dcs_write_seq(dsi, 0x0f, 0x00);
+	dsi_dcs_write_seq(dsi, 0x10, 0x40);
+	dsi_dcs_write_seq(dsi, 0x11, 0x02);
+	dsi_dcs_write_seq(dsi, 0x12, 0x05);
+	dsi_dcs_write_seq(dsi, 0x13, 0x90);
+	dsi_dcs_write_seq(dsi, 0x14, 0x02);
+	dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	dsi_dcs_write_seq(dsi, 0x16, 0x2f);
+	dsi_dcs_write_seq(dsi, 0x17, 0x2f);
+	dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	dsi_dcs_write_seq(dsi, 0x1a, 0x00);
+	dsi_dcs_write_seq(dsi, 0x1b, 0x50);
+	dsi_dcs_write_seq(dsi, 0x1c, 0x2c);
+	dsi_dcs_write_seq(dsi, 0x1d, 0x0c);
+	dsi_dcs_write_seq(dsi, 0x1e, 0x00);
+	dsi_dcs_write_seq(dsi, 0x1f, 0x87);
+	dsi_dcs_write_seq(dsi, 0x20, 0x86);
+	dsi_dcs_write_seq(dsi, 0x21, 0x00);
+	dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	dsi_dcs_write_seq(dsi, 0x23, 0xc0);
+	dsi_dcs_write_seq(dsi, 0x24, 0x30);
+	dsi_dcs_write_seq(dsi, 0x25, 0x00);
+	dsi_dcs_write_seq(dsi, 0x26, 0x00);
+	dsi_dcs_write_seq(dsi, 0x27, 0x03);
+	dsi_dcs_write_seq(dsi, 0x30, 0x01);
+	dsi_dcs_write_seq(dsi, 0x31, 0x23);
+	dsi_dcs_write_seq(dsi, 0x32, 0x45);
+	dsi_dcs_write_seq(dsi, 0x33, 0x67);
+	dsi_dcs_write_seq(dsi, 0x34, 0x89);
+	dsi_dcs_write_seq(dsi, 0x35, 0xab);
+	dsi_dcs_write_seq(dsi, 0x36, 0x01);
+	dsi_dcs_write_seq(dsi, 0x37, 0x23);
+	dsi_dcs_write_seq(dsi, 0x38, 0x45);
+	dsi_dcs_write_seq(dsi, 0x39, 0x67);
+	dsi_dcs_write_seq(dsi, 0x3a, 0x89);
+	dsi_dcs_write_seq(dsi, 0x3b, 0xab);
+	dsi_dcs_write_seq(dsi, 0x3c, 0xcd);
+	dsi_dcs_write_seq(dsi, 0x3d, 0xef);
+	dsi_dcs_write_seq(dsi, 0x50, 0x11);
+	dsi_dcs_write_seq(dsi, 0x51, 0x06);
+	dsi_dcs_write_seq(dsi, 0x52, 0x0c);
+	dsi_dcs_write_seq(dsi, 0x53, 0x0d);
+	dsi_dcs_write_seq(dsi, 0x54, 0x0e);
+	dsi_dcs_write_seq(dsi, 0x55, 0x0f);
+	dsi_dcs_write_seq(dsi, 0x56, 0x02);
+	dsi_dcs_write_seq(dsi, 0x57, 0x02);
+	dsi_dcs_write_seq(dsi, 0x58, 0x02);
+	dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5a, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5b, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5c, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5d, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5e, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5f, 0x02);
+	dsi_dcs_write_seq(dsi, 0x60, 0x05);
+	dsi_dcs_write_seq(dsi, 0x61, 0x05);
+	dsi_dcs_write_seq(dsi, 0x62, 0x05);
+	dsi_dcs_write_seq(dsi, 0x63, 0x02);
+	dsi_dcs_write_seq(dsi, 0x64, 0x01);
+	dsi_dcs_write_seq(dsi, 0x65, 0x00);
+	dsi_dcs_write_seq(dsi, 0x66, 0x08);
+	dsi_dcs_write_seq(dsi, 0x67, 0x08);
+	dsi_dcs_write_seq(dsi, 0x68, 0x0c);
+	dsi_dcs_write_seq(dsi, 0x69, 0x0d);
+	dsi_dcs_write_seq(dsi, 0x6a, 0x0e);
+	dsi_dcs_write_seq(dsi, 0x6b, 0x0f);
+	dsi_dcs_write_seq(dsi, 0x6c, 0x02);
+	dsi_dcs_write_seq(dsi, 0x6d, 0x02);
+	dsi_dcs_write_seq(dsi, 0x6e, 0x02);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0x70, 0x02);
+	dsi_dcs_write_seq(dsi, 0x71, 0x02);
+	dsi_dcs_write_seq(dsi, 0x72, 0x02);
+	dsi_dcs_write_seq(dsi, 0x73, 0x02);
+	dsi_dcs_write_seq(dsi, 0x74, 0x02);
+	dsi_dcs_write_seq(dsi, 0x75, 0x02);
+	dsi_dcs_write_seq(dsi, 0x76, 0x05);
+	dsi_dcs_write_seq(dsi, 0x77, 0x05);
+	dsi_dcs_write_seq(dsi, 0x78, 0x05);
+	dsi_dcs_write_seq(dsi, 0x79, 0x02);
+	dsi_dcs_write_seq(dsi, 0x7a, 0x01);
+	dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	dsi_dcs_write_seq(dsi, 0x7c, 0x06);
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x08);
+	dsi_dcs_write_seq(dsi, 0x76, 0xb4);
+	dsi_dcs_write_seq(dsi, 0x78, 0x02);
+	dsi_dcs_write_seq(dsi, 0x74, 0x2b);
+	dsi_dcs_write_seq(dsi, 0x8e, 0x15);
+	dsi_dcs_write_seq(dsi, 0x40, 0x01);
+	dsi_dcs_write_seq(dsi, 0x7b, 0x04);
+	dsi_dcs_write_seq(dsi, 0x72, 0x25);
+	dsi_dcs_write_seq(dsi, 0x87, 0x3a);
+	dsi_dcs_write_seq(dsi, 0x7e, 0x4c);
+	dsi_dcs_write_seq(dsi, 0x6c, 0x05);
+	dsi_dcs_write_seq(dsi, 0x49, 0x10);
+	dsi_dcs_write_seq(dsi, 0x2d, 0x80);
+	dsi_dcs_write_seq(dsi, 0x50, 0x65);
+	dsi_dcs_write_seq(dsi, 0x53, 0x29);
+	dsi_dcs_write_seq(dsi, 0x54, 0x65);
+	dsi_dcs_write_seq(dsi, 0x55, 0x38);
+	dsi_dcs_write_seq(dsi, 0x57, 0x47);
+	dsi_dcs_write_seq(dsi, 0x58, 0x47);
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	dsi_dcs_write_seq(dsi, 0x22, 0x0a);
+	dsi_dcs_write_seq(dsi, 0x53, 0x91);
+	dsi_dcs_write_seq(dsi, 0x55, 0x78);
+	dsi_dcs_write_seq(dsi, 0x50, 0xa5);
+	dsi_dcs_write_seq(dsi, 0x51, 0xa2);
+	dsi_dcs_write_seq(dsi, 0x31, 0x00);
+	dsi_dcs_write_seq(dsi, 0xa0, 0x0a);
+	dsi_dcs_write_seq(dsi, 0xa1, 0x1f);
+	dsi_dcs_write_seq(dsi, 0xa2, 0x2e);
+	dsi_dcs_write_seq(dsi, 0xa3, 0x16);
+	dsi_dcs_write_seq(dsi, 0xa4, 0x1b);
+	dsi_dcs_write_seq(dsi, 0xa5, 0x27);
+	dsi_dcs_write_seq(dsi, 0xa6, 0x1f);
+	dsi_dcs_write_seq(dsi, 0xa7, 0x1e);
+	dsi_dcs_write_seq(dsi, 0xa8, 0x94);
+	dsi_dcs_write_seq(dsi, 0xa9, 0x1e);
+	dsi_dcs_write_seq(dsi, 0xaa, 0x2b);
+	dsi_dcs_write_seq(dsi, 0xab, 0x93);
+	dsi_dcs_write_seq(dsi, 0xac, 0x1e);
+	dsi_dcs_write_seq(dsi, 0xad, 0x1d);
+	dsi_dcs_write_seq(dsi, 0xae, 0x53);
+	dsi_dcs_write_seq(dsi, 0xaf, 0x26);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x2d);
+	dsi_dcs_write_seq(dsi, 0xb1, 0x55);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x68);
+	dsi_dcs_write_seq(dsi, 0xb3, 0x3f);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x01);
+	dsi_dcs_write_seq(dsi, 0xc1, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xc2, 0x19);
+	dsi_dcs_write_seq(dsi, 0xc3, 0x16);
+	dsi_dcs_write_seq(dsi, 0xc4, 0x14);
+	dsi_dcs_write_seq(dsi, 0xc5, 0x25);
+	dsi_dcs_write_seq(dsi, 0xc6, 0x15);
+	dsi_dcs_write_seq(dsi, 0xc7, 0x1c);
+	dsi_dcs_write_seq(dsi, 0xc8, 0x78);
+	dsi_dcs_write_seq(dsi, 0xc9, 0x1d);
+	dsi_dcs_write_seq(dsi, 0xca, 0x28);
+	dsi_dcs_write_seq(dsi, 0xcb, 0x6a);
+	dsi_dcs_write_seq(dsi, 0xcc, 0x1c);
+	dsi_dcs_write_seq(dsi, 0xcd, 0x1a);
+	dsi_dcs_write_seq(dsi, 0xce, 0x4c);
+	dsi_dcs_write_seq(dsi, 0xcf, 0x1f);
+	dsi_dcs_write_seq(dsi, 0xd0, 0x25);
+	dsi_dcs_write_seq(dsi, 0xd1, 0x54);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x62);
+	dsi_dcs_write_seq(dsi, 0xd3, 0x3f);
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x06);
+	dsi_dcs_write_seq(dsi, 0x1b, 0x02);
+	dsi_dcs_write_seq(dsi, 0x5a, 0x03);
+	dsi_dcs_write_seq(dsi, 0x1a, 0x06);
+	dsi_dcs_write_seq(dsi, 0x20, 0x09);
+	dsi_dcs_write_seq(dsi, 0x21, 0x0c);
+	dsi_dcs_write_seq(dsi, 0x22, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+	dsi_dcs_write_seq(dsi, 0x55, 0x80);
+	// WARNING: Ignoring weird SET_MAXIMUM_RETURN_PACKET_SIZE
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int ili9881_off(struct ili9881 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int ili9881_prepare(struct drm_panel *panel)
+{
+	struct ili9881 *ctx = to_ili9881(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ili9881_reset(ctx);
+
+	ret = ili9881_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int ili9881_unprepare(struct drm_panel *panel)
+{
+	struct ili9881 *ctx = to_ili9881(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = ili9881_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ili9881_mode = {
+	.clock = (720 + 168 + 24 + 240) * (1280 + 12 + 4 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 168,
+	.hsync_end = 720 + 168 + 24,
+	.htotal = 720 + 168 + 24 + 240,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 4,
+	.vtotal = 1280 + 12 + 4 + 20,
+	.width_mm = 59,
+	.height_mm = 104,
+};
+
+static int ili9881_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ili9881_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ili9881_panel_funcs = {
+	.prepare = ili9881_prepare,
+	.unprepare = ili9881_unprepare,
+	.get_modes = ili9881_get_modes,
+};
+
+static int ili9881_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ili9881 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &ili9881_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ili9881_remove(struct mipi_dsi_device *dsi)
+{
+	struct ili9881 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id ili9881_of_match[] = {
+	{ .compatible = "wingtech,yassy-ili9881" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili9881_of_match);
+
+static struct mipi_dsi_driver ili9881_driver = {
+	.probe = ili9881_probe,
+	.remove = ili9881_remove,
+	.driver = {
+		.name = "panel-ili9881",
+		.of_match_table = ili9881_of_match,
+	},
+};
+module_mipi_dsi_driver(ili9881_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ili9881_HD720p_video_Yassy");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index fb785f5a106..f0837c6a386 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -4960,6 +4960,36 @@ struct panel_desc_dsi {
 	unsigned int lanes;
 };
 
+static const struct drm_display_mode s6e8aa5x01_ams497hy01_mode = {
+	.clock = (720 + 226 + 20 + 100) * (1280 + 14 + 2 + 8) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 226,
+	.hsync_end = 720 + 226 + 20,
+	.htotal = 720 + 226 + 20 + 100,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 14,
+	.vsync_end = 1280 + 14 + 2,
+	.vtotal = 1280 + 14 + 2 + 8,
+	.width_mm = 62,
+	.height_mm = 106,
+};
+
+static const struct panel_desc_dsi samsung_s6e8aa5x01_ams497hy01 = {
+	.desc = {
+		.modes = &s6e8aa5x01_ams497hy01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 62,
+			.height = 106,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct drm_display_mode auo_b080uan01_mode = {
 	.clock = 154500,
 	.hdisplay = 1200,
@@ -5018,6 +5048,38 @@ static const struct panel_desc_dsi boe_tv080wum_nl0 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode lg_c50_panel_mode = {
+	.clock = (480 + 24 + 8 + 88) * (854 + 1070 + 4 + 12) * 60 / 1000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 24,
+	.hsync_end = 480 + 24 + 8,
+	.htotal = 480 + 24 + 8 + 88,
+	.vdisplay = 854,
+	.vsync_start = 854 + 1070,
+	.vsync_end = 854 + 1070 + 4,
+	.vtotal = 854 + 1070 + 4 + 12,
+	.width_mm = 55,
+	.height_mm = 99,
+};
+
+static const struct panel_desc_dsi lg_c50_panel = {
+	.desc = {
+		.modes = &lg_c50_panel_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 55,
+			.height = 99,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_NO_EOT_PACKET |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 2,
+};
+
+
 static const struct drm_display_mode lg_ld070wx3_sl01_mode = {
 	.clock = 71000,
 	.hdisplay = 800,
@@ -5074,6 +5136,36 @@ static const struct panel_desc_dsi lg_lh500wx1_sd03 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode lgd_incell_m2db7400_mode = {
+	.clock = (720 + 82 + 4 + 120) * (1280 + 540 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 82,
+	.hsync_end = 720 + 82 + 4,
+	.htotal = 720 + 82 + 4 + 120,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 540,
+	.vsync_end = 1280 + 540 + 1,
+	.vtotal = 1280 + 540 + 1 + 11,
+	.width_mm = 66,
+	.height_mm = 117,
+};
+
+static const struct panel_desc_dsi lgd_incell_m2db7400 = {
+	.desc = {
+		.modes = &lgd_incell_m2db7400_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 66,
+			.height = 117,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_NO_EOT_PACKET,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct drm_display_mode panasonic_vvx10f004b00_mode = {
 	.clock = 157200,
 	.hdisplay = 1920,
@@ -5169,12 +5261,21 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "boe,tv080wum-nl0",
 		.data = &boe_tv080wum_nl0
+	}, {
+		.compatible = "samsung,s6e8aa5x01-ams497hy01",
+		.data = &samsung_s6e8aa5x01_ams497hy01,
+	}, {
+		.compatible = "lg,c50-panel",
+		.data = &lg_c50_panel
 	}, {
 		.compatible = "lg,ld070wx3-sl01",
 		.data = &lg_ld070wx3_sl01
 	}, {
 		.compatible = "lg,lh500wx1-sd03",
 		.data = &lg_lh500wx1_sd03
+	}, {
+		.compatible = "lg,m2db7400-incell-simple",
+		.data = &lgd_incell_m2db7400
 	}, {
 		.compatible = "panasonic,vvx10f004b00",
 		.data = &panasonic_vvx10f004b00
diff --git a/drivers/iio/light/ltr501.c b/drivers/iio/light/ltr501.c
index f0bd0ad34f2..b2983b1a9ed 100644
--- a/drivers/iio/light/ltr501.c
+++ b/drivers/iio/light/ltr501.c
@@ -15,6 +15,7 @@
 #include <linux/delay.h>
 #include <linux/regmap.h>
 #include <linux/acpi.h>
+#include <linux/regulator/consumer.h>
 
 #include <linux/iio/iio.h>
 #include <linux/iio/events.h>
@@ -151,6 +152,7 @@ struct ltr501_chip_info {
 
 struct ltr501_data {
 	struct i2c_client *client;
+	struct regulator_bulk_data regulators[2];
 	struct mutex lock_als, lock_ps;
 	const struct ltr501_chip_info *chip_info;
 	u8 als_contr, ps_contr;
@@ -1379,6 +1381,13 @@ static const struct regmap_config ltr501_regmap_config = {
 	.volatile_reg = ltr501_is_volatile_reg,
 };
 
+static void ltr501_disable_regulators(void *d)
+{
+	struct ltr501_data *data = d;
+
+	regulator_bulk_disable(ARRAY_SIZE(data->regulators), data->regulators);
+}
+
 static int ltr501_powerdown(struct ltr501_data *data)
 {
 	return ltr501_write_contr(data, data->als_contr &
@@ -1423,6 +1432,25 @@ static int ltr501_probe(struct i2c_client *client,
 	mutex_init(&data->lock_als);
 	mutex_init(&data->lock_ps);
 
+	data->regulators[0].supply = "vdd";
+	data->regulators[1].supply = "vddio";
+	ret = devm_regulator_bulk_get(&client->dev,
+				      ARRAY_SIZE(data->regulators),
+				      data->regulators);
+	if (ret)
+		return dev_err_probe(&client->dev, ret,
+				     "Failed to get regulators\n");
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(data->regulators),
+				    data->regulators);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action_or_reset(&client->dev,
+				       ltr501_disable_regulators, data);
+	if (ret)
+		return ret;
+
 	data->reg_it = devm_regmap_field_alloc(&client->dev, regmap,
 					       reg_field_it);
 	if (IS_ERR(data->reg_it)) {
@@ -1581,9 +1609,18 @@ static const struct i2c_device_id ltr501_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ltr501_id);
 
+static const struct of_device_id ltr501_of_match[] = {
+	{ .compatible = "liteon,ltr501", },
+	{ .compatible = "liteon,ltr559", },
+	{ .compatible = "liteon,ltr301", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ltr501_of_match);
+
 static struct i2c_driver ltr501_driver = {
 	.driver = {
 		.name   = LTR501_DRV_NAME,
+		.of_match_table = ltr501_of_match,
 		.pm	= &ltr501_pm_ops,
 		.acpi_match_table = ACPI_PTR(ltr_acpi_match),
 	},
diff --git a/drivers/input/keyboard/tm2-touchkey.c b/drivers/input/keyboard/tm2-touchkey.c
index 6218b1c682e..632cd6c1c8d 100644
--- a/drivers/input/keyboard/tm2-touchkey.c
+++ b/drivers/input/keyboard/tm2-touchkey.c
@@ -156,6 +156,8 @@ static irqreturn_t tm2_touchkey_irq_handler(int irq, void *devid)
 		goto out;
 	}
 
+	input_event(touchkey->input_dev, EV_MSC, MSC_SCAN, index);
+
 	if (data & TM2_TOUCHKEY_BIT_PRESS_EV) {
 		for (i = 0; i < touchkey->num_keycodes; i++)
 			input_report_key(touchkey->input_dev,
@@ -250,6 +252,11 @@ static int tm2_touchkey_probe(struct i2c_client *client,
 	touchkey->input_dev->name = TM2_TOUCHKEY_DEV_NAME;
 	touchkey->input_dev->id.bustype = BUS_I2C;
 
+	touchkey->input_dev->keycode = touchkey->keycodes;
+	touchkey->input_dev->keycodemax = touchkey->num_keycodes;
+	touchkey->input_dev->keycodesize = sizeof(touchkey->keycodes[0]);
+
+	input_set_capability(touchkey->input_dev, EV_MSC, MSC_SCAN);
 	for (i = 0; i < touchkey->num_keycodes; i++)
 		input_set_capability(touchkey->input_dev, EV_KEY,
 				     touchkey->keycodes[i]);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d4e74738c5a..0f86e248b36 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1366,4 +1366,13 @@ config TOUCHSCREEN_ZINITIX
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_HIMAX852X
+	tristate "Himax touchscreens"
+	depends on I2C
+	help
+		Say Y here if you have a Himax 852xES touchscreen.
+		If unsure, say N.
+		To compile this driver as a module, choose M here: the
+		module will be called himax_852xES.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 7d34100f7f2..847bceb11e5 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_HIMAX852X)	+= himax_852xES.o
diff --git a/drivers/input/touchscreen/himax_852xES.c b/drivers/input/touchscreen/himax_852xES.c
new file mode 100644
index 00000000000..94d66a3d12f
--- /dev/null
+++ b/drivers/input/touchscreen/himax_852xES.c
@@ -0,0 +1,601 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for HMX852xES chipset
+ *
+ * Mainly inspired by Melfas MMS114/MMS152 touchscreen device driver
+ * Copyright (c) 2012 Samsung Electronics Co., Ltd.
+ * Author: Joonyoung Shim <jy0922.shim@samsung.com>
+ *
+ * Based on the Himax Android Driver Sample Code Ver 0.3 for HMX852xES chipset:
+ * Copyright (c) 2014 Himax Corporation.
+ */
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+
+#define HX852_COORD_SIZE(fingers)	((fingers) * sizeof(struct hx852_coord))
+#define HX852_WIDTH_SIZE(fingers)	ALIGN(fingers, 4)
+#define HX852_BUF_SIZE(fingers)		(HX852_COORD_SIZE(fingers) + \
+					HX852_WIDTH_SIZE(fingers) + \
+					sizeof(struct hx852_touch_info))
+
+#define HX852_MAX_FINGERS		12
+#define HX852_MAX_KEY_COUNT		3
+#define HX852_MAX_BUF_SIZE		HX852_BUF_SIZE(HX852_MAX_FINGERS)
+
+#define HX852_SLEEP_MODE_ON		0x80
+#define HX852_SLEEP_MODE_OFF		0x81
+#define HX852_TOUCH_EVENTS_OFF		0x82
+#define HX852_TOUCH_EVENTS_ON		0x83
+#define HX852_READ_ALL_EVENTS		0x86
+
+#define HX852_REG_SRAM_SWITCH		0x8C
+#define HX852_REG_SRAM_ADDR		0x8B
+#define HX852_REG_FLASH_RPLACE		0x5A
+
+#define HX852_ENTER_TEST_MODE_SEQ	{HX852_REG_SRAM_SWITCH, 0x14}
+#define HX852_LEAVE_TEST_MODE_SEQ	{HX852_REG_SRAM_SWITCH, 0x00}
+#define HX852_GET_CONFIG_SEQ		{HX852_REG_SRAM_ADDR, 0x00, 0x70}
+
+#define ABS_PRESSURE_MIN		0
+#define ABS_PRESSURE_MAX		200
+#define ABS_WIDTH_MIN			0
+#define ABS_WIDTH_MAX			200
+
+struct hx852_data {
+	struct touchscreen_properties props;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data supplies[2];
+
+	int max_fingers;
+
+	bool had_finger_pressed;
+	u8 last_key;
+
+	int keycount;
+	u32 keycodes[HX852_MAX_KEY_COUNT];
+};
+
+struct hx852_config {
+	u8 rx_num;
+	u8 tx_num;
+	u8 max_pt;
+	u8 padding1[3];
+	u8 x_res[2];
+	u8 y_res[2];
+	u8 padding2[2];
+};
+
+struct hx852_command {
+	u8 data[3];
+	u8 len;
+	u8 sleep;
+};
+
+struct hx852_coord {
+	u8 x[2];
+	u8 y[2];
+};
+
+struct hx852_touch_info {
+	u8 finger_num;
+	u8 finger_pressed[2];
+	u8 padding;
+};
+
+static const u8 hx852_internal_keymappings[HX852_MAX_KEY_COUNT] = {0x01, 0x02, 0x04};
+
+static int hx852_i2c_read(struct hx852_data *ts, uint8_t command, uint8_t *data,
+			  uint8_t length)
+{
+	struct i2c_client *client = ts->client;
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &command,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = data,
+		}
+	};
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(&client->dev, "failed to read command %#x: %d\n",
+			command, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx852_i2c_write(struct hx852_data *ts, struct hx852_command *cmds,
+			   unsigned int ncmds)
+{
+	struct i2c_client *client = ts->client;
+	int ret;
+	int i;
+
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = 0,
+	};
+
+	for (i = 0; i < ncmds; i++) {
+		msg.len = cmds[i].len;
+		msg.buf = cmds[i].data;
+
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret != 1) {
+			dev_err(&client->dev,
+				"failed to write command %d (%#x): %d\n", i,
+				cmds[i].data[0], ret);
+			return ret;
+		}
+
+		msleep(cmds[i].sleep);
+	}
+
+	return 0;
+}
+
+static int hx852_read_config(struct hx852_data *ts)
+{
+	struct hx852_config conf;
+	int x_max, y_max;
+	int error;
+
+	struct hx852_command pre_read_msg_seq[] = {
+		{ .data = HX852_ENTER_TEST_MODE_SEQ, .len = 2, .sleep = 10 },
+		{ .data = HX852_GET_CONFIG_SEQ, .len = 3, .sleep = 10 },
+	};
+
+	struct hx852_command post_read_msg_seq[] = {
+		{ .data = HX852_LEAVE_TEST_MODE_SEQ, .len = 2, .sleep = 10 },
+	};
+
+	error = hx852_i2c_write(ts, pre_read_msg_seq,
+				ARRAY_SIZE(pre_read_msg_seq));
+	if (error)
+		return error;
+
+	error = hx852_i2c_read(ts, HX852_REG_FLASH_RPLACE,
+			       (u8 *)&conf, sizeof(conf));
+	if (error)
+		return error;
+
+	error = hx852_i2c_write(ts, post_read_msg_seq,
+				ARRAY_SIZE(post_read_msg_seq));
+	if (error)
+		return error;
+
+	ts->max_fingers = (conf.max_pt & 0xF0) >> 4;
+	if (ts->max_fingers > HX852_MAX_FINGERS) {
+		dev_err(&ts->client->dev,
+			"max supported fingers: %d, yours: %d\n",
+			HX852_MAX_FINGERS, ts->max_fingers);
+		return -EINVAL;
+	}
+
+	x_max = get_unaligned_be16(conf.x_res) - 1;
+	y_max = get_unaligned_be16(conf.y_res) - 1;
+
+	if (x_max && y_max) {
+		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
+				     0, x_max, 0, 0);
+		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
+				     0, y_max, 0, 0);
+	}
+
+	return 0;
+}
+
+static int hx852_power_on(struct hx852_data *ts)
+{
+	struct i2c_client *client = ts->client;
+	int error;
+
+	struct hx852_command ts_resume_cmd_seq[] = {
+		{ .data = { HX852_TOUCH_EVENTS_ON }, .len = 1, .sleep = 30 },
+		{ .data = { HX852_SLEEP_MODE_OFF }, .len = 1, .sleep = 50 },
+	};
+
+	error = regulator_bulk_enable(ARRAY_SIZE(ts->supplies), ts->supplies);
+	if (error < 0) {
+		dev_err(&client->dev,
+			"Failed to enable regulators: %d\n", error);
+		return error;
+	}
+
+	gpiod_set_value_cansleep(ts->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ts->reset_gpio, 1);
+
+	msleep(50);
+	error = hx852_i2c_write(ts, ts_resume_cmd_seq,
+				ARRAY_SIZE(ts_resume_cmd_seq));
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int hx852_init(struct hx852_data *ts)
+{
+	int error;
+
+	struct hx852_command pre_conf_cmd_seq[] = {
+		{ .data = { HX852_TOUCH_EVENTS_OFF }, .len = 1, .sleep = 50 },
+		{ .data = { HX852_SLEEP_MODE_ON }, .len = 1, .sleep = 0 },
+	};
+
+	error = hx852_power_on(ts);
+	if (error)
+		return error;
+
+	error = hx852_i2c_write(ts, pre_conf_cmd_seq,
+				ARRAY_SIZE(pre_conf_cmd_seq));
+	if (error)
+		return error;
+
+	error = hx852_read_config(ts);
+	if (error)
+		return error;
+
+	error = regulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);
+	if (error)
+		dev_warn(&ts->client->dev,
+			 "failed to disable regulators: %d\n", error);
+
+	return 0;
+}
+
+static void hx852_process_btn_touch(struct hx852_data *ts, int current_key)
+{
+	int i;
+
+	for (i = 0; i < ts->keycount; i++) {
+		if (hx852_internal_keymappings[i] == current_key)
+			input_report_key(ts->input_dev, ts->keycodes[i], 1);
+		else if (hx852_internal_keymappings[i] == ts->last_key)
+			input_report_key(ts->input_dev, ts->keycodes[i], 0);
+	}
+
+	ts->last_key = current_key;
+}
+
+static void hx852_process_display_touch(struct hx852_data *ts,
+					struct hx852_coord *coord,
+					u8 *width, u16 finger_pressed)
+{
+	unsigned int x, y, w;
+	int i;
+
+	ts->had_finger_pressed = false;
+
+	for (i = 0; i < ts->max_fingers; i++) {
+		if (!(finger_pressed & BIT(i)))
+			continue;
+
+		x = get_unaligned_be16(coord[i].x);
+		y = get_unaligned_be16(coord[i].y);
+		w = width[i];
+
+		input_mt_slot(ts->input_dev, i);
+		input_mt_report_slot_state(ts->input_dev,
+					   MT_TOOL_FINGER, 1);
+
+		touchscreen_report_pos(ts->input_dev, &ts->props, x, y,
+				       true);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
+		ts->had_finger_pressed = true;
+	}
+
+	input_mt_sync_frame(ts->input_dev);
+}
+
+static irqreturn_t hx852_interrupt(int irq, void *ptr)
+{
+	struct hx852_data *ts = ptr;
+	struct input_dev *input_dev = ts->input_dev;
+
+	u8 buf[HX852_MAX_BUF_SIZE];
+	u8 current_key;
+	u16 finger_pressed;
+	int error;
+
+	struct hx852_coord *coord = (struct hx852_coord *)buf;
+	u8 *width = &buf[HX852_COORD_SIZE(ts->max_fingers)];
+	struct hx852_touch_info *info = (struct hx852_touch_info *)
+		&width[HX852_WIDTH_SIZE(ts->max_fingers)];
+
+	mutex_lock(&input_dev->mutex);
+	if (!input_dev->users) {
+		mutex_unlock(&input_dev->mutex);
+		return IRQ_HANDLED;
+	}
+	mutex_unlock(&input_dev->mutex);
+
+	error = hx852_i2c_read(ts, HX852_READ_ALL_EVENTS, buf,
+			       HX852_BUF_SIZE(ts->max_fingers));
+	if (error)
+		return IRQ_HANDLED;
+
+	finger_pressed = get_unaligned_le16(info->finger_pressed);
+
+	current_key = finger_pressed >> HX852_MAX_FINGERS;
+	if (current_key == 0x0F)
+		current_key = 0x00;
+
+	if (info->finger_num == 0xff || !(info->finger_num & 0x0f))
+		finger_pressed = 0;
+
+	if (finger_pressed || ts->had_finger_pressed)
+		hx852_process_display_touch(ts, coord, width, finger_pressed);
+	else if (ts->keycount && (current_key || ts->last_key))
+		hx852_process_btn_touch(ts, current_key);
+
+	input_sync(ts->input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int hx852_start(struct hx852_data *ts)
+{
+	struct i2c_client *client = ts->client;
+	int error;
+
+	error = hx852_power_on(ts);
+	if (error)
+		return error;
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static void hx852_stop(struct hx852_data *ts)
+{
+	struct i2c_client *client = ts->client;
+	int error;
+
+	struct hx852_command ts_sleep_cmd_seq[] = {
+		{ .data = { HX852_TOUCH_EVENTS_OFF }, .len = 1, .sleep = 40 },
+		{ .data = { HX852_SLEEP_MODE_ON }, .len = 1, .sleep = 50 },
+	};
+
+	disable_irq(client->irq);
+
+	hx852_i2c_write(ts, ts_sleep_cmd_seq, ARRAY_SIZE(ts_sleep_cmd_seq));
+
+	error = regulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);
+	if (error)
+		dev_warn(&client->dev,
+			 "failed to disable regulators: %d\n", error);
+}
+
+static int hx852_input_open(struct input_dev *dev)
+{
+	struct hx852_data *ts = input_get_drvdata(dev);
+
+	return hx852_start(ts);
+}
+
+static void hx852_input_close(struct input_dev *dev)
+{
+	struct hx852_data *ts = input_get_drvdata(dev);
+
+	hx852_stop(ts);
+}
+
+static int hx852_parse_properties(struct hx852_data *ts)
+{
+	struct device *dev = &ts->client->dev;
+	int error = 0;
+
+	ts->keycount = device_property_count_u32(dev, "linux,keycodes");
+
+	if (ts->keycount <= 0) {
+		ts->keycount = 0;
+		return 0;
+	}
+
+	if (ts->keycount > HX852_MAX_KEY_COUNT) {
+		dev_err(dev, "max supported keys: %d, yours: %d\n",
+			HX852_MAX_KEY_COUNT, ts->keycount);
+		return -EINVAL;
+	}
+
+	error = device_property_read_u32_array(dev, "linux,keycodes",
+					       ts->keycodes, ts->keycount);
+	if (error)
+		dev_err(dev,
+			"failed to read linux,keycodes property: %d\n", error);
+
+	return error;
+}
+
+static int hx852_probe(struct i2c_client *client)
+{
+	struct hx852_data *ts;
+	struct input_dev *input_dev;
+	int i;
+	int error;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+			"plain i2c-level commands not supported\n");
+		return -ENODEV;
+	}
+
+	ts = devm_kzalloc(&client->dev, sizeof(struct hx852_data), GFP_KERNEL);
+	input_dev = devm_input_allocate_device(&client->dev);
+	if (!ts || !input_dev) {
+		dev_err(&client->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	ts->client = client;
+	ts->input_dev = input_dev;
+
+	ts->supplies[0].supply = "vcca";
+	ts->supplies[1].supply = "vccd";
+	error = devm_regulator_bulk_get(&client->dev,
+					ARRAY_SIZE(ts->supplies), ts->supplies);
+	if (error < 0) {
+		dev_err(&client->dev, "Failed to get regulators: %d\n", error);
+		return error;
+	}
+
+	ts->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
+						 GPIOD_OUT_LOW);
+	if (IS_ERR(ts->reset_gpio)) {
+		error = PTR_ERR(ts->reset_gpio);
+		dev_err(&client->dev, "failed to get reset gpio: %d\n", error);
+		return error;
+	}
+
+	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);
+	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);
+
+	error = hx852_init(ts);
+	if (error)
+		return error;
+
+	touchscreen_parse_properties(input_dev, true, &ts->props);
+	error = hx852_parse_properties(ts);
+	if (error)
+		return error;
+
+	error = input_mt_init_slots(input_dev, ts->max_fingers,
+				    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (error)
+		return error;
+
+	for (i = 0; i < ts->keycount; i++)
+		input_set_capability(ts->input_dev, EV_KEY, ts->keycodes[i]);
+
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	input_dev->name = "himax-touchscreen";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &client->dev;
+	input_dev->open = hx852_input_open;
+	input_dev->close = hx852_input_close;
+
+	input_set_drvdata(input_dev, ts);
+	i2c_set_clientdata(client, ts);
+
+	if (!client->irq) {
+		dev_err(&client->dev, "client->irq not found\n");
+		return -EINVAL;
+	}
+
+	error = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+					  hx852_interrupt, IRQF_ONESHOT,
+					  NULL, ts);
+	if (error) {
+		dev_err(&client->dev, "request irq %d failed\n",
+			client->irq);
+		return error;
+	}
+
+	disable_irq(client->irq);
+
+	error = input_register_device(ts->input_dev);
+	if (error) {
+		dev_err(&client->dev, "failed to register input device\n");
+		return error;
+	}
+
+	return 0;
+}
+
+static int __maybe_unused hx852_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct hx852_data *ts = i2c_get_clientdata(client);
+	struct input_dev *input_dev = ts->input_dev;
+	int i;
+
+	mutex_lock(&input_dev->mutex);
+	if (input_dev->users)
+		hx852_stop(ts);
+	mutex_unlock(&input_dev->mutex);
+
+	if (ts->had_finger_pressed)
+		input_mt_sync_frame(input_dev);
+
+	if (ts->last_key) {
+		for (i = 0; i < ts->keycount; i++) {
+			if (hx852_internal_keymappings[i] == ts->last_key)
+				input_report_key(ts->input_dev,
+						 ts->keycodes[i], 0);
+		}
+	}
+
+	if (ts->had_finger_pressed || ts->last_key)
+		input_sync(input_dev);
+
+	ts->last_key = 0;
+	ts->had_finger_pressed = false;
+
+	return 0;
+}
+
+static int __maybe_unused hx852_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct hx852_data *ts = i2c_get_clientdata(client);
+	struct input_dev *input_dev = ts->input_dev;
+	int error = 0;
+
+	mutex_lock(&input_dev->mutex);
+	if (input_dev->users)
+		error = hx852_start(ts);
+	mutex_unlock(&input_dev->mutex);
+
+	return error;
+}
+
+static SIMPLE_DEV_PM_OPS(hx852_pm_ops, hx852_suspend, hx852_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id hx852_dt_match[] = {
+	{ .compatible = "himax,852x" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hx852_dt_match);
+#endif
+
+static struct i2c_driver hx852_driver = {
+	.driver = {
+		.name = "Himax852xes",
+		.pm = &hx852_pm_ops,
+		.of_match_table = of_match_ptr(hx852_dt_match),
+	},
+	.probe_new = hx852_probe,
+};
+
+module_i2c_driver(hx852_driver);
+
+MODULE_DESCRIPTION("Driver for HMX852xES chipset");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/msg2638.c b/drivers/input/touchscreen/msg2638.c
index 75536bc8896..36069b30ab9 100644
--- a/drivers/input/touchscreen/msg2638.c
+++ b/drivers/input/touchscreen/msg2638.c
@@ -26,23 +26,43 @@
 
 #define MODE_DATA_RAW			0x5A
 
-#define MAX_SUPPORTED_FINGER_NUM	5
+#define MSG2138_MAX_FINGERS		2
+#define MSG2638_MAX_FINGERS		5
+
+#define MAX_BUTTONS			4
 
 #define CHIP_ON_DELAY_MS		15
 #define FIRMWARE_ON_DELAY_MS		50
 #define RESET_DELAY_MIN_US		10000
 #define RESET_DELAY_MAX_US		11000
 
-struct packet {
+struct msg_chip_data {
+	irq_handler_t irq_handler;
+	unsigned int max_fingers;
+};
+
+struct msg2138_packet {
+	u8	xy_hi; /* higher bits of x and y coordinates */
+	u8	x_low;
+	u8	y_low;
+};
+
+struct msg2138_touch_event {
+	u8	magic;
+	struct	msg2138_packet pkt[MSG2138_MAX_FINGERS];
+	u8	checksum;
+};
+
+struct msg2638_packet {
 	u8	xy_hi; /* higher bits of x and y coordinates */
 	u8	x_low;
 	u8	y_low;
 	u8	pressure;
 };
 
-struct touch_event {
+struct msg2638_touch_event {
 	u8	mode;
-	struct	packet pkt[MAX_SUPPORTED_FINGER_NUM];
+	struct	msg2638_packet pkt[MSG2638_MAX_FINGERS];
 	u8	proximity;
 	u8	checksum;
 };
@@ -53,6 +73,9 @@ struct msg2638_ts_data {
 	struct touchscreen_properties prop;
 	struct regulator_bulk_data supplies[2];
 	struct gpio_desc *reset_gpiod;
+	int max_fingers;
+	u32 keycodes[MAX_BUTTONS];
+	int num_keycodes;
 };
 
 static u8 msg2638_checksum(u8 *data, u32 length)
@@ -66,12 +89,102 @@ static u8 msg2638_checksum(u8 *data, u32 length)
 	return (u8)((-sum) & 0xFF);
 }
 
+static void msg2138_report_keys(struct msg2638_ts_data *msg2638, u8 keys)
+{
+	int i;
+
+	/* keys can be 0x00 or 0xff when all keys have been released */
+	if (keys == 0xff)
+		keys = 0;
+
+	for (i = 0; i < msg2638->num_keycodes; ++i)
+		input_report_key(msg2638->input_dev, msg2638->keycodes[i],
+				 !!(keys & BIT(i)));
+}
+
+static irqreturn_t msg2138_ts_irq_handler(int irq, void *msg2638_handler)
+{
+	struct msg2638_ts_data *msg2638 = msg2638_handler;
+	struct i2c_client *client = msg2638->client;
+	struct input_dev *input = msg2638->input_dev;
+	struct msg2138_touch_event touch_event;
+	u32 len = sizeof(touch_event);
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags	= I2C_M_RD,
+			.len	= sizeof(touch_event),
+			.buf	= (u8 *)&touch_event,
+		},
+	};
+	struct msg2138_packet *p0, *p1;
+	u16 x, y, delta_x, delta_y;
+	int ret;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(&client->dev,
+			"Failed I2C transfer in irq handler: %d\n",
+			ret < 0 ? ret : -EIO);
+		goto out;
+	}
+
+	if (msg2638_checksum((u8 *)&touch_event, len - 1) !=
+						touch_event.checksum) {
+		dev_err(&client->dev, "Failed checksum!\n");
+		goto out;
+	}
+
+	p0 = &touch_event.pkt[0];
+	p1 = &touch_event.pkt[1];
+
+	/* Ignore non-pressed finger data, but check for key code */
+	if (p0->xy_hi == 0xFF && p0->x_low == 0xFF && p0->y_low == 0xFF) {
+		if (p1->xy_hi == 0xFF && p1->y_low == 0xFF)
+			msg2138_report_keys(msg2638, p1->x_low);
+		goto report;
+	}
+
+	x = (((p0->xy_hi & 0xF0) << 4) | p0->x_low);
+	y = (((p0->xy_hi & 0x0F) << 8) | p0->y_low);
+
+	input_mt_slot(input, 0);
+	input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	touchscreen_report_pos(input, &msg2638->prop, x, y, true);
+
+	/* Ignore non-pressed finger data */
+	if (p1->xy_hi == 0xFF && p1->x_low == 0xFF && p1->y_low == 0xFF)
+		goto report;
+
+	/* Second finger is reported as a delta position */
+	delta_x = (((p1->xy_hi & 0xF0) << 4) | p1->x_low);
+	delta_y = (((p1->xy_hi & 0x0F) << 8) | p1->y_low);
+
+	/* Ignore second finger if both deltas equal 0 */
+	if (delta_x == 0 && delta_y == 0)
+		goto report;
+
+	x += delta_x;
+	y += delta_y;
+
+	input_mt_slot(input, 1);
+	input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	touchscreen_report_pos(input, &msg2638->prop, x, y, true);
+
+report:
+	input_mt_sync_frame(msg2638->input_dev);
+	input_sync(msg2638->input_dev);
+
+out:
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t msg2638_ts_irq_handler(int irq, void *msg2638_handler)
 {
 	struct msg2638_ts_data *msg2638 = msg2638_handler;
 	struct i2c_client *client = msg2638->client;
 	struct input_dev *input = msg2638->input_dev;
-	struct touch_event touch_event;
+	struct msg2638_touch_event touch_event;
 	u32 len = sizeof(touch_event);
 	struct i2c_msg msg[] = {
 		{
@@ -81,7 +194,7 @@ static irqreturn_t msg2638_ts_irq_handler(int irq, void *msg2638_handler)
 			.buf	= (u8 *)&touch_event,
 		},
 	};
-	struct packet *p;
+	struct msg2638_packet *p;
 	u16 x, y;
 	int ret;
 	int i;
@@ -103,7 +216,7 @@ static irqreturn_t msg2638_ts_irq_handler(int irq, void *msg2638_handler)
 		goto out;
 	}
 
-	for (i = 0; i < MAX_SUPPORTED_FINGER_NUM; i++) {
+	for (i = 0; i < msg2638->max_fingers; i++) {
 		p = &touch_event.pkt[i];
 
 		/* Ignore non-pressed finger data */
@@ -190,6 +303,7 @@ static int msg2638_init_input_dev(struct msg2638_ts_data *msg2638)
 	struct device *dev = &msg2638->client->dev;
 	struct input_dev *input_dev;
 	int error;
+	int i;
 
 	input_dev = devm_input_allocate_device(dev);
 	if (!input_dev) {
@@ -206,6 +320,14 @@ static int msg2638_init_input_dev(struct msg2638_ts_data *msg2638)
 	input_dev->open = msg2638_input_open;
 	input_dev->close = msg2638_input_close;
 
+	if (msg2638->num_keycodes) {
+		input_dev->keycode = msg2638->keycodes;
+		input_dev->keycodemax = msg2638->num_keycodes;
+		input_dev->keycodesize = sizeof(msg2638->keycodes[0]);
+		for (i = 0; i < msg2638->num_keycodes; i++)
+			input_set_capability(input_dev, EV_KEY, msg2638->keycodes[i]);
+	}
+
 	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);
 	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);
 
@@ -215,7 +337,7 @@ static int msg2638_init_input_dev(struct msg2638_ts_data *msg2638)
 		return -EINVAL;
 	}
 
-	error = input_mt_init_slots(input_dev, MAX_SUPPORTED_FINGER_NUM,
+	error = input_mt_init_slots(input_dev, msg2638->max_fingers,
 				    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
 	if (error) {
 		dev_err(dev, "Failed to initialize MT slots: %d\n", error);
@@ -233,6 +355,7 @@ static int msg2638_init_input_dev(struct msg2638_ts_data *msg2638)
 
 static int msg2638_ts_probe(struct i2c_client *client)
 {
+	const struct msg_chip_data *chip_data;
 	struct device *dev = &client->dev;
 	struct msg2638_ts_data *msg2638;
 	int error;
@@ -249,6 +372,14 @@ static int msg2638_ts_probe(struct i2c_client *client)
 	msg2638->client = client;
 	i2c_set_clientdata(client, msg2638);
 
+	chip_data = device_get_match_data(&client->dev);
+	if (!chip_data || !chip_data->max_fingers) {
+		dev_err(dev, "Invalid or missing chip data\n");
+		return -EINVAL;
+	}
+
+	msg2638->max_fingers = chip_data->max_fingers;
+
 	msg2638->supplies[0].supply = "vdd";
 	msg2638->supplies[1].supply = "vddio";
 	error = devm_regulator_bulk_get(dev, ARRAY_SIZE(msg2638->supplies),
@@ -265,14 +396,20 @@ static int msg2638_ts_probe(struct i2c_client *client)
 		return error;
 	}
 
-	error = msg2638_init_input_dev(msg2638);
-	if (error) {
-		dev_err(dev, "Failed to initialize input device: %d\n", error);
-		return error;
+	msg2638->num_keycodes =
+		of_property_read_variable_u32_array(dev->of_node, "linux,keycodes",
+						    msg2638->keycodes, 0,
+						    ARRAY_SIZE(msg2638->keycodes));
+	if (msg2638->num_keycodes == -EINVAL) {
+		msg2638->num_keycodes = 0;
+	} else if (msg2638->num_keycodes < 0) {
+		dev_err(dev, "Unable to parse linux,keycodes property: %d\n",
+			msg2638->num_keycodes);
+		return msg2638->num_keycodes;
 	}
 
 	error = devm_request_threaded_irq(dev, client->irq,
-					  NULL, msg2638_ts_irq_handler,
+					  NULL, chip_data->irq_handler,
 					  IRQF_ONESHOT | IRQF_NO_AUTOEN,
 					  client->name, msg2638);
 	if (error) {
@@ -280,6 +417,12 @@ static int msg2638_ts_probe(struct i2c_client *client)
 		return error;
 	}
 
+	error = msg2638_init_input_dev(msg2638);
+	if (error) {
+		dev_err(dev, "Failed to initialize input device: %d\n", error);
+		return error;
+	}
+
 	return 0;
 }
 
@@ -316,8 +459,19 @@ static int __maybe_unused msg2638_resume(struct device *dev)
 
 static SIMPLE_DEV_PM_OPS(msg2638_pm_ops, msg2638_suspend, msg2638_resume);
 
+static const struct msg_chip_data msg2138_data = {
+	.irq_handler = msg2138_ts_irq_handler,
+	.max_fingers = MSG2138_MAX_FINGERS,
+};
+
+static const struct msg_chip_data msg2638_data = {
+	.irq_handler = msg2638_ts_irq_handler,
+	.max_fingers = MSG2638_MAX_FINGERS,
+};
+
 static const struct of_device_id msg2638_of_match[] = {
-	{ .compatible = "mstar,msg2638" },
+	{ .compatible = "mstar,msg2138", .data = &msg2138_data },
+	{ .compatible = "mstar,msg2638", .data = &msg2638_data },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, msg2638_of_match);
diff --git a/drivers/input/touchscreen/zinitix.c b/drivers/input/touchscreen/zinitix.c
index 400957f4c8c..3cba31c3d39 100644
--- a/drivers/input/touchscreen/zinitix.c
+++ b/drivers/input/touchscreen/zinitix.c
@@ -119,6 +119,7 @@
 
 #define DEFAULT_TOUCH_POINT_MODE		2
 #define MAX_SUPPORTED_FINGER_NUM		5
+#define MAX_SUPPORTED_BUTTON_NUM		8
 
 #define CHIP_ON_DELAY				15 // ms
 #define FIRMWARE_ON_DELAY			40 // ms
@@ -146,6 +147,8 @@ struct bt541_ts_data {
 	struct touchscreen_properties prop;
 	struct regulator_bulk_data supplies[2];
 	u32 zinitix_mode;
+	u32 keycodes[MAX_SUPPORTED_BUTTON_NUM];
+	int num_keycodes;
 };
 
 static int zinitix_read_data(struct i2c_client *client,
@@ -195,6 +198,7 @@ static int zinitix_init_touch(struct bt541_ts_data *bt541)
 	struct i2c_client *client = bt541->client;
 	int i;
 	int error;
+	u16 int_flags = 0;
 
 	error = zinitix_write_cmd(client, BT541_SWRESET_CMD);
 	if (error) {
@@ -225,6 +229,11 @@ static int zinitix_init_touch(struct bt541_ts_data *bt541)
 	if (error)
 		return error;
 
+	error = zinitix_write_u16(client, BT541_BUTTON_SUPPORTED_NUM,
+				  bt541->num_keycodes);
+	if (error)
+		return error;
+
 	error = zinitix_write_u16(client, BT541_INITIAL_TOUCH_MODE,
 				  bt541->zinitix_mode);
 	if (error)
@@ -235,9 +244,12 @@ static int zinitix_init_touch(struct bt541_ts_data *bt541)
 	if (error)
 		return error;
 
-	error = zinitix_write_u16(client, BT541_INT_ENABLE_FLAG,
-				  BIT_PT_CNT_CHANGE | BIT_DOWN | BIT_MOVE |
-					BIT_UP);
+	int_flags = BIT_PT_CNT_CHANGE | BIT_DOWN | BIT_MOVE | BIT_UP;
+
+	if (bt541->num_keycodes)
+		int_flags |= BIT_ICON_EVENT;
+
+	error = zinitix_write_u16(client, BT541_INT_ENABLE_FLAG, int_flags);
 	if (error)
 		return error;
 
@@ -339,6 +351,15 @@ static void zinitix_report_finger(struct bt541_ts_data *bt541, int slot,
 	}
 }
 
+static void zinitix_report_keys(struct bt541_ts_data *bt541, __le16 icon_events)
+{
+	int i;
+
+	for (i = 0; i < bt541->num_keycodes; i++)
+		input_report_key(bt541->input_dev,
+				 bt541->keycodes[i], !!(icon_events & BIT(i)));
+}
+
 static irqreturn_t zinitix_ts_irq_handler(int irq, void *bt541_handler)
 {
 	struct bt541_ts_data *bt541 = bt541_handler;
@@ -347,6 +368,7 @@ static irqreturn_t zinitix_ts_irq_handler(int irq, void *bt541_handler)
 	unsigned long finger_mask;
 	int error;
 	int i;
+	__le16 icon_events = 0;
 
 	memset(&touch_event, 0, sizeof(struct touch_event));
 
@@ -357,6 +379,17 @@ static irqreturn_t zinitix_ts_irq_handler(int irq, void *bt541_handler)
 		goto out;
 	}
 
+	if (touch_event.status & BIT_ICON_EVENT) {
+		error = zinitix_read_data(bt541->client, BT541_ICON_STATUS_REG,
+					  &icon_events, sizeof(icon_events));
+		if (error) {
+			dev_err(&client->dev, "Failed to read icon events\n");
+			goto out;
+		}
+
+		zinitix_report_keys(bt541, icon_events);
+	}
+
 	finger_mask = touch_event.finger_mask;
 	for_each_set_bit(i, &finger_mask, MAX_SUPPORTED_FINGER_NUM) {
 		const struct point_coord *p = &touch_event.point_coord[i];
@@ -442,6 +475,7 @@ static int zinitix_init_input_dev(struct bt541_ts_data *bt541)
 {
 	struct input_dev *input_dev;
 	int error;
+	int i;
 
 	input_dev = devm_input_allocate_device(&bt541->client->dev);
 	if (!input_dev) {
@@ -459,6 +493,14 @@ static int zinitix_init_input_dev(struct bt541_ts_data *bt541)
 	input_dev->open = zinitix_input_open;
 	input_dev->close = zinitix_input_close;
 
+	if (bt541->num_keycodes) {
+		input_dev->keycode = bt541->keycodes;
+		input_dev->keycodemax = bt541->num_keycodes;
+		input_dev->keycodesize = sizeof(bt541->keycodes[0]);
+		for (i = 0; i < bt541->num_keycodes; i++)
+			input_set_capability(input_dev, EV_KEY, bt541->keycodes[i]);
+	}
+
 	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);
 	input_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);
 	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
@@ -523,6 +565,28 @@ static int zinitix_ts_probe(struct i2c_client *client)
 		return error;
 	}
 
+	error = devm_request_threaded_irq(&client->dev, client->irq,
+					  NULL, zinitix_ts_irq_handler,
+					  IRQF_ONESHOT | IRQF_NO_AUTOEN,
+					  client->name, bt541);
+	if (error) {
+		dev_err(&client->dev, "Failed to request IRQ: %d\n", error);
+		return error;
+	}
+
+	bt541->num_keycodes = of_property_read_variable_u32_array(
+					client->dev.of_node, "linux,keycodes",
+					bt541->keycodes, 0,
+					ARRAY_SIZE(bt541->keycodes));
+	if (bt541->num_keycodes == -EINVAL) {
+		bt541->num_keycodes = 0;
+	} else if (bt541->num_keycodes < 0) {
+		dev_err(&client->dev,
+			"Unable to parse \"linux,keycodes\" property: %d\n",
+			bt541->num_keycodes);
+		return bt541->num_keycodes;
+	}
+
 	error = zinitix_init_input_dev(bt541);
 	if (error) {
 		dev_err(&client->dev,
diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig
index 3eb68fa1b8c..d5f878c3575 100644
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -448,7 +448,6 @@ config QCOM_IOMMU
 	select QCOM_SCM
 	select IOMMU_API
 	select IOMMU_IO_PGTABLE_LPAE
-	select ARM_DMA_USE_IOMMU
 	help
 	  Support for IOMMU on certain Qualcomm SoCs.
 
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index ed800f5da7d..8a830dea38d 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -754,6 +754,15 @@ config LEDS_POWERNV
 	  To compile this driver as a module, choose 'm' here: the module
 	  will be called leds-powernv.
 
+config LEDS_QCOM_LPG
+	tristate "LED support for Qualcomm LPG"
+	depends on LEDS_CLASS_MULTICOLOR
+	depends on OF
+	depends on SPMI
+	help
+	  This option enables support for the Light Pulse Generator found in a
+	  wide variety of Qualcomm PMICs.
+
 config LEDS_SYSCON
 	bool "LED support for LEDs on system controllers"
 	depends on LEDS_CLASS=y
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index c636ec06961..f7a370fb63b 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_LEDS_PCA963X)		+= leds-pca963x.o
 obj-$(CONFIG_LEDS_PM8058)		+= leds-pm8058.o
 obj-$(CONFIG_LEDS_POWERNV)		+= leds-powernv.o
 obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
+obj-$(CONFIG_LEDS_QCOM_LPG)		+= leds-qcom-lpg.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_S3C24XX)		+= leds-s3c24xx.o
 obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
diff --git a/drivers/leds/leds-qcom-lpg.c b/drivers/leds/leds-qcom-lpg.c
new file mode 100644
index 00000000000..86131a65d2c
--- /dev/null
+++ b/drivers/leds/leds-qcom-lpg.c
@@ -0,0 +1,1190 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2017-2020 Linaro Ltd
+ * Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ */
+#include <linux/bits.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#define LPG_PATTERN_CONFIG_REG	0x40
+#define LPG_SIZE_CLK_REG	0x41
+#define LPG_PREDIV_CLK_REG	0x42
+#define PWM_TYPE_CONFIG_REG	0x43
+#define PWM_VALUE_REG		0x44
+#define PWM_ENABLE_CONTROL_REG	0x46
+#define PWM_SYNC_REG		0x47
+#define LPG_RAMP_DURATION_REG	0x50
+#define LPG_HI_PAUSE_REG	0x52
+#define LPG_LO_PAUSE_REG	0x54
+#define LPG_HI_IDX_REG		0x56
+#define LPG_LO_IDX_REG		0x57
+#define PWM_SEC_ACCESS_REG	0xd0
+#define PWM_DTEST_REG(x)	(0xe2 + (x) - 1)
+
+#define TRI_LED_SRC_SEL		0x45
+#define TRI_LED_EN_CTL		0x46
+#define TRI_LED_ATC_CTL		0x47
+
+#define LPG_LUT_REG(x)		(0x40 + (x) * 2)
+#define RAMP_CONTROL_REG	0xc8
+
+struct lpg_channel;
+struct lpg_data;
+
+/**
+ * struct lpg - LPG device context
+ * @dev:	struct device for LPG device
+ * @map:	regmap for register access
+ * @pwm:	PWM-chip object, if operating in PWM mode
+ * @lut_base:	base address of the LUT block (optional)
+ * @lut_size:	number of entries in the LUT block
+ * @lut_bitmap:	allocation bitmap for LUT entries
+ * @triled_base: base address of the TRILED block (optional)
+ * @triled_src:	power-source for the TRILED
+ * @channels:	list of PWM channels
+ * @num_channels: number of @channels
+ */
+struct lpg {
+	struct device *dev;
+	struct regmap *map;
+
+	struct pwm_chip pwm;
+
+	const struct lpg_data *data;
+
+	u32 lut_base;
+	u32 lut_size;
+	unsigned long *lut_bitmap;
+
+	u32 triled_base;
+	u32 triled_src;
+
+	struct lpg_channel *channels;
+	unsigned int num_channels;
+};
+
+/**
+ * struct lpg_channel - per channel data
+ * @lpg:	reference to parent lpg
+ * @base:	base address of the PWM channel
+ * @triled_mask: mask in TRILED to enable this channel
+ * @lut_mask:	mask in LUT to start pattern generator for this channel
+ * @in_use:	channel is exposed to LED framework
+ * @color:	color of the LED attached to this channel
+ * @dtest_line:	DTEST line for output, or 0 if disabled
+ * @dtest_value: DTEST line configuration
+ * @pwm_value:	duty (in microseconds) of the generated pulses, overridden by LUT
+ * @enabled:	output enabled?
+ * @period_us:	period (in microseconds) of the generated pulses
+ * @pwm_size:	resolution of the @pwm_value, 6 or 9 bits
+ * @clk:	base frequency of the clock generator
+ * @pre_div:	divider of @clk
+ * @pre_div_exp: exponential divider of @clk
+ * @ramp_enabled: duty cycle is driven by iterating over lookup table
+ * @ramp_ping_pong: reverse through pattern, rather than wrapping to start
+ * @ramp_oneshot: perform only a single pass over the pattern
+ * @ramp_reverse: iterate over pattern backwards
+ * @ramp_duration_ms: length (in milliseconds) of one pattern run
+ * @ramp_lo_pause_ms: pause (in milliseconds) before iterating over pattern
+ * @ramp_hi_pause_ms: pause (in milliseconds) after iterating over pattern
+ * @pattern_lo_idx: start index of associated pattern
+ * @pattern_hi_idx: last index of associated pattern
+ */
+struct lpg_channel {
+	struct lpg *lpg;
+
+	u32 base;
+	unsigned int triled_mask;
+	unsigned int lut_mask;
+
+	bool in_use;
+
+	int color;
+
+	u32 dtest_line;
+	u32 dtest_value;
+
+	u16 pwm_value;
+	bool enabled;
+
+	unsigned int period_us;
+	unsigned int pwm_size;
+	unsigned int clk;
+	unsigned int pre_div;
+	unsigned int pre_div_exp;
+
+	bool ramp_enabled;
+	bool ramp_ping_pong;
+	bool ramp_oneshot;
+	bool ramp_reverse;
+	unsigned long ramp_duration_ms;
+	unsigned long ramp_lo_pause_ms;
+	unsigned long ramp_hi_pause_ms;
+
+	unsigned int pattern_lo_idx;
+	unsigned int pattern_hi_idx;
+};
+
+/**
+ * struct lpg_led - logical LED object
+ * @lpg:		lpg context reference
+ * @cdev:		LED class device
+ * @mcdev:		Multicolor LED class device
+ * @num_channels:	number of @channels
+ * @channels:		list of channels associated with the LED
+ */
+struct lpg_led {
+	struct lpg *lpg;
+
+	struct led_classdev cdev;
+	struct led_classdev_mc mcdev;
+
+	unsigned int num_channels;
+	struct lpg_channel *channels[];
+};
+
+/**
+ * struct lpg_channel_data - per channel initialization data
+ * @base:		base address for PWM channel registers
+ * @triled_mask:	bitmask for controlling this channel in TRILED
+ */
+struct lpg_channel_data {
+	unsigned int base;
+	u8 triled_mask;
+};
+
+/**
+ * struct lpg_data - initialization data
+ * @lut_base:		base address of LUT block
+ * @lut_size:		number of entries in LUT
+ * @triled_base:	base address of TRILED
+ * @pwm_9bit_mask:	bitmask for switching from 6bit to 9bit pwm
+ * @num_channels:	number of channels in LPG
+ * @channels:		list of channel initialization data
+ */
+struct lpg_data {
+	unsigned int lut_base;
+	unsigned int lut_size;
+	unsigned int triled_base;
+	unsigned int pwm_9bit_mask;
+	int num_channels;
+	struct lpg_channel_data *channels;
+};
+
+static int triled_set(struct lpg *lpg, unsigned int mask, unsigned int enable)
+{
+	/* Skip if we don't have a triled block */
+	if (!lpg->triled_base)
+		return 0;
+
+	return regmap_update_bits(lpg->map, lpg->triled_base + TRI_LED_EN_CTL,
+				  mask, enable);
+}
+
+static int lpg_lut_store(struct lpg *lpg, struct led_pattern *pattern,
+			 size_t len, unsigned int *lo_idx, unsigned int *hi_idx)
+{
+	unsigned int idx;
+	__le16 val;
+	int i;
+
+	/* Hardware does not behave when LO_IDX == HI_IDX */
+	if (len == 1)
+		return -EINVAL;
+
+	idx = bitmap_find_next_zero_area(lpg->lut_bitmap, lpg->lut_size,
+					 0, len, 0);
+	if (idx >= lpg->lut_size)
+		return -ENOMEM;
+
+	for (i = 0; i < len; i++) {
+		val = cpu_to_le16(pattern[i].brightness);
+
+		regmap_bulk_write(lpg->map, lpg->lut_base + LPG_LUT_REG(idx + i),
+				  &val, sizeof(val));
+	}
+
+	bitmap_set(lpg->lut_bitmap, idx, len);
+
+	*lo_idx = idx;
+	*hi_idx = idx + len - 1;
+
+	return 0;
+}
+
+static void lpg_lut_free(struct lpg *lpg, unsigned int lo_idx, unsigned int hi_idx)
+{
+	int len;
+
+	if (lo_idx == hi_idx)
+		return;
+
+	len = hi_idx - lo_idx + 1;
+	bitmap_clear(lpg->lut_bitmap, lo_idx, len);
+}
+
+static int lpg_lut_sync(struct lpg *lpg, unsigned int mask)
+{
+	return regmap_write(lpg->map, lpg->lut_base + RAMP_CONTROL_REG, mask);
+}
+
+#define NUM_PWM_PREDIV	4
+#define NUM_PWM_CLK	3
+#define NUM_EXP		7
+
+static const unsigned int lpg_clk_table[NUM_PWM_PREDIV][NUM_PWM_CLK] = {
+	{
+		1 * (NSEC_PER_SEC / 1024),
+		1 * (NSEC_PER_SEC / 32768),
+		1 * (NSEC_PER_SEC / 19200000),
+	},
+	{
+		3 * (NSEC_PER_SEC / 1024),
+		3 * (NSEC_PER_SEC / 32768),
+		3 * (NSEC_PER_SEC / 19200000),
+	},
+	{
+		5 * (NSEC_PER_SEC / 1024),
+		5 * (NSEC_PER_SEC / 32768),
+		5 * (NSEC_PER_SEC / 19200000),
+	},
+	{
+		6 * (NSEC_PER_SEC / 1024),
+		6 * (NSEC_PER_SEC / 32768),
+		6 * (NSEC_PER_SEC / 19200000),
+	},
+};
+
+/*
+ * PWM Frequency = Clock Frequency / (N * T)
+ *      or
+ * PWM Period = Clock Period * (N * T)
+ *      where
+ * N = 2^9 or 2^6 for 9-bit or 6-bit PWM size
+ * T = Pre-divide * 2^m, where m = 0..7 (exponent)
+ *
+ * This is the formula to figure out m for the best pre-divide and clock:
+ * (PWM Period / N) = (Pre-divide * Clock Period) * 2^m
+ */
+static void lpg_calc_freq(struct lpg_channel *chan, unsigned int period_us)
+{
+	int             n, m, clk, div;
+	int             best_m, best_div, best_clk;
+	unsigned int    last_err, cur_err, min_err;
+	unsigned int    tmp_p, period_n;
+
+	if (period_us == chan->period_us)
+		return;
+
+	/* PWM Period / N */
+	if (period_us < UINT_MAX / NSEC_PER_USEC)
+		n = 6;
+	else
+		n = 9;
+
+	period_n = ((u64)period_us * NSEC_PER_USEC) >> n;
+
+	min_err = UINT_MAX;
+	last_err = UINT_MAX;
+	best_m = 0;
+	best_clk = 0;
+	best_div = 0;
+	for (clk = 0; clk < NUM_PWM_CLK; clk++) {
+		for (div = 0; div < NUM_PWM_PREDIV; div++) {
+			/* period_n = (PWM Period / N) */
+			/* tmp_p = (Pre-divide * Clock Period) * 2^m */
+			tmp_p = lpg_clk_table[div][clk];
+			for (m = 0; m <= NUM_EXP; m++) {
+				cur_err = abs(period_n - tmp_p);
+				if (cur_err < min_err) {
+					min_err = cur_err;
+					best_m = m;
+					best_clk = clk;
+					best_div = div;
+				}
+
+				if (m && cur_err > last_err)
+					/* Break for bigger cur_err */
+					break;
+
+				last_err = cur_err;
+				tmp_p <<= 1;
+			}
+		}
+	}
+
+	/* Use higher resolution */
+	if (best_m >= 3 && n == 6) {
+		n += 3;
+		best_m -= 3;
+	}
+
+	chan->clk = best_clk;
+	chan->pre_div = best_div;
+	chan->pre_div_exp = best_m;
+	chan->pwm_size = n;
+
+	chan->period_us = period_us;
+}
+
+static void lpg_calc_duty(struct lpg_channel *chan, unsigned int duty_us)
+{
+	unsigned int max = (1 << chan->pwm_size) - 1;
+	unsigned int val = div_u64((u64)duty_us << chan->pwm_size, chan->period_us);
+
+	chan->pwm_value = min(val, max);
+}
+
+static void lpg_apply_freq(struct lpg_channel *chan)
+{
+	unsigned long val;
+	struct lpg *lpg = chan->lpg;
+
+	if (!chan->enabled)
+		return;
+
+	/* Clock register values are off-by-one from lpg_clk_table */
+	val = chan->clk + 1;
+
+	if (chan->pwm_size == 9)
+		val |= lpg->data->pwm_9bit_mask;
+
+	regmap_write(lpg->map, chan->base + LPG_SIZE_CLK_REG, val);
+
+	val = chan->pre_div << 5 | chan->pre_div_exp;
+	regmap_write(lpg->map, chan->base + LPG_PREDIV_CLK_REG, val);
+}
+
+#define LPG_ENABLE_GLITCH_REMOVAL	BIT(5)
+
+static void lpg_enable_glitch(struct lpg_channel *chan)
+{
+	struct lpg *lpg = chan->lpg;
+
+	regmap_update_bits(lpg->map, chan->base + PWM_TYPE_CONFIG_REG,
+			   LPG_ENABLE_GLITCH_REMOVAL, 0);
+}
+
+static void lpg_disable_glitch(struct lpg_channel *chan)
+{
+	struct lpg *lpg = chan->lpg;
+
+	regmap_update_bits(lpg->map, chan->base + PWM_TYPE_CONFIG_REG,
+			   LPG_ENABLE_GLITCH_REMOVAL,
+			   LPG_ENABLE_GLITCH_REMOVAL);
+}
+
+static void lpg_apply_pwm_value(struct lpg_channel *chan)
+{
+	__le16 val = cpu_to_le16(chan->pwm_value);
+	struct lpg *lpg = chan->lpg;
+
+	if (!chan->enabled)
+		return;
+
+	regmap_bulk_write(lpg->map, chan->base + PWM_VALUE_REG, &val, sizeof(val));
+}
+
+#define LPG_PATTERN_CONFIG_LO_TO_HI	BIT(4)
+#define LPG_PATTERN_CONFIG_REPEAT	BIT(3)
+#define LPG_PATTERN_CONFIG_TOGGLE	BIT(2)
+#define LPG_PATTERN_CONFIG_PAUSE_HI	BIT(1)
+#define LPG_PATTERN_CONFIG_PAUSE_LO	BIT(0)
+
+static void lpg_apply_lut_control(struct lpg_channel *chan)
+{
+	struct lpg *lpg = chan->lpg;
+	unsigned int hi_pause;
+	unsigned int lo_pause;
+	unsigned int step;
+	unsigned int conf = 0;
+	unsigned int lo_idx = chan->pattern_lo_idx;
+	unsigned int hi_idx = chan->pattern_hi_idx;
+	int pattern_len;
+
+	if (!chan->ramp_enabled || chan->pattern_lo_idx == chan->pattern_hi_idx)
+		return;
+
+	pattern_len = hi_idx - lo_idx + 1;
+
+	step = DIV_ROUND_UP(chan->ramp_duration_ms, pattern_len);
+	hi_pause = DIV_ROUND_UP(chan->ramp_hi_pause_ms, step);
+	lo_pause = DIV_ROUND_UP(chan->ramp_lo_pause_ms, step);
+
+	if (!chan->ramp_reverse)
+		conf |= LPG_PATTERN_CONFIG_LO_TO_HI;
+	if (!chan->ramp_oneshot)
+		conf |= LPG_PATTERN_CONFIG_REPEAT;
+	if (chan->ramp_ping_pong)
+		conf |= LPG_PATTERN_CONFIG_TOGGLE;
+	if (chan->ramp_hi_pause_ms)
+		conf |= LPG_PATTERN_CONFIG_PAUSE_HI;
+	if (chan->ramp_lo_pause_ms)
+		conf |= LPG_PATTERN_CONFIG_PAUSE_LO;
+
+	regmap_write(lpg->map, chan->base + LPG_PATTERN_CONFIG_REG, conf);
+	regmap_write(lpg->map, chan->base + LPG_HI_IDX_REG, hi_idx);
+	regmap_write(lpg->map, chan->base + LPG_LO_IDX_REG, lo_idx);
+
+	regmap_write(lpg->map, chan->base + LPG_RAMP_DURATION_REG, step);
+	regmap_write(lpg->map, chan->base + LPG_HI_PAUSE_REG, hi_pause);
+	regmap_write(lpg->map, chan->base + LPG_LO_PAUSE_REG, lo_pause);
+}
+
+#define LPG_ENABLE_CONTROL_OUTPUT		BIT(7)
+#define LPG_ENABLE_CONTROL_BUFFER_TRISTATE	BIT(5)
+#define LPG_ENABLE_CONTROL_SRC_PWM		BIT(2)
+#define LPG_ENABLE_CONTROL_RAMP_GEN		BIT(1)
+
+static void lpg_apply_control(struct lpg_channel *chan)
+{
+	unsigned int ctrl;
+	struct lpg *lpg = chan->lpg;
+
+	ctrl = LPG_ENABLE_CONTROL_BUFFER_TRISTATE;
+
+	if (chan->enabled)
+		ctrl |= LPG_ENABLE_CONTROL_OUTPUT;
+
+	if (chan->pattern_lo_idx != chan->pattern_hi_idx)
+		ctrl |= LPG_ENABLE_CONTROL_RAMP_GEN;
+	else
+		ctrl |= LPG_ENABLE_CONTROL_SRC_PWM;
+
+	regmap_write(lpg->map, chan->base + PWM_ENABLE_CONTROL_REG, ctrl);
+
+	/*
+	 * Due to LPG hardware bug, in the PWM mode, having enabled PWM,
+	 * We have to write PWM values one more time.
+	 */
+	if (chan->enabled)
+		lpg_apply_pwm_value(chan);
+}
+
+#define LPG_SYNC_PWM	BIT(0)
+
+static void lpg_apply_sync(struct lpg_channel *chan)
+{
+	struct lpg *lpg = chan->lpg;
+
+	regmap_write(lpg->map, chan->base + PWM_SYNC_REG, LPG_SYNC_PWM);
+}
+
+static void lpg_apply_dtest(struct lpg_channel *chan)
+{
+	struct lpg *lpg = chan->lpg;
+
+	if (!chan->dtest_line)
+		return;
+
+	regmap_write(lpg->map, chan->base + PWM_SEC_ACCESS_REG, 0xa5);
+	regmap_write(lpg->map, chan->base + PWM_DTEST_REG(chan->dtest_line),
+		     chan->dtest_value);
+}
+
+static void lpg_apply(struct lpg_channel *chan)
+{
+	lpg_disable_glitch(chan);
+	lpg_apply_freq(chan);
+	lpg_apply_pwm_value(chan);
+	lpg_apply_control(chan);
+	lpg_apply_sync(chan);
+	lpg_apply_lut_control(chan);
+	lpg_enable_glitch(chan);
+}
+
+static void lpg_brightness_set(struct lpg_led *led, struct led_classdev *cdev,
+			       struct mc_subled *subleds)
+{
+	enum led_brightness brightness;
+	struct lpg_channel *chan;
+	unsigned int triled_enabled = 0;
+	unsigned int triled_mask = 0;
+	unsigned int lut_mask = 0;
+	unsigned int duty_us;
+	struct lpg *lpg = led->lpg;
+	int i;
+
+	for (i = 0; i < led->num_channels; i++) {
+		chan = led->channels[i];
+		brightness = subleds[i].brightness;
+
+		if (brightness == LED_OFF) {
+			chan->enabled = false;
+			chan->ramp_enabled = false;
+		} else if (chan->pattern_lo_idx != chan->pattern_hi_idx) {
+			lpg_calc_freq(chan, NSEC_PER_USEC);
+
+			chan->enabled = true;
+			chan->ramp_enabled = true;
+
+			lut_mask |= chan->lut_mask;
+			triled_enabled |= chan->triled_mask;
+		} else {
+			lpg_calc_freq(chan, NSEC_PER_USEC);
+
+			duty_us = brightness * chan->period_us / cdev->max_brightness;
+			lpg_calc_duty(chan, duty_us);
+			chan->enabled = true;
+			chan->ramp_enabled = false;
+
+			triled_enabled |= chan->triled_mask;
+		}
+
+		triled_mask |= chan->triled_mask;
+
+		lpg_apply(chan);
+	}
+
+	/* Toggle triled lines */
+	if (triled_mask)
+		triled_set(lpg, triled_mask, triled_enabled);
+
+	/* Trigger start of ramp generator(s) */
+	if (lut_mask)
+		lpg_lut_sync(lpg, lut_mask);
+}
+
+static void lpg_brightness_single_set(struct led_classdev *cdev,
+				      enum led_brightness value)
+{
+	struct lpg_led *led = container_of(cdev, struct lpg_led, cdev);
+	struct mc_subled info;
+
+	info.brightness = value;
+	lpg_brightness_set(led, cdev, &info);
+}
+
+static void lpg_brightness_mc_set(struct led_classdev *cdev,
+				  enum led_brightness value)
+{
+	struct led_classdev_mc *mc = lcdev_to_mccdev(cdev);
+	struct lpg_led *led = container_of(mc, struct lpg_led, mcdev);
+
+	led_mc_calc_color_components(mc, value);
+	lpg_brightness_set(led, cdev, mc->subled_info);
+}
+
+static int lpg_blink_set(struct lpg_led *led,
+			 unsigned long delay_on, unsigned long delay_off)
+{
+	struct lpg_channel *chan;
+	unsigned int period_us;
+	unsigned int duty_us;
+	int i;
+
+	if (!delay_on && !delay_off) {
+		delay_on = 500;
+		delay_off = 500;
+	}
+
+	duty_us = delay_on * USEC_PER_MSEC;
+	period_us = (delay_on + delay_off) * USEC_PER_MSEC;
+
+	for (i = 0; i < led->num_channels; i++) {
+		chan = led->channels[i];
+
+		lpg_calc_freq(chan, period_us);
+		lpg_calc_duty(chan, duty_us);
+
+		chan->enabled = true;
+		chan->ramp_enabled = false;
+
+		lpg_apply(chan);
+	}
+
+	return 0;
+}
+
+static int lpg_blink_single_set(struct led_classdev *cdev,
+				unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct lpg_led *led = container_of(cdev, struct lpg_led, cdev);
+
+	return lpg_blink_set(led, *delay_on, *delay_off);
+}
+
+static int lpg_blink_mc_set(struct led_classdev *cdev,
+			    unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct led_classdev_mc *mc = lcdev_to_mccdev(cdev);
+	struct lpg_led *led = container_of(mc, struct lpg_led, mcdev);
+
+	return lpg_blink_set(led, *delay_on, *delay_off);
+}
+
+static int lpg_pattern_set(struct lpg_led *led, struct led_pattern *pattern,
+			   u32 len, int repeat)
+{
+	struct lpg_channel *chan;
+	struct lpg *lpg = led->lpg;
+	unsigned int hi_pause;
+	unsigned int lo_pause;
+	unsigned int lo_idx;
+	unsigned int hi_idx;
+	bool ping_pong = true;
+	int brightness_a;
+	int brightness_b;
+	int ret;
+	int i;
+
+	/* Only support oneshot or indefinite loops, due to limited pattern space */
+	if (repeat != -1 && repeat != 1)
+		return -EINVAL;
+
+	/*
+	 * The LPG plays patterns with at a fixed pace, a "low pause" can be
+	 * performed before the pattern and a "high pause" after. In order to
+	 * save space the pattern can be played in "ping pong" mode, in which
+	 * the pattern is first played forward, then "high pause" is applied,
+	 * then the pattern is played backwards and finally the "low pause" is
+	 * applied.
+	 *
+	 * The delta_t of the first entry is used to determine the pace of the
+	 * pattern.
+	 *
+	 * If the specified pattern is a palindrome the ping pong mode is
+	 * enabled. In this scenario the delta_t of the last entry determines
+	 * the "low pause" time and the delta_t of the middle entry (i.e. the
+	 * last in the programmed pattern) determines the "high pause". If the
+	 * pattern consists of an odd number of values, no "high pause" is
+	 * used.
+	 *
+	 * When ping pong mode is not selected, the delta_t of the last entry
+	 * is used as "high pause". No "low pause" is used.
+	 *
+	 * delta_t of any other members of the pattern is ignored.
+	 */
+
+	/* Detect palindromes and use "ping pong" to reduce LUT usage */
+	for (i = 0; i < len / 2; i++) {
+		brightness_a = pattern[i].brightness;
+		brightness_b = pattern[len - i - 1].brightness;
+
+		if (brightness_a != brightness_b) {
+			ping_pong = false;
+			break;
+		}
+	}
+
+	if (ping_pong) {
+		if (len % 2)
+			hi_pause = 0;
+		else
+			hi_pause = pattern[len + 1 / 2].delta_t;
+		lo_pause = pattern[len - 1].delta_t;
+
+		len = (len + 1) / 2;
+	} else {
+		hi_pause = pattern[len - 1].delta_t;
+		lo_pause = 0;
+	}
+
+	ret = lpg_lut_store(lpg, pattern, len, &lo_idx, &hi_idx);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < led->num_channels; i++) {
+		chan = led->channels[i];
+
+		chan->ramp_duration_ms = pattern[0].delta_t * len;
+		chan->ramp_ping_pong = ping_pong;
+		chan->ramp_oneshot = repeat != -1;
+
+		chan->ramp_lo_pause_ms = lo_pause;
+		chan->ramp_hi_pause_ms = hi_pause;
+
+		chan->pattern_lo_idx = lo_idx;
+		chan->pattern_hi_idx = hi_idx;
+	}
+
+out:
+	return ret;
+}
+
+static int lpg_pattern_single_set(struct led_classdev *cdev,
+				  struct led_pattern *pattern, u32 len,
+				  int repeat)
+{
+	struct lpg_led *led = container_of(cdev, struct lpg_led, cdev);
+	int ret;
+
+	ret = lpg_pattern_set(led, pattern, len, repeat);
+	if (ret < 0)
+		return ret;
+
+	lpg_brightness_single_set(cdev, LED_FULL);
+
+	return 0;
+}
+
+static int lpg_pattern_mc_set(struct led_classdev *cdev,
+			      struct led_pattern *pattern, u32 len,
+			      int repeat)
+{
+	struct led_classdev_mc *mc = lcdev_to_mccdev(cdev);
+	struct lpg_led *led = container_of(mc, struct lpg_led, mcdev);
+	int ret;
+
+	ret = lpg_pattern_set(led, pattern, len, repeat);
+	if (ret < 0)
+		return ret;
+
+	led_mc_calc_color_components(mc, LED_FULL);
+	lpg_brightness_set(led, cdev, mc->subled_info);
+
+	return 0;
+}
+
+static int lpg_pattern_clear(struct lpg_led *led)
+{
+	struct lpg_channel *chan;
+	struct lpg *lpg = led->lpg;
+	int i;
+
+	chan = led->channels[0];
+	lpg_lut_free(lpg, chan->pattern_lo_idx, chan->pattern_hi_idx);
+
+	for (i = 0; i < led->num_channels; i++) {
+		chan = led->channels[i];
+		chan->pattern_lo_idx = 0;
+		chan->pattern_hi_idx = 0;
+	}
+
+	return 0;
+}
+
+static int lpg_pattern_single_clear(struct led_classdev *cdev)
+{
+	struct lpg_led *led = container_of(cdev, struct lpg_led, cdev);
+
+	return lpg_pattern_clear(led);
+}
+
+static int lpg_pattern_mc_clear(struct led_classdev *cdev)
+{
+	struct led_classdev_mc *mc = lcdev_to_mccdev(cdev);
+	struct lpg_led *led = container_of(mc, struct lpg_led, mcdev);
+
+	return lpg_pattern_clear(led);
+}
+
+static int lpg_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct lpg *lpg = container_of(chip, struct lpg, pwm);
+	struct lpg_channel *chan = &lpg->channels[pwm->hwpwm];
+
+	return chan->in_use ? -EBUSY : 0;
+}
+
+static int lpg_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			 const struct pwm_state *state)
+{
+	struct lpg *lpg = container_of(chip, struct lpg, pwm);
+	struct lpg_channel *chan = &lpg->channels[pwm->hwpwm];
+
+	lpg_calc_freq(chan, div_u64(state->period, NSEC_PER_USEC));
+	lpg_calc_duty(chan, div_u64(state->duty_cycle, NSEC_PER_USEC));
+	chan->enabled = state->enabled;
+
+	lpg_apply(chan);
+
+	triled_set(lpg, chan->triled_mask, chan->enabled ? chan->triled_mask : 0);
+
+	return 0;
+}
+
+static const struct pwm_ops lpg_pwm_ops = {
+	.request = lpg_pwm_request,
+	.apply = lpg_pwm_apply,
+	.owner = THIS_MODULE,
+};
+
+static int lpg_add_pwm(struct lpg *lpg)
+{
+	int ret;
+
+	lpg->pwm.base = -1;
+	lpg->pwm.dev = lpg->dev;
+	lpg->pwm.npwm = lpg->num_channels;
+	lpg->pwm.ops = &lpg_pwm_ops;
+
+	ret = pwmchip_add(&lpg->pwm);
+	if (ret)
+		dev_err(lpg->dev, "failed to add PWM chip: ret %d\n", ret);
+
+	return ret;
+}
+
+static int lpg_parse_channel(struct lpg *lpg, struct device_node *np,
+			     struct lpg_channel **channel)
+{
+	struct lpg_channel *chan;
+	u32 dtest[2];
+	u32 color = LED_COLOR_ID_GREEN;
+	u32 reg;
+	int ret;
+
+	ret = of_property_read_u32(np, "reg", &reg);
+	if (ret || !reg || reg > lpg->num_channels) {
+		dev_err(lpg->dev, "invalid reg of %pOFn\n", np);
+		return -EINVAL;
+	}
+
+	chan = &lpg->channels[reg - 1];
+	chan->in_use = true;
+
+	ret = of_property_read_u32(np, "color", &color);
+	if (ret < 0 && ret != -EINVAL)
+		return ret;
+
+	chan->color = color;
+
+	ret = of_property_read_u32_array(np, "qcom,dtest", dtest, 2);
+	if (ret < 0 && ret != -EINVAL) {
+		dev_err(lpg->dev, "malformed qcom,dtest of %pOFn\n", np);
+		return ret;
+	} else if (!ret) {
+		chan->dtest_line = dtest[0];
+		chan->dtest_value = dtest[1];
+	}
+
+	*channel = chan;
+
+	return 0;
+}
+
+static int lpg_add_led(struct lpg *lpg, struct device_node *np)
+{
+	struct led_classdev *cdev;
+	struct device_node *child;
+	struct mc_subled *info;
+	struct lpg_led *led;
+	const char *state;
+	int num_channels;
+	u32 color = 0;
+	int ret;
+	int i;
+
+	ret = of_property_read_u32(np, "color", &color);
+	if (ret < 0 && ret != -EINVAL)
+		return ret;
+
+	if (color == LED_COLOR_ID_MULTI)
+		num_channels = of_get_available_child_count(np);
+	else
+		num_channels = 1;
+
+	led = devm_kzalloc(lpg->dev, struct_size(led, channels, num_channels), GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
+
+	led->lpg = lpg;
+	led->num_channels = num_channels;
+
+	if (color == LED_COLOR_ID_MULTI) {
+		info = devm_kcalloc(lpg->dev, num_channels, sizeof(*info), GFP_KERNEL);
+		if (!info)
+			return -ENOMEM;
+		i = 0;
+		for_each_available_child_of_node(np, child) {
+			ret = lpg_parse_channel(lpg, child, &led->channels[i]);
+			if (ret < 0)
+				return ret;
+
+			info[i].color_index = led->channels[i]->color;
+			info[i].intensity = LED_FULL;
+			i++;
+		}
+
+		led->mcdev.subled_info = info;
+		led->mcdev.num_colors = num_channels;
+
+		cdev = &led->mcdev.led_cdev;
+		cdev->brightness_set = lpg_brightness_mc_set;
+		cdev->blink_set = lpg_blink_mc_set;
+
+		/* Register pattern accessors only if we have a LUT block */
+		if (lpg->lut_base) {
+			cdev->pattern_set = lpg_pattern_mc_set;
+			cdev->pattern_clear = lpg_pattern_mc_clear;
+		}
+	} else {
+		ret = lpg_parse_channel(lpg, np, &led->channels[0]);
+		if (ret < 0)
+			return ret;
+
+		cdev = &led->cdev;
+		cdev->brightness_set = lpg_brightness_single_set;
+		cdev->blink_set = lpg_blink_single_set;
+
+		/* Register pattern accessors only if we have a LUT block */
+		if (lpg->lut_base) {
+			cdev->pattern_set = lpg_pattern_single_set;
+			cdev->pattern_clear = lpg_pattern_single_clear;
+		}
+	}
+
+	/* Use label else node name */
+	cdev->name = of_get_property(np, "label", NULL) ? : np->name;
+	cdev->default_trigger = of_get_property(np, "linux,default-trigger", NULL);
+	cdev->max_brightness = 255;
+
+	if (!of_property_read_string(np, "default-state", &state) &&
+	    !strcmp(state, "on"))
+		cdev->brightness = LED_FULL;
+	else
+		cdev->brightness = LED_OFF;
+
+	cdev->brightness_set(cdev, cdev->brightness);
+
+	if (color == LED_COLOR_ID_MULTI)
+		ret = devm_led_classdev_multicolor_register(lpg->dev, &led->mcdev);
+	else
+		ret = devm_led_classdev_register(lpg->dev, &led->cdev);
+	if (ret)
+		dev_err(lpg->dev, "unable to register %s\n", cdev->name);
+
+	return ret;
+}
+
+static int lpg_init_channels(struct lpg *lpg)
+{
+	const struct lpg_data *data = lpg->data;
+	int i;
+
+	lpg->num_channels = data->num_channels;
+	lpg->channels = devm_kcalloc(lpg->dev, data->num_channels,
+				     sizeof(struct lpg_channel), GFP_KERNEL);
+	if (!lpg->channels)
+		return -ENOMEM;
+
+	for (i = 0; i < data->num_channels; i++) {
+		lpg->channels[i].lpg = lpg;
+		lpg->channels[i].base = data->channels[i].base;
+		lpg->channels[i].triled_mask = data->channels[i].triled_mask;
+		lpg->channels[i].lut_mask = BIT(i);
+	}
+
+	return 0;
+}
+
+static int lpg_init_triled(struct lpg *lpg)
+{
+	struct device_node *np = lpg->dev->of_node;
+	int ret;
+
+	/* Skip initialization if we don't have a triled block */
+	if (!lpg->data->triled_base)
+		return 0;
+
+	lpg->triled_base = lpg->data->triled_base;
+
+	ret = of_property_read_u32(np, "qcom,power-source", &lpg->triled_src);
+	if (ret || lpg->triled_src == 2 || lpg->triled_src > 3) {
+		dev_err(lpg->dev, "invalid power source\n");
+		return -EINVAL;
+	}
+
+	/* Disable automatic trickle charge LED */
+	regmap_write(lpg->map, lpg->triled_base + TRI_LED_ATC_CTL, 0);
+
+	/* Configure power source */
+	regmap_write(lpg->map, lpg->triled_base + TRI_LED_SRC_SEL, lpg->triled_src);
+
+	/* Default all outputs to off */
+	regmap_write(lpg->map, lpg->triled_base + TRI_LED_EN_CTL, 0);
+
+	return 0;
+}
+
+static int lpg_init_lut(struct lpg *lpg)
+{
+	const struct lpg_data *data = lpg->data;
+	size_t bitmap_size;
+
+	if (!data->lut_base)
+		return 0;
+
+	lpg->lut_base = data->lut_base;
+	lpg->lut_size = data->lut_size;
+
+	bitmap_size = BITS_TO_LONGS(lpg->lut_size) * sizeof(unsigned long);
+	lpg->lut_bitmap = devm_kzalloc(lpg->dev, bitmap_size, GFP_KERNEL);
+
+	bitmap_clear(lpg->lut_bitmap, 0, lpg->lut_size);
+	return lpg->lut_bitmap ? 0 : -ENOMEM;
+}
+
+static int lpg_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct lpg *lpg;
+	int ret;
+	int i;
+
+	lpg = devm_kzalloc(&pdev->dev, sizeof(*lpg), GFP_KERNEL);
+	if (!lpg)
+		return -ENOMEM;
+
+	lpg->data = of_device_get_match_data(&pdev->dev);
+	if (!lpg->data)
+		return -EINVAL;
+
+	lpg->dev = &pdev->dev;
+
+	lpg->map = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!lpg->map) {
+		dev_err(&pdev->dev, "parent regmap unavailable\n");
+		return -ENXIO;
+	}
+
+	ret = lpg_init_channels(lpg);
+	if (ret < 0)
+		return ret;
+
+	ret = lpg_init_triled(lpg);
+	if (ret < 0)
+		return ret;
+
+	ret = lpg_init_lut(lpg);
+	if (ret < 0)
+		return ret;
+
+	for_each_available_child_of_node(pdev->dev.of_node, np) {
+		ret = lpg_add_led(lpg, np);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < lpg->num_channels; i++)
+		lpg_apply_dtest(&lpg->channels[i]);
+
+	ret = lpg_add_pwm(lpg);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, lpg);
+
+	return 0;
+}
+
+static int lpg_remove(struct platform_device *pdev)
+{
+	struct lpg *lpg = platform_get_drvdata(pdev);
+
+	pwmchip_remove(&lpg->pwm);
+
+	return 0;
+}
+
+static const struct lpg_data pm8916_pwm_data = {
+	.pwm_9bit_mask = BIT(2),
+
+	.num_channels = 1,
+	.channels = (struct lpg_channel_data[]) {
+		{ .base = 0xbc00 },
+	},
+};
+
+static const struct lpg_data pm8941_lpg_data = {
+	.lut_base = 0xb000,
+	.lut_size = 64,
+
+	.triled_base = 0xd000,
+
+	.pwm_9bit_mask = 3 << 4,
+
+	.num_channels = 8,
+	.channels = (struct lpg_channel_data[]) {
+		{ .base = 0xb100 },
+		{ .base = 0xb200 },
+		{ .base = 0xb300 },
+		{ .base = 0xb400 },
+		{ .base = 0xb500, .triled_mask = BIT(5) },
+		{ .base = 0xb600, .triled_mask = BIT(6) },
+		{ .base = 0xb700, .triled_mask = BIT(7) },
+		{ .base = 0xb800 },
+	},
+};
+
+static const struct lpg_data pm8994_lpg_data = {
+	.lut_base = 0xb000,
+	.lut_size = 64,
+
+	.pwm_9bit_mask = 3 << 4,
+
+	.num_channels = 6,
+	.channels = (struct lpg_channel_data[]) {
+		{ .base = 0xb100 },
+		{ .base = 0xb200 },
+		{ .base = 0xb300 },
+		{ .base = 0xb400 },
+		{ .base = 0xb500 },
+		{ .base = 0xb600 },
+	},
+};
+
+static const struct lpg_data pmi8994_lpg_data = {
+	.lut_base = 0xb000,
+	.lut_size = 24,
+
+	.triled_base = 0xd000,
+
+	.pwm_9bit_mask = BIT(4),
+
+	.num_channels = 4,
+	.channels = (struct lpg_channel_data[]) {
+		{ .base = 0xb100, .triled_mask = BIT(5) },
+		{ .base = 0xb200, .triled_mask = BIT(6) },
+		{ .base = 0xb300, .triled_mask = BIT(7) },
+		{ .base = 0xb400 },
+	},
+};
+
+static const struct lpg_data pmi8998_lpg_data = {
+	.lut_base = 0xb000,
+	.lut_size = 49,
+
+	.pwm_9bit_mask = BIT(4),
+
+	.num_channels = 6,
+	.channels = (struct lpg_channel_data[]) {
+		{ .base = 0xb100 },
+		{ .base = 0xb200 },
+		{ .base = 0xb300, .triled_mask = BIT(5) },
+		{ .base = 0xb400, .triled_mask = BIT(6) },
+		{ .base = 0xb500, .triled_mask = BIT(7) },
+		{ .base = 0xb600 },
+	},
+};
+
+static const struct of_device_id lpg_of_table[] = {
+	{ .compatible = "qcom,pm8916-pwm", .data = &pm8916_pwm_data },
+	{ .compatible = "qcom,pm8941-lpg", .data = &pm8941_lpg_data },
+	{ .compatible = "qcom,pm8994-lpg", .data = &pm8994_lpg_data },
+	{ .compatible = "qcom,pmi8994-lpg", .data = &pmi8994_lpg_data },
+	{ .compatible = "qcom,pmi8998-lpg", .data = &pmi8998_lpg_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, lpg_of_table);
+
+static struct platform_driver lpg_driver = {
+	.probe = lpg_probe,
+	.remove = lpg_remove,
+	.driver = {
+		.name = "qcom-spmi-lpg",
+		.of_match_table = lpg_of_table,
+	},
+};
+module_platform_driver(lpg_driver);
+
+MODULE_DESCRIPTION("Qualcomm LPG LED driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/wwan/Kconfig b/drivers/net/wwan/Kconfig
index 77dbfc418bc..af04f0dccc0 100644
--- a/drivers/net/wwan/Kconfig
+++ b/drivers/net/wwan/Kconfig
@@ -50,6 +50,19 @@ config MHI_WWAN_MBIM
           To compile this driver as a module, choose M here: the module will be
           called mhi_wwan_mbim.
 
+config QCOM_BAM_DMUX
+	tristate "Qualcomm BAM-DMUX WWAN network driver"
+	depends on (DMA_ENGINE && PM && QCOM_SMEM_STATE) || COMPILE_TEST
+	help
+	  The BAM Data Multiplexer provides access to the network data channels
+	  of modems integrated into many older Qualcomm SoCs, e.g. Qualcomm
+	  MSM8916 or MSM8974. The connection can be established via QMI/AT from
+	  userspace with control ports available through the WWAN subsystem
+	  (CONFIG_RPMSG_WWAN_CTRL) or QRTR network sockets (CONFIG_QRTR).
+
+	  To compile this driver as a module, choose M here: the module will be
+	  called qcom_bam_dmux.
+
 config RPMSG_WWAN_CTRL
 	tristate "RPMSG WWAN control driver"
 	depends on RPMSG
diff --git a/drivers/net/wwan/Makefile b/drivers/net/wwan/Makefile
index fe51feedac2..e722650bebe 100644
--- a/drivers/net/wwan/Makefile
+++ b/drivers/net/wwan/Makefile
@@ -10,5 +10,6 @@ obj-$(CONFIG_WWAN_HWSIM) += wwan_hwsim.o
 
 obj-$(CONFIG_MHI_WWAN_CTRL) += mhi_wwan_ctrl.o
 obj-$(CONFIG_MHI_WWAN_MBIM) += mhi_wwan_mbim.o
+obj-$(CONFIG_QCOM_BAM_DMUX) += qcom_bam_dmux.o
 obj-$(CONFIG_RPMSG_WWAN_CTRL) += rpmsg_wwan_ctrl.o
 obj-$(CONFIG_IOSM) += iosm/
diff --git a/drivers/net/wwan/qcom_bam_dmux.c b/drivers/net/wwan/qcom_bam_dmux.c
new file mode 100644
index 00000000000..5dfa2eba601
--- /dev/null
+++ b/drivers/net/wwan/qcom_bam_dmux.c
@@ -0,0 +1,907 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Qualcomm BAM-DMUX WWAN network driver
+ * Copyright (c) 2020, Stephan Gerhold <stephan@gerhold.net>
+ */
+
+#include <linux/atomic.h>
+#include <linux/bitops.h>
+#include <linux/completion.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/if_arp.h>
+#include <linux/interrupt.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/soc/qcom/smem_state.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <net/pkt_sched.h>
+
+#define BAM_DMUX_BUFFER_SIZE		SZ_2K
+#define BAM_DMUX_HDR_SIZE		sizeof(struct bam_dmux_hdr)
+#define BAM_DMUX_MAX_DATA_SIZE		(BAM_DMUX_BUFFER_SIZE - BAM_DMUX_HDR_SIZE)
+#define BAM_DMUX_NUM_SKB		32
+
+#define BAM_DMUX_HDR_MAGIC		0x33fc
+
+#define BAM_DMUX_AUTOSUSPEND_DELAY	1000
+#define BAM_DMUX_REMOTE_TIMEOUT		msecs_to_jiffies(2000)
+
+enum {
+	BAM_DMUX_CMD_DATA,
+	BAM_DMUX_CMD_OPEN,
+	BAM_DMUX_CMD_CLOSE,
+};
+
+enum {
+	BAM_DMUX_CH_DATA_0,
+	BAM_DMUX_CH_DATA_1,
+	BAM_DMUX_CH_DATA_2,
+	BAM_DMUX_CH_DATA_3,
+	BAM_DMUX_CH_DATA_4,
+	BAM_DMUX_CH_DATA_5,
+	BAM_DMUX_CH_DATA_6,
+	BAM_DMUX_CH_DATA_7,
+	BAM_DMUX_NUM_CH
+};
+
+struct bam_dmux_hdr {
+	u16 magic;
+	u8 signal;
+	u8 cmd;
+	u8 pad;
+	u8 ch;
+	u16 len;
+};
+
+struct bam_dmux_skb_dma {
+	struct bam_dmux *dmux;
+	struct sk_buff *skb;
+	dma_addr_t addr;
+};
+
+struct bam_dmux {
+	struct device *dev;
+
+	int pc_irq;
+	bool pc_state, pc_ack_state;
+	struct qcom_smem_state *pc, *pc_ack;
+	u32 pc_mask, pc_ack_mask;
+	wait_queue_head_t pc_wait;
+	struct completion pc_ack_completion;
+
+	struct dma_chan *rx, *tx;
+	struct bam_dmux_skb_dma rx_skbs[BAM_DMUX_NUM_SKB];
+	struct bam_dmux_skb_dma tx_skbs[BAM_DMUX_NUM_SKB];
+	spinlock_t tx_lock; /* Protect tx_skbs, tx_next_skb */
+	unsigned int tx_next_skb;
+	atomic_long_t tx_deferred_skb;
+	struct work_struct tx_wakeup_work;
+
+	DECLARE_BITMAP(remote_channels, BAM_DMUX_NUM_CH);
+	struct work_struct register_netdev_work;
+	struct net_device *netdevs[BAM_DMUX_NUM_CH];
+};
+
+struct bam_dmux_netdev {
+	struct bam_dmux *dmux;
+	u8 ch;
+};
+
+static void bam_dmux_pc_vote(struct bam_dmux *dmux, bool enable)
+{
+	reinit_completion(&dmux->pc_ack_completion);
+	qcom_smem_state_update_bits(dmux->pc, dmux->pc_mask,
+				    enable ? dmux->pc_mask : 0);
+}
+
+static void bam_dmux_pc_ack(struct bam_dmux *dmux)
+{
+	qcom_smem_state_update_bits(dmux->pc_ack, dmux->pc_ack_mask,
+				    dmux->pc_ack_state ? 0 : dmux->pc_ack_mask);
+	dmux->pc_ack_state = !dmux->pc_ack_state;
+}
+
+static bool bam_dmux_skb_dma_map(struct bam_dmux_skb_dma *skb_dma,
+				 enum dma_data_direction dir)
+{
+	struct device *dev = skb_dma->dmux->dev;
+
+	skb_dma->addr = dma_map_single(dev, skb_dma->skb->data, skb_dma->skb->len, dir);
+	if (dma_mapping_error(dev, skb_dma->addr)) {
+		dev_err(dev, "Failed to DMA map buffer\n");
+		skb_dma->addr = 0;
+		return false;
+	}
+
+	return true;
+}
+
+static void bam_dmux_skb_dma_unmap(struct bam_dmux_skb_dma *skb_dma,
+				   enum dma_data_direction dir)
+{
+	dma_unmap_single(skb_dma->dmux->dev, skb_dma->addr, skb_dma->skb->len, dir);
+	skb_dma->addr = 0;
+}
+
+static void bam_dmux_tx_wake_queues(struct bam_dmux *dmux)
+{
+	int i;
+
+	dev_dbg(dmux->dev, "wake queues\n");
+
+	for (i = 0; i < BAM_DMUX_NUM_CH; ++i) {
+		struct net_device *netdev = dmux->netdevs[i];
+
+		if (netdev && netif_running(netdev))
+			netif_wake_queue(netdev);
+	}
+}
+
+static void bam_dmux_tx_stop_queues(struct bam_dmux *dmux)
+{
+	int i;
+
+	dev_dbg(dmux->dev, "stop queues\n");
+
+	for (i = 0; i < BAM_DMUX_NUM_CH; ++i) {
+		struct net_device *netdev = dmux->netdevs[i];
+
+		if (netdev)
+			netif_stop_queue(netdev);
+	}
+}
+
+static void bam_dmux_tx_done(struct bam_dmux_skb_dma *skb_dma)
+{
+	struct bam_dmux *dmux = skb_dma->dmux;
+	unsigned long flags;
+
+	pm_runtime_mark_last_busy(dmux->dev);
+	pm_runtime_put_autosuspend(dmux->dev);
+
+	if (skb_dma->addr)
+		bam_dmux_skb_dma_unmap(skb_dma, DMA_TO_DEVICE);
+
+	spin_lock_irqsave(&dmux->tx_lock, flags);
+	skb_dma->skb = NULL;
+	if (skb_dma == &dmux->tx_skbs[dmux->tx_next_skb % BAM_DMUX_NUM_SKB])
+		bam_dmux_tx_wake_queues(dmux);
+	spin_unlock_irqrestore(&dmux->tx_lock, flags);
+}
+
+static void bam_dmux_tx_callback(void *data)
+{
+	struct bam_dmux_skb_dma *skb_dma = data;
+	struct sk_buff *skb = skb_dma->skb;
+
+	bam_dmux_tx_done(skb_dma);
+	dev_consume_skb_any(skb);
+}
+
+static bool bam_dmux_skb_dma_submit_tx(struct bam_dmux_skb_dma *skb_dma)
+{
+	struct bam_dmux *dmux = skb_dma->dmux;
+	struct dma_async_tx_descriptor *desc;
+
+	desc = dmaengine_prep_slave_single(dmux->tx, skb_dma->addr,
+					   skb_dma->skb->len, DMA_MEM_TO_DEV,
+					   DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(dmux->dev, "Failed to prepare TX DMA buffer\n");
+		return false;
+	}
+
+	desc->callback = bam_dmux_tx_callback;
+	desc->callback_param = skb_dma;
+	desc->cookie = dmaengine_submit(desc);
+	return true;
+}
+
+static struct bam_dmux_skb_dma *
+bam_dmux_tx_queue(struct bam_dmux *dmux, struct sk_buff *skb)
+{
+	struct bam_dmux_skb_dma *skb_dma;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmux->tx_lock, flags);
+
+	skb_dma = &dmux->tx_skbs[dmux->tx_next_skb % BAM_DMUX_NUM_SKB];
+	if (skb_dma->skb) {
+		bam_dmux_tx_stop_queues(dmux);
+		spin_unlock_irqrestore(&dmux->tx_lock, flags);
+		return NULL;
+	}
+	skb_dma->skb = skb;
+
+	dmux->tx_next_skb++;
+	if (dmux->tx_skbs[dmux->tx_next_skb % BAM_DMUX_NUM_SKB].skb)
+		bam_dmux_tx_stop_queues(dmux);
+
+	spin_unlock_irqrestore(&dmux->tx_lock, flags);
+	return skb_dma;
+}
+
+static int bam_dmux_send_cmd(struct bam_dmux_netdev *bndev, u8 cmd)
+{
+	struct bam_dmux *dmux = bndev->dmux;
+	struct bam_dmux_skb_dma *skb_dma;
+	struct bam_dmux_hdr *hdr;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = alloc_skb(sizeof(*hdr), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	hdr = skb_put_zero(skb, sizeof(*hdr));
+	hdr->magic = BAM_DMUX_HDR_MAGIC;
+	hdr->cmd = cmd;
+	hdr->ch = bndev->ch;
+
+	skb_dma = bam_dmux_tx_queue(dmux, skb);
+	if (!skb_dma) {
+		ret = -EAGAIN;
+		goto free_skb;
+	}
+
+	ret = pm_runtime_get_sync(dmux->dev);
+	if (ret < 0)
+		goto tx_fail;
+
+	if (!bam_dmux_skb_dma_map(skb_dma, DMA_TO_DEVICE)) {
+		ret = -ENOMEM;
+		goto tx_fail;
+	}
+
+	if (!bam_dmux_skb_dma_submit_tx(skb_dma)) {
+		ret = -EIO;
+		goto tx_fail;
+	}
+
+	dma_async_issue_pending(dmux->tx);
+	return 0;
+
+tx_fail:
+	bam_dmux_tx_done(skb_dma);
+free_skb:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+static int bam_dmux_netdev_open(struct net_device *netdev)
+{
+	struct bam_dmux_netdev *bndev = netdev_priv(netdev);
+	int ret;
+
+	ret = bam_dmux_send_cmd(bndev, BAM_DMUX_CMD_OPEN);
+	if (ret)
+		return ret;
+
+	netif_start_queue(netdev);
+	return 0;
+}
+
+static int bam_dmux_netdev_stop(struct net_device *netdev)
+{
+	struct bam_dmux_netdev *bndev = netdev_priv(netdev);
+
+	netif_stop_queue(netdev);
+	bam_dmux_send_cmd(bndev, BAM_DMUX_CMD_CLOSE);
+	return 0;
+}
+
+static unsigned int needed_room(unsigned int avail, unsigned int needed)
+{
+	if (avail >= needed)
+		return 0;
+	return needed - avail;
+}
+
+static int bam_dmux_tx_prepare_skb(struct bam_dmux_netdev *bndev,
+				   struct sk_buff *skb)
+{
+	unsigned int head = needed_room(skb_headroom(skb), BAM_DMUX_HDR_SIZE);
+	unsigned int pad = sizeof(u32) - skb->len % sizeof(u32);
+	unsigned int tail = needed_room(skb_tailroom(skb), pad);
+	struct bam_dmux_hdr *hdr;
+	int ret;
+
+	if (head || tail || skb_cloned(skb)) {
+		ret = pskb_expand_head(skb, head, tail, GFP_ATOMIC);
+		if (ret)
+			return ret;
+	}
+
+	hdr = skb_push(skb, sizeof(*hdr));
+	hdr->magic = BAM_DMUX_HDR_MAGIC;
+	hdr->signal = 0;
+	hdr->cmd = BAM_DMUX_CMD_DATA;
+	hdr->pad = pad;
+	hdr->ch = bndev->ch;
+	hdr->len = skb->len - sizeof(*hdr);
+	if (pad)
+		skb_put_zero(skb, pad);
+
+	return 0;
+}
+
+static netdev_tx_t bam_dmux_netdev_start_xmit(struct sk_buff *skb,
+					      struct net_device *netdev)
+{
+	struct bam_dmux_netdev *bndev = netdev_priv(netdev);
+	struct bam_dmux *dmux = bndev->dmux;
+	struct bam_dmux_skb_dma *skb_dma;
+	int active, ret;
+
+	skb_dma = bam_dmux_tx_queue(dmux, skb);
+	if (!skb_dma)
+		return NETDEV_TX_BUSY;
+
+	active = pm_runtime_get(dmux->dev);
+	if (active < 0 && active != -EINPROGRESS)
+		goto drop;
+
+	ret = bam_dmux_tx_prepare_skb(bndev, skb);
+	if (ret)
+		goto drop;
+
+	if (!bam_dmux_skb_dma_map(skb_dma, DMA_TO_DEVICE))
+		goto drop;
+
+	if (active <= 0) {
+		/* Cannot sleep here so mark skb for wakeup handler and return */
+		if (!atomic_long_fetch_or(BIT(skb_dma - dmux->tx_skbs),
+					  &dmux->tx_deferred_skb))
+			queue_pm_work(&dmux->tx_wakeup_work);
+		return NETDEV_TX_OK;
+	}
+
+	if (!bam_dmux_skb_dma_submit_tx(skb_dma))
+		goto drop;
+
+	dma_async_issue_pending(dmux->tx);
+	return NETDEV_TX_OK;
+
+drop:
+	bam_dmux_tx_done(skb_dma);
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static void bam_dmux_tx_wakeup_work(struct work_struct *work)
+{
+	struct bam_dmux *dmux = container_of(work, struct bam_dmux, tx_wakeup_work);
+	unsigned long pending;
+	int ret, i;
+
+	ret = pm_runtime_resume_and_get(dmux->dev);
+	if (ret < 0) {
+		dev_err(dmux->dev, "Failed to resume: %d\n", ret);
+		return;
+	}
+
+	pending = atomic_long_xchg(&dmux->tx_deferred_skb, 0);
+	if (!pending)
+		goto out;
+
+	dev_dbg(dmux->dev, "pending skbs after wakeup: %#lx\n", pending);
+	for_each_set_bit(i, &pending, BAM_DMUX_NUM_SKB) {
+		bam_dmux_skb_dma_submit_tx(&dmux->tx_skbs[i]);
+	}
+	dma_async_issue_pending(dmux->tx);
+
+out:
+	pm_runtime_mark_last_busy(dmux->dev);
+	pm_runtime_put_autosuspend(dmux->dev);
+}
+
+static const struct net_device_ops bam_dmux_ops = {
+	.ndo_open	= bam_dmux_netdev_open,
+	.ndo_stop	= bam_dmux_netdev_stop,
+	.ndo_start_xmit	= bam_dmux_netdev_start_xmit,
+};
+
+static const struct device_type wwan_type = {
+	.name = "wwan",
+};
+
+static void bam_dmux_netdev_setup(struct net_device *dev)
+{
+	dev->netdev_ops = &bam_dmux_ops;
+
+	dev->type = ARPHRD_RAWIP;
+	SET_NETDEV_DEVTYPE(dev, &wwan_type);
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP;
+
+	dev->mtu = ETH_DATA_LEN;
+	dev->max_mtu = BAM_DMUX_MAX_DATA_SIZE;
+	dev->needed_headroom = sizeof(struct bam_dmux_hdr);
+	dev->needed_tailroom = sizeof(u32); /* word-aligned */
+	dev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;
+
+	/* This perm addr will be used as interface identifier by IPv6 */
+	dev->addr_assign_type = NET_ADDR_RANDOM;
+	eth_random_addr(dev->perm_addr);
+}
+
+static void bam_dmux_register_netdev_work(struct work_struct *work)
+{
+	struct bam_dmux *dmux = container_of(work, struct bam_dmux, register_netdev_work);
+	struct bam_dmux_netdev *bndev;
+	struct net_device *netdev;
+	int ch, ret;
+
+	for_each_set_bit(ch, dmux->remote_channels, BAM_DMUX_NUM_CH) {
+		if (dmux->netdevs[ch])
+			continue;
+
+		netdev = alloc_netdev(sizeof(*bndev), "wwan%d", NET_NAME_ENUM,
+				      bam_dmux_netdev_setup);
+		if (!netdev)
+			return;
+
+		SET_NETDEV_DEV(netdev, dmux->dev);
+		netdev->dev_port = ch;
+
+		bndev = netdev_priv(netdev);
+		bndev->dmux = dmux;
+		bndev->ch = ch;
+
+		ret = register_netdev(netdev);
+		if (ret) {
+			dev_err(dmux->dev, "Failed to register netdev for channel %u: %d\n",
+				ch, ret);
+			free_netdev(netdev);
+			return;
+		}
+
+		dmux->netdevs[ch] = netdev;
+	}
+}
+
+static void bam_dmux_rx_callback(void *data);
+
+static bool bam_dmux_skb_dma_submit_rx(struct bam_dmux_skb_dma *skb_dma)
+{
+	struct bam_dmux *dmux = skb_dma->dmux;
+	struct dma_async_tx_descriptor *desc;
+
+	desc = dmaengine_prep_slave_single(dmux->rx, skb_dma->addr,
+					   skb_dma->skb->len, DMA_DEV_TO_MEM,
+					   DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(dmux->dev, "Failed to prepare RX DMA buffer\n");
+		return false;
+	}
+
+	desc->callback = bam_dmux_rx_callback;
+	desc->callback_param = skb_dma;
+	desc->cookie = dmaengine_submit(desc);
+	return true;
+}
+
+static bool bam_dmux_skb_dma_queue_rx(struct bam_dmux_skb_dma *skb_dma, gfp_t gfp)
+{
+	if (!skb_dma->skb) {
+		skb_dma->skb = __netdev_alloc_skb(NULL, BAM_DMUX_BUFFER_SIZE, gfp);
+		if (!skb_dma->skb)
+			return false;
+		skb_put(skb_dma->skb, BAM_DMUX_BUFFER_SIZE);
+	}
+
+	return bam_dmux_skb_dma_map(skb_dma, DMA_FROM_DEVICE) &&
+	       bam_dmux_skb_dma_submit_rx(skb_dma);
+}
+
+static void bam_dmux_cmd_data(struct bam_dmux_skb_dma *skb_dma)
+{
+	struct bam_dmux *dmux = skb_dma->dmux;
+	struct sk_buff *skb = skb_dma->skb;
+	struct bam_dmux_hdr *hdr = (struct bam_dmux_hdr *)skb->data;
+	struct net_device *netdev = dmux->netdevs[hdr->ch];
+
+	if (!netdev || !netif_running(netdev)) {
+		dev_warn(dmux->dev, "Data for inactive channel %u\n", hdr->ch);
+		return;
+	}
+
+	if (hdr->len > BAM_DMUX_MAX_DATA_SIZE) {
+		dev_err(dmux->dev, "Data larger than buffer? (%u > %u)\n",
+			hdr->len, (u16)BAM_DMUX_MAX_DATA_SIZE);
+		return;
+	}
+
+	skb_dma->skb = NULL; /* Hand over to network stack */
+
+	skb_pull(skb, sizeof(*hdr));
+	skb_trim(skb, hdr->len);
+	skb->dev = netdev;
+
+	/* Only Raw-IP/QMAP is supported by this driver */
+	switch (skb->data[0] & 0xf0) {
+	case 0x40:
+		skb->protocol = htons(ETH_P_IP);
+		break;
+	case 0x60:
+		skb->protocol = htons(ETH_P_IPV6);
+		break;
+	default:
+		skb->protocol = htons(ETH_P_MAP);
+		break;
+	}
+
+	netif_receive_skb(skb);
+}
+
+static void bam_dmux_cmd_open(struct bam_dmux *dmux, struct bam_dmux_hdr *hdr)
+{
+	struct net_device *netdev = dmux->netdevs[hdr->ch];
+
+	dev_dbg(dmux->dev, "open channel: %u\n", hdr->ch);
+
+	if (__test_and_set_bit(hdr->ch, dmux->remote_channels)) {
+		dev_warn(dmux->dev, "Channel already open: %u\n", hdr->ch);
+		return;
+	}
+
+	if (netdev) {
+		netif_device_attach(netdev);
+	} else {
+		/* Cannot sleep here, schedule work to register the netdev */
+		schedule_work(&dmux->register_netdev_work);
+	}
+}
+
+static void bam_dmux_cmd_close(struct bam_dmux *dmux, struct bam_dmux_hdr *hdr)
+{
+	struct net_device *netdev = dmux->netdevs[hdr->ch];
+
+	dev_dbg(dmux->dev, "close channel: %u\n", hdr->ch);
+
+	if (!__test_and_clear_bit(hdr->ch, dmux->remote_channels)) {
+		dev_err(dmux->dev, "Channel not open: %u\n", hdr->ch);
+		return;
+	}
+
+	if (netdev)
+		netif_device_detach(netdev);
+}
+
+static void bam_dmux_rx_callback(void *data)
+{
+	struct bam_dmux_skb_dma *skb_dma = data;
+	struct bam_dmux *dmux = skb_dma->dmux;
+	struct sk_buff *skb = skb_dma->skb;
+	struct bam_dmux_hdr *hdr = (struct bam_dmux_hdr *)skb->data;
+
+	bam_dmux_skb_dma_unmap(skb_dma, DMA_FROM_DEVICE);
+
+	if (hdr->magic != BAM_DMUX_HDR_MAGIC) {
+		dev_err(dmux->dev, "Invalid magic in header: %#x\n", hdr->magic);
+		goto out;
+	}
+
+	if (hdr->ch >= BAM_DMUX_NUM_CH) {
+		dev_dbg(dmux->dev, "Unsupported channel: %u\n", hdr->ch);
+		goto out;
+	}
+
+	switch (hdr->cmd) {
+	case BAM_DMUX_CMD_DATA:
+		bam_dmux_cmd_data(skb_dma);
+		break;
+	case BAM_DMUX_CMD_OPEN:
+		bam_dmux_cmd_open(dmux, hdr);
+		break;
+	case BAM_DMUX_CMD_CLOSE:
+		bam_dmux_cmd_close(dmux, hdr);
+		break;
+	default:
+		dev_err(dmux->dev, "Unsupported command %u on channel %u\n",
+			hdr->cmd, hdr->ch);
+		break;
+	}
+
+out:
+	if (bam_dmux_skb_dma_queue_rx(skb_dma, GFP_ATOMIC))
+		dma_async_issue_pending(dmux->rx);
+}
+
+static bool bam_dmux_power_on(struct bam_dmux *dmux)
+{
+	struct device *dev = dmux->dev;
+	struct dma_slave_config dma_rx_conf = {
+		.direction = DMA_DEV_TO_MEM,
+		.src_maxburst = BAM_DMUX_BUFFER_SIZE,
+	};
+	int i;
+
+	dmux->rx = dma_request_chan(dev, "rx");
+	if (IS_ERR(dmux->rx)) {
+		dev_err(dev, "Failed to request RX DMA channel: %pe\n", dmux->rx);
+		dmux->rx = NULL;
+		return false;
+	}
+	dmaengine_slave_config(dmux->rx, &dma_rx_conf);
+
+	for (i = 0; i < BAM_DMUX_NUM_SKB; i++) {
+		if (!bam_dmux_skb_dma_queue_rx(&dmux->rx_skbs[i], GFP_KERNEL))
+			return false;
+	}
+	dma_async_issue_pending(dmux->rx);
+
+	return true;
+}
+
+static void bam_dmux_free_skbs(struct bam_dmux_skb_dma skbs[],
+			       enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < BAM_DMUX_NUM_SKB; i++) {
+		struct bam_dmux_skb_dma *skb_dma = &skbs[i];
+
+		if (skb_dma->addr)
+			bam_dmux_skb_dma_unmap(skb_dma, dir);
+		if (skb_dma->skb) {
+			dev_kfree_skb(skb_dma->skb);
+			skb_dma->skb = NULL;
+		}
+	}
+}
+
+static void bam_dmux_power_off(struct bam_dmux *dmux)
+{
+	if (dmux->tx) {
+		dmaengine_terminate_sync(dmux->tx);
+		dma_release_channel(dmux->tx);
+		dmux->tx = NULL;
+	}
+
+	if (dmux->rx) {
+		dmaengine_terminate_sync(dmux->rx);
+		dma_release_channel(dmux->rx);
+		dmux->rx = NULL;
+	}
+
+	bam_dmux_free_skbs(dmux->rx_skbs, DMA_FROM_DEVICE);
+}
+
+static irqreturn_t bam_dmux_pc_irq(int irq, void *data)
+{
+	struct bam_dmux *dmux = data;
+	bool new_state = !dmux->pc_state;
+
+	dev_dbg(dmux->dev, "pc: %u\n", new_state);
+
+	if (new_state) {
+		if (bam_dmux_power_on(dmux))
+			bam_dmux_pc_ack(dmux);
+		else
+			bam_dmux_power_off(dmux);
+	} else {
+		bam_dmux_power_off(dmux);
+		bam_dmux_pc_ack(dmux);
+	}
+
+	dmux->pc_state = new_state;
+	wake_up_all(&dmux->pc_wait);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t bam_dmux_pc_ack_irq(int irq, void *data)
+{
+	struct bam_dmux *dmux = data;
+
+	dev_dbg(dmux->dev, "pc ack\n");
+	complete_all(&dmux->pc_ack_completion);
+
+	return IRQ_HANDLED;
+}
+
+static int bam_dmux_runtime_suspend(struct device *dev)
+{
+	struct bam_dmux *dmux = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "runtime suspend\n");
+	bam_dmux_pc_vote(dmux, false);
+
+	return 0;
+}
+
+static int __maybe_unused bam_dmux_runtime_resume(struct device *dev)
+{
+	struct bam_dmux *dmux = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "runtime resume\n");
+
+	/* Wait until previous power down was acked */
+	if (!wait_for_completion_timeout(&dmux->pc_ack_completion,
+					 BAM_DMUX_REMOTE_TIMEOUT))
+		return -ETIMEDOUT;
+
+	/* Vote for power state */
+	bam_dmux_pc_vote(dmux, true);
+
+	/* Wait for ack */
+	if (!wait_for_completion_timeout(&dmux->pc_ack_completion,
+					 BAM_DMUX_REMOTE_TIMEOUT)) {
+		bam_dmux_pc_vote(dmux, false);
+		return -ETIMEDOUT;
+	}
+
+	/* Wait until we're up */
+	if (!wait_event_timeout(dmux->pc_wait, dmux->pc_state,
+				BAM_DMUX_REMOTE_TIMEOUT)) {
+		bam_dmux_pc_vote(dmux, false);
+		return -ETIMEDOUT;
+	}
+
+	/* Ensure that we actually initialized successfully */
+	if (!dmux->rx) {
+		bam_dmux_pc_vote(dmux, false);
+		return -ENXIO;
+	}
+
+	/* Request TX channel if necessary */
+	if (dmux->tx)
+		return 0;
+
+	dmux->tx = dma_request_chan(dev, "tx");
+	if (IS_ERR(dmux->rx)) {
+		dev_err(dev, "Failed to request TX DMA channel: %pe\n", dmux->tx);
+		dmux->tx = NULL;
+		bam_dmux_runtime_suspend(dev);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int bam_dmux_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct bam_dmux *dmux;
+	int ret, pc_ack_irq, i;
+	unsigned int bit;
+
+	dmux = devm_kzalloc(dev, sizeof(*dmux), GFP_KERNEL);
+	if (!dmux)
+		return -ENOMEM;
+
+	dmux->dev = dev;
+	platform_set_drvdata(pdev, dmux);
+
+	dmux->pc_irq = platform_get_irq_byname(pdev, "pc");
+	if (dmux->pc_irq < 0)
+		return dmux->pc_irq;
+
+	pc_ack_irq = platform_get_irq_byname(pdev, "pc-ack");
+	if (pc_ack_irq < 0)
+		return pc_ack_irq;
+
+	dmux->pc = devm_qcom_smem_state_get(dev, "pc", &bit);
+	if (IS_ERR(dmux->pc))
+		return dev_err_probe(dev, PTR_ERR(dmux->pc),
+				     "Failed to get pc state\n");
+	dmux->pc_mask = BIT(bit);
+
+	dmux->pc_ack = devm_qcom_smem_state_get(dev, "pc-ack", &bit);
+	if (IS_ERR(dmux->pc_ack))
+		return dev_err_probe(dev, PTR_ERR(dmux->pc_ack),
+				     "Failed to get pc-ack state\n");
+	dmux->pc_ack_mask = BIT(bit);
+
+	init_waitqueue_head(&dmux->pc_wait);
+	init_completion(&dmux->pc_ack_completion);
+	complete_all(&dmux->pc_ack_completion);
+
+	spin_lock_init(&dmux->tx_lock);
+	INIT_WORK(&dmux->tx_wakeup_work, bam_dmux_tx_wakeup_work);
+	INIT_WORK(&dmux->register_netdev_work, bam_dmux_register_netdev_work);
+
+	for (i = 0; i < BAM_DMUX_NUM_SKB; i++) {
+		dmux->rx_skbs[i].dmux = dmux;
+		dmux->tx_skbs[i].dmux = dmux;
+	}
+
+	/* Runtime PM manages our own power vote.
+	 * Note that the RX path may be active even if we are runtime suspended,
+	 * since it is controlled by the remote side.
+	 */
+	pm_runtime_set_autosuspend_delay(dev, BAM_DMUX_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_enable(dev);
+
+	ret = devm_request_threaded_irq(dev, pc_ack_irq, NULL, bam_dmux_pc_ack_irq,
+					IRQF_ONESHOT, NULL, dmux);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, dmux->pc_irq, NULL, bam_dmux_pc_irq,
+					IRQF_ONESHOT, NULL, dmux);
+	if (ret)
+		return ret;
+
+	ret = irq_get_irqchip_state(dmux->pc_irq, IRQCHIP_STATE_LINE_LEVEL,
+				    &dmux->pc_state);
+	if (ret)
+		return ret;
+
+	/* Check if remote finished initialization before us */
+	if (dmux->pc_state) {
+		if (bam_dmux_power_on(dmux))
+			bam_dmux_pc_ack(dmux);
+		else
+			bam_dmux_power_off(dmux);
+	}
+
+	return 0;
+}
+
+static int bam_dmux_remove(struct platform_device *pdev)
+{
+	struct bam_dmux *dmux = platform_get_drvdata(pdev);
+	struct device *dev = dmux->dev;
+	LIST_HEAD(list);
+	int i;
+
+	/* Unregister network interfaces */
+	cancel_work_sync(&dmux->register_netdev_work);
+	rtnl_lock();
+	for (i = 0; i < BAM_DMUX_NUM_CH; ++i)
+		if (dmux->netdevs[i])
+			unregister_netdevice_queue(dmux->netdevs[i], &list);
+	unregister_netdevice_many(&list);
+	rtnl_unlock();
+	cancel_work_sync(&dmux->tx_wakeup_work);
+
+	/* Drop our own power vote */
+	pm_runtime_disable(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+	bam_dmux_runtime_suspend(dev);
+	pm_runtime_set_suspended(dev);
+
+	/* Try to wait for remote side to drop power vote */
+	if (!wait_event_timeout(dmux->pc_wait, !dmux->rx, BAM_DMUX_REMOTE_TIMEOUT))
+		dev_err(dev, "Timed out waiting for remote side to suspend\n");
+
+	/* Make sure everything is cleaned up before we return */
+	disable_irq(dmux->pc_irq);
+	bam_dmux_power_off(dmux);
+	bam_dmux_free_skbs(dmux->tx_skbs, DMA_TO_DEVICE);
+
+	return 0;
+}
+
+static const struct dev_pm_ops bam_dmux_pm_ops = {
+	SET_RUNTIME_PM_OPS(bam_dmux_runtime_suspend, bam_dmux_runtime_resume, NULL)
+};
+
+static const struct of_device_id bam_dmux_of_match[] = {
+	{ .compatible = "qcom,bam-dmux" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, bam_dmux_of_match);
+
+static struct platform_driver bam_dmux_driver = {
+	.probe = bam_dmux_probe,
+	.remove = bam_dmux_remove,
+	.driver = {
+		.name = "bam-dmux",
+		.pm = &bam_dmux_pm_ops,
+		.of_match_table = bam_dmux_of_match,
+	},
+};
+module_platform_driver(bam_dmux_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Qualcomm BAM-DMUX WWAN Network Driver");
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index fcc7534edcb..ae258a65ef2 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -602,6 +602,36 @@ config CHARGER_QCOM_SMBB
 	  documentation for more detail.  The base name for this driver is
 	  'pm8941_charger'.
 
+config SMB1360
+	tristate "Qualcomm SMB1360 charger and fuel gauge"
+	depends on I2C
+	depends on OF
+	select REGMAP_I2C
+	help
+	  Say Y to enable support for Qualcomm SMB1360 charger and fuel gauge.
+
+config SMB1360_DEBUG
+	bool "Dump SMB1360 registers before/after driver initialization"
+	depends on SMB1360
+
+config BATTERY_PM8916_BMS_VM
+        tristate "Qualcomm PM8916 BMS-VM support"
+        depends on MFD_SPMI_PMIC || COMPILE_TEST
+        help
+          This driver adds support for pm8916 BMS-VM
+
+          To compile this driver as module, choose M here: the
+          module will be called pm8916_bms_vm.
+
+config CHARGER_PM8916_LBC
+        tristate "Qualcomm PM8916 Linear Battery Charger support"
+        depends on MFD_SPMI_PMIC || COMPILE_TEST
+        help
+          This driver adds support for pm8916 LBC
+
+          To compile this driver as module, choose M here: the
+          module will be called pm8916_lbc.
+
 config CHARGER_BQ2415X
 	tristate "TI BQ2415x battery charger driver"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 4e55a11aab7..98a4318b43a 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -80,6 +80,11 @@ obj-$(CONFIG_CHARGER_MAX8998)	+= max8998_charger.o
 obj-$(CONFIG_CHARGER_MP2629)	+= mp2629_charger.o
 obj-$(CONFIG_CHARGER_MT6360)	+= mt6360_charger.o
 obj-$(CONFIG_CHARGER_QCOM_SMBB)	+= qcom_smbb.o
+smb1360-y			:= smb1360-driver.o
+smb1360-$(CONFIG_SMB1360_DEBUG)	+= smb1360-dump.o
+obj-$(CONFIG_SMB1360)		+= smb1360.o
+obj-$(CONFIG_BATTERY_PM8916_BMS_VM)	+= pm8916_bms_vm.o
+obj-$(CONFIG_CHARGER_PM8916_LBC)	+= pm8916_lbc.o
 obj-$(CONFIG_CHARGER_BQ2415X)	+= bq2415x_charger.o
 obj-$(CONFIG_CHARGER_BQ24190)	+= bq24190_charger.o
 obj-$(CONFIG_CHARGER_BQ24257)	+= bq24257_charger.o
diff --git a/drivers/power/supply/pm8916_bms_vm.c b/drivers/power/supply/pm8916_bms_vm.c
new file mode 100644
index 00000000000..c4051c03c0b
--- /dev/null
+++ b/drivers/power/supply/pm8916_bms_vm.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#define PM8916_PERPH_TYPE 0x04
+#define PM8916_BMS_VM_TYPE 0x020D
+
+#define PM8916_SEC_ACCESS 0xD0
+#define PM8916_SEC_MAGIC 0xA5
+
+#define PM8916_BMS_VM_STATUS1 0x08
+#define PM8916_BMS_VM_FSM_STATE(x) (((x) & 0b00111000) >> 3)
+#define PM8916_BMS_VM_FSM_STATE_S2 0x2
+
+#define PM8916_BMS_VM_MODE_CTL 0x40
+#define PM8916_BMS_VM_MODE_FORCE_S3 (BIT(0) | BIT(1))
+#define PM8916_BMS_VM_MODE_NORMAL (BIT(1) | BIT(3))
+
+#define PM8916_BMS_VM_EN_CTL 0x46
+#define PM8916_BMS_ENABLED BIT(7)
+
+#define PM8916_BMS_VM_FIFO_LENGTH_CTL 0x47
+#define PM8916_BMS_VM_S1_SAMPLE_INTERVAL_CTL 0x55
+#define PM8916_BMS_VM_S2_SAMPLE_INTERVAL_CTL 0x56
+#define PM8916_BMS_VM_S3_S7_OCV_DATA0 0x6A
+#define PM8916_BMS_VM_BMS_FIFO_REG_0_LSB 0xC0
+
+// NOTE: downstream has a comment saying that using 1 fifo is broken in hardware
+#define PM8916_BMS_VM_FIFO_COUNT 2 // 2 .. 8
+
+#define PM8916_BMS_VM_S1_SAMPLE_INTERVAL 10
+#define PM8916_BMS_VM_S2_SAMPLE_INTERVAL 10
+
+struct pm8916_bms_vm_battery {
+	struct device *dev;
+	struct power_supply_desc desc;
+	struct power_supply *battery;
+	struct power_supply_battery_info info;
+	struct regmap *regmap;
+	unsigned int reg;
+	unsigned int boot_ocv;
+	unsigned int last_ocv;
+	unsigned int fake_ocv;
+	unsigned int vbat_now;
+};
+
+static int pm8916_bms_vm_battery_get_property(struct power_supply *psy,
+					      enum power_supply_property psp,
+					      union power_supply_propval *val)
+{
+	struct pm8916_bms_vm_battery *bat = power_supply_get_drvdata(psy);
+	struct power_supply_battery_info *info = &bat->info;
+	int supplied;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		supplied = power_supply_am_i_supplied(psy);
+
+		if (supplied < 0 && supplied != -ENODEV) {
+			return supplied;
+		} else if (supplied && supplied != -ENODEV) {
+			if (power_supply_batinfo_ocv2cap(info, bat->fake_ocv, 20) > 98)
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+			else
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		} else {
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+		return 0;
+
+	case POWER_SUPPLY_PROP_HEALTH:
+		if (bat->vbat_now < info->voltage_min_design_uv)
+			val->intval = POWER_SUPPLY_HEALTH_DEAD;
+		else if (bat->vbat_now > info->voltage_max_design_uv)
+			val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = power_supply_batinfo_ocv2cap(info, bat->fake_ocv, 20);
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = bat->vbat_now;
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_BOOT:
+		// NOTE Returning last known ocv value here - it changes after suspend
+		val->intval = bat->last_ocv;
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		val->intval = bat->fake_ocv;
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = info->voltage_min_design_uv;
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = info->voltage_max_design_uv;
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static enum power_supply_property pm8916_bms_vm_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_BOOT,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+};
+
+static irqreturn_t pm8916_bms_vm_fifo_update_done_irq(int irq, void *data)
+{
+	struct pm8916_bms_vm_battery *bat = data;
+	struct power_supply_battery_info *info = &bat->info;
+	u16 vbat_data[PM8916_BMS_VM_FIFO_COUNT];
+	int i, ret, delta = 0, loc_delta;
+	unsigned int tmp = 0;
+	int supplied;
+
+	ret = regmap_bulk_read(bat->regmap, bat->reg + PM8916_BMS_VM_BMS_FIFO_REG_0_LSB,
+			       &vbat_data, PM8916_BMS_VM_FIFO_COUNT * 2);
+	if (ret)
+		return IRQ_HANDLED;
+
+	supplied = power_supply_am_i_supplied(bat->battery);
+	// We assume that we don't charge if no charger is present.
+	if (supplied == -ENODEV)
+		supplied = 0;
+	else if (supplied < 0)
+		return IRQ_HANDLED;
+
+	for (i = 0; i < PM8916_BMS_VM_FIFO_COUNT; i++) {
+		tmp = vbat_data[i] * 300 - 100000;
+
+		loc_delta = tmp - bat->vbat_now;
+		delta += loc_delta;
+		bat->vbat_now = tmp;
+	}
+
+	/*
+	 * NOTE: Since VM-BMS is mostly implemented in software, OCV needs to be estimated.
+	 * This driver makes some assumptions to estimate OCV from averaged VBAT measurements
+	 * and initial OCV measurements taken on boot or while in suspend:
+	 *
+	 *  - When charger is online, ocv can only increase.
+	 *  - When charger is offline, ocv can only decrease and ocv > vbat.
+	 *  - ocv can't change more than 0.025v between the measurements.
+	 *  - When charger is in CV mode (vbat = const vbat-max), ocv increases by
+	 *    0.004v every measurement until it reaches vbat.
+	 *
+	 * Those assumptions give somewhat realistic estimation of ocv and capacity, though
+	 * in some worst case scenarios it will perform poorly.
+	 * Ideally proper BMS algorithm should be implemented in userspace.
+	 */
+
+	if ((supplied && delta > 0) || (!supplied && delta < 0))
+		if (abs(delta) < 25000) /* 0.025v */
+			bat->fake_ocv += delta;
+
+	if (!supplied && bat->fake_ocv < bat->vbat_now)
+		bat->fake_ocv = bat->vbat_now;
+
+	regmap_write(bat->regmap, bat->reg + PM8916_BMS_VM_STATUS1, 0);
+	regmap_read(bat->regmap, bat->reg + PM8916_BMS_VM_STATUS1, &tmp);
+
+	if (PM8916_BMS_VM_FSM_STATE(tmp) == PM8916_BMS_VM_FSM_STATE_S2 &&
+	    bat->fake_ocv < bat->vbat_now - 10000 /* 0.01v */) {
+		bat->fake_ocv += 4000; /* 0.004v */
+	}
+
+	if (supplied && bat->fake_ocv > info->voltage_max_design_uv)
+		bat->fake_ocv = info->voltage_max_design_uv;
+
+	power_supply_changed(bat->battery);
+
+	return IRQ_HANDLED;
+}
+
+static int pm8916_bms_vm_battery_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pm8916_bms_vm_battery *bat;
+	struct power_supply_config psy_cfg = {};
+	struct power_supply_desc *desc;
+	int ret, irq;
+	unsigned int tmp;
+
+	bat = devm_kzalloc(dev, sizeof(*bat), GFP_KERNEL);
+	if (!bat)
+		return -ENOMEM;
+
+	bat->dev = dev;
+
+	bat->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!bat->regmap)
+		return -ENODEV;
+
+	of_property_read_u32(dev->of_node, "reg", &bat->reg);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_threaded_irq(dev, irq, NULL, pm8916_bms_vm_fifo_update_done_irq,
+					IRQF_ONESHOT, "pm8916_vm_bms", bat);
+	if (ret)
+		return ret;
+
+	ret = regmap_bulk_read(bat->regmap, bat->reg + PM8916_PERPH_TYPE, &tmp, 2);
+	if (ret)
+		goto comm_error;
+
+	if (tmp != PM8916_BMS_VM_TYPE) {
+		dev_err(dev, "Device reported wrong type: 0x%X\n", tmp);
+		return -ENODEV;
+	}
+
+	ret = regmap_write(bat->regmap, bat->reg + PM8916_BMS_VM_S1_SAMPLE_INTERVAL_CTL,
+			   PM8916_BMS_VM_S1_SAMPLE_INTERVAL);
+	if (ret)
+		goto comm_error;
+	ret = regmap_write(bat->regmap, bat->reg + PM8916_BMS_VM_S2_SAMPLE_INTERVAL_CTL,
+			   PM8916_BMS_VM_S2_SAMPLE_INTERVAL);
+	if (ret)
+		goto comm_error;
+	ret = regmap_write(bat->regmap, bat->reg + PM8916_BMS_VM_FIFO_LENGTH_CTL,
+			   PM8916_BMS_VM_FIFO_COUNT << 4 | PM8916_BMS_VM_FIFO_COUNT);
+	if (ret)
+		goto comm_error;
+	ret = regmap_write(bat->regmap,
+			   bat->reg + PM8916_BMS_VM_EN_CTL, PM8916_BMS_ENABLED);
+	if (ret)
+		goto comm_error;
+
+	ret = regmap_bulk_read(bat->regmap,
+			       bat->reg + PM8916_BMS_VM_S3_S7_OCV_DATA0, &tmp, 2);
+	if (ret)
+		goto comm_error;
+
+	bat->boot_ocv = tmp * 300;
+	bat->last_ocv = bat->boot_ocv;
+	bat->fake_ocv = bat->boot_ocv;
+	bat->vbat_now = bat->boot_ocv;
+
+	desc = &bat->desc;
+	desc->name = "pm8916-bms-vm";
+	desc->type = POWER_SUPPLY_TYPE_BATTERY;
+	desc->properties = pm8916_bms_vm_battery_properties;
+	desc->num_properties = ARRAY_SIZE(pm8916_bms_vm_battery_properties);
+	desc->get_property = pm8916_bms_vm_battery_get_property;
+	psy_cfg.drv_data = bat;
+	psy_cfg.of_node = dev->of_node;
+
+	bat->battery = devm_power_supply_register(dev, desc, &psy_cfg);
+	if (IS_ERR(bat->battery)) {
+		if (PTR_ERR(bat->battery) != -EPROBE_DEFER)
+			dev_err(dev, "Unable to register battery: %ld\n", PTR_ERR(bat->battery));
+		return PTR_ERR(bat->battery);
+	}
+
+	ret = power_supply_get_battery_info(bat->battery, &bat->info);
+	if (ret) {
+		dev_err(dev, "Unable to get battery info: %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, bat);
+
+	return 0;
+
+comm_error:
+	dev_err(dev, "Unable to communicate with device: %d\n", ret);
+	return ret;
+}
+
+static int pm8916_bms_vm_battery_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pm8916_bms_vm_battery *bat = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = regmap_write(bat->regmap,
+			   bat->reg + PM8916_SEC_ACCESS, PM8916_SEC_MAGIC);
+	if (ret)
+		goto error;
+	ret = regmap_write(bat->regmap,
+			   bat->reg + PM8916_BMS_VM_MODE_CTL, PM8916_BMS_VM_MODE_FORCE_S3);
+	if (ret)
+		goto error;
+
+	return 0;
+
+error:
+	dev_err(bat->dev, "Failed to force S3 mode: %d\n", ret);
+	return ret;
+}
+
+static int pm8916_bms_vm_battery_resume(struct platform_device *pdev)
+{
+	struct pm8916_bms_vm_battery *bat = platform_get_drvdata(pdev);
+	int ret;
+	unsigned int tmp;
+
+	ret = regmap_bulk_read(bat->regmap,
+			       bat->reg + PM8916_BMS_VM_S3_S7_OCV_DATA0, &tmp, 2);
+
+	if (tmp * 300 != bat->last_ocv) {
+		bat->last_ocv = tmp * 300;
+		bat->fake_ocv = bat->last_ocv;
+	}
+
+	ret = regmap_write(bat->regmap,
+			   bat->reg + PM8916_SEC_ACCESS, PM8916_SEC_MAGIC);
+	if (ret)
+		goto error;
+	ret = regmap_write(bat->regmap,
+			   bat->reg + PM8916_BMS_VM_MODE_CTL, PM8916_BMS_VM_MODE_NORMAL);
+	if (ret)
+		goto error;
+
+	return 0;
+
+error:
+	dev_err(bat->dev, "Failed to return normal mode: %d\n", ret);
+	return ret;
+}
+
+static const struct of_device_id pm8916_bms_vm_battery_of_match[] = {
+	{ .compatible = "qcom,pm8916-bms-vm", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pm8916_bms_vm_battery_of_match);
+
+static struct platform_driver pm8916_bms_vm_battery_driver = {
+	.driver = {
+		.name = "pm8916-bms-vm",
+		.of_match_table = of_match_ptr(pm8916_bms_vm_battery_of_match),
+	},
+	.probe = pm8916_bms_vm_battery_probe,
+	.suspend = pm8916_bms_vm_battery_suspend,
+	.resume = pm8916_bms_vm_battery_resume,
+};
+module_platform_driver(pm8916_bms_vm_battery_driver);
+
+MODULE_DESCRIPTION("pm8916 BMS-VM driver");
+MODULE_AUTHOR("Nikita Travkin <nikitos.tr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/pm8916_lbc.c b/drivers/power/supply/pm8916_lbc.c
new file mode 100644
index 00000000000..f7c9644a522
--- /dev/null
+++ b/drivers/power/supply/pm8916_lbc.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/extcon-provider.h>
+
+/* Two bytes: type + subtype */
+#define PM8916_PERPH_TYPE 0x04
+#define PM8916_LBC_CHGR_TYPE 0x1502
+#define PM8916_LBC_BAT_IF_TYPE 0x1602
+#define PM8916_LBC_USB_TYPE 0x1702
+#define PM8916_LBC_MISC_TYPE 0x1802
+
+#define PM8916_LBC_CHGR_CHG_OPTION 0x08
+#define PM8916_LBC_CHGR_PMIC_CHARGER BIT(7)
+
+#define PM8916_LBC_CHGR_CHG_STATUS 0x09
+
+#define PM8916_INT_RT_STS 0x10
+
+#define PM8916_LBC_USB_USBIN_VALID BIT(1)
+
+#define PM8916_LBC_CHGR_VDD_MAX 0x40
+#define PM8916_LBC_CHGR_VDD_SAFE 0x41
+#define PM8916_LBC_CHGR_IBAT_MAX 0x44
+#define PM8916_LBC_CHGR_IBAT_SAFE 0x45
+
+#define PM8916_LBC_CHGR_TCHG_MAX_EN 0x60
+#define PM8916_LBC_CHGR_TCHG_MAX_ENABLED BIT(7)
+#define PM8916_LBC_CHGR_TCHG_MAX 0x61
+
+#define PM8916_LBC_CHGR_CHG_CTRL 0x49
+#define PM8916_LBC_CHGR_CHG_EN BIT(7)
+#define PM8916_LBC_CHGR_PSTG_EN BIT(5)
+
+#define PM8916_LBC_CHGR_MIN_CURRENT 90000
+#define PM8916_LBC_CHGR_MAX_CURRENT 1440000
+
+#define PM8916_LBC_CHGR_MIN_VOLTAGE 4000000
+#define PM8916_LBC_CHGR_MAX_VOLTAGE 4775000
+#define PM8916_LBC_CHGR_VOLTAGE_STEP 25000
+
+#define PM8916_LBC_CHGR_MIN_TIME 4
+#define PM8916_LBC_CHGR_MAX_TIME 256
+
+struct pm8916_lbc_charger {
+	struct device *dev;
+	struct extcon_dev *edev;
+	struct power_supply_desc desc;
+	struct power_supply *charger;
+	struct power_supply_battery_info info;
+	struct regmap *regmap;
+	unsigned int reg[4];
+	unsigned int charge_voltage_max;
+	unsigned int charge_voltage_safe;
+	unsigned int charge_current_max;
+	unsigned int charge_current_safe;
+};
+
+static const unsigned int pm8916_lbc_charger_cable[] = {
+	EXTCON_USB,
+	EXTCON_NONE,
+};
+
+enum {
+	LBC_CHGR = 0,
+	LBC_BAT_IF,
+	LBC_USB,
+	LBC_MISC,
+};
+
+static int pm8916_lbc_charger_enable(struct pm8916_lbc_charger *chg)
+{
+	int ret = 0;
+	unsigned int tmp;
+
+	chg->charge_voltage_max = min_t(u32, max_t(u32, chg->charge_voltage_max,
+					PM8916_LBC_CHGR_MIN_VOLTAGE), chg->charge_voltage_safe);
+
+	tmp = (chg->charge_voltage_max - PM8916_LBC_CHGR_MIN_VOLTAGE);
+	tmp /= PM8916_LBC_CHGR_VOLTAGE_STEP;
+
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_VDD_MAX, tmp);
+	if (ret)
+		goto error;
+
+	chg->charge_current_max = min(chg->charge_current_max, chg->charge_current_safe);
+
+	tmp = max_t(u32, PM8916_LBC_CHGR_MIN_CURRENT,
+		    min_t(u32, chg->charge_current_max, PM8916_LBC_CHGR_MAX_CURRENT));
+
+	tmp = chg->charge_current_safe / PM8916_LBC_CHGR_MIN_CURRENT - 1;
+
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_IBAT_MAX, tmp);
+	if (ret)
+		goto error;
+
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_CHG_CTRL,
+			   PM8916_LBC_CHGR_CHG_EN | PM8916_LBC_CHGR_PSTG_EN);
+	if (ret)
+		goto error;
+
+	return ret;
+
+error:
+	dev_err(chg->dev, "Failed to enable charging: %d\n", ret);
+	return ret;
+}
+
+static int pm8916_lbc_charger_get_property(struct power_supply *psy,
+					   enum power_supply_property psp,
+					   union power_supply_propval *val)
+{
+	struct pm8916_lbc_charger *chg = power_supply_get_drvdata(psy);
+	int ret = 0;
+	unsigned int tmp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = regmap_read(chg->regmap, chg->reg[LBC_USB] + PM8916_INT_RT_STS, &tmp);
+		if (ret)
+			return ret;
+		val->intval = !!(tmp & PM8916_LBC_USB_USBIN_VALID);
+		return 0;
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		val->intval = chg->charge_current_max;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		val->intval = chg->charge_voltage_max;
+		return 0;
+
+	default:
+		return -EINVAL;
+	};
+}
+
+static enum power_supply_property pm8916_lbc_charger_properties[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+};
+
+static irqreturn_t pm8916_lbc_charger_state_changed_irq(int irq, void *data)
+{
+	struct pm8916_lbc_charger *chg = data;
+	unsigned int tmp;
+	int ret;
+
+	power_supply_changed(chg->charger);
+
+	ret = regmap_read(chg->regmap, chg->reg[LBC_USB] + PM8916_INT_RT_STS, &tmp);
+	if (ret)
+		return IRQ_HANDLED;
+	extcon_set_state_sync(chg->edev, EXTCON_USB, !!(tmp & PM8916_LBC_USB_USBIN_VALID));
+
+	return IRQ_HANDLED;
+}
+
+static int pm8916_lbc_charger_probe_dt(struct pm8916_lbc_charger *chg)
+{
+	struct device *dev = chg->dev;
+	struct device_node *np = dev->of_node;
+
+	int ret = 0;
+	unsigned int tmp;
+
+	of_property_read_u32(np, "qcom,vdd-safe", &chg->charge_voltage_safe);
+	if (chg->charge_voltage_safe < PM8916_LBC_CHGR_MIN_VOLTAGE)
+		return -EINVAL;
+
+	chg->charge_voltage_safe = max_t(u32, PM8916_LBC_CHGR_MIN_VOLTAGE, min_t(u32,
+					 PM8916_LBC_CHGR_MAX_VOLTAGE, chg->charge_voltage_safe));
+
+	chg->charge_voltage_max = chg->charge_voltage_safe;
+
+	tmp = (chg->charge_voltage_safe - PM8916_LBC_CHGR_MIN_VOLTAGE);
+	tmp /= PM8916_LBC_CHGR_VOLTAGE_STEP;
+
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_VDD_SAFE, tmp);
+	if (ret)
+		return ret;
+
+	of_property_read_u32(np, "qcom,ibat-safe", &chg->charge_current_safe);
+
+	chg->charge_current_safe = max_t(u32, PM8916_LBC_CHGR_MIN_CURRENT, min_t(u32,
+					 chg->charge_current_safe, PM8916_LBC_CHGR_MAX_CURRENT));
+
+	// LBC will pull as much current as it can until it reaches this limit.
+	chg->charge_current_max = chg->charge_current_safe;
+
+	tmp = chg->charge_current_safe / PM8916_LBC_CHGR_MIN_CURRENT - 1;
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_IBAT_SAFE, tmp);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_TCHG_MAX_EN, 0x00);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static int pm8916_lbc_charger_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pm8916_lbc_charger *chg;
+	struct power_supply_config psy_cfg = {};
+	struct power_supply_desc *desc;
+	int ret, len, irq;
+	unsigned int tmp;
+
+	chg = devm_kzalloc(dev, sizeof(*chg), GFP_KERNEL);
+	if (!chg)
+		return -ENOMEM;
+
+	chg->dev = dev;
+
+	chg->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!chg->regmap)
+		return -ENODEV;
+
+	len = of_property_count_u32_elems(dev->of_node, "reg");
+	if (len < 0) {
+		return len;
+	} else if (len != 4) {
+		dev_err(dev, "Wrong amount of reg values: %d (4 expected)\n", len);
+		return ret;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_threaded_irq(dev, irq, NULL, pm8916_lbc_charger_state_changed_irq,
+					IRQF_ONESHOT, "pm8916_lbc", chg);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32_array(dev->of_node, "reg", chg->reg, len);
+	if (ret)
+		return ret;
+
+	ret = regmap_bulk_read(chg->regmap, chg->reg[LBC_CHGR] + PM8916_PERPH_TYPE, &tmp, 2);
+	if (ret)
+		goto comm_error;
+	if (tmp != PM8916_LBC_CHGR_TYPE)
+		goto type_error;
+
+	ret = regmap_bulk_read(chg->regmap, chg->reg[LBC_BAT_IF] + PM8916_PERPH_TYPE, &tmp, 2);
+	if (ret)
+		goto comm_error;
+	if (tmp != PM8916_LBC_BAT_IF_TYPE)
+		goto type_error;
+
+	ret = regmap_bulk_read(chg->regmap, chg->reg[LBC_USB] + PM8916_PERPH_TYPE, &tmp, 2);
+	if (ret)
+		goto comm_error;
+	if (tmp != PM8916_LBC_USB_TYPE)
+		goto type_error;
+
+	ret = regmap_bulk_read(chg->regmap, chg->reg[LBC_MISC] + PM8916_PERPH_TYPE, &tmp, 2);
+	if (ret)
+		goto comm_error;
+	if (tmp != PM8916_LBC_MISC_TYPE)
+		goto type_error;
+
+	ret = regmap_read(chg->regmap, chg->reg[LBC_CHGR] + PM8916_LBC_CHGR_CHG_OPTION, &tmp);
+	if (ret)
+		goto comm_error;
+	if (tmp != PM8916_LBC_CHGR_PMIC_CHARGER) {
+		dev_err(dev, "The system is using an external charger\n");
+		return -ENODEV;
+	}
+
+	ret = pm8916_lbc_charger_probe_dt(chg);
+	if (ret) {
+		dev_err(dev, "Error while parsing device tree: %d\n", ret);
+		return ret;
+	}
+
+	desc = &chg->desc;
+	desc->name = "pm8916-lbc-chgr";
+	desc->type = POWER_SUPPLY_TYPE_USB;
+	desc->properties = pm8916_lbc_charger_properties;
+	desc->num_properties = ARRAY_SIZE(pm8916_lbc_charger_properties);
+	desc->get_property = pm8916_lbc_charger_get_property;
+	psy_cfg.drv_data = chg;
+	psy_cfg.of_node = dev->of_node;
+
+	chg->charger = devm_power_supply_register(dev, desc, &psy_cfg);
+	if (IS_ERR(chg->charger)) {
+		dev_err(dev, "Unable to register charger\n");
+		return PTR_ERR(chg->charger);
+	}
+
+	ret = power_supply_get_battery_info(chg->charger, &chg->info);
+	if (ret) {
+		dev_err(dev, "Unable to get battery info: %d\n", ret);
+		return ret;
+	}
+
+	chg->edev = devm_extcon_dev_allocate(dev, pm8916_lbc_charger_cable);
+	if (IS_ERR(chg->edev))
+		return PTR_ERR(chg->edev);
+
+	ret = devm_extcon_dev_register(dev, chg->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to register extcon device: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_read(chg->regmap, chg->reg[LBC_USB] + PM8916_INT_RT_STS, &tmp);
+	if (ret)
+		goto comm_error;
+
+	extcon_set_state_sync(chg->edev, EXTCON_USB, !!(tmp & PM8916_LBC_USB_USBIN_VALID));
+
+	chg->charge_voltage_max = chg->info.voltage_max_design_uv;
+	ret = pm8916_lbc_charger_enable(chg);
+	if (ret)
+		return ret;
+
+	return 0;
+
+comm_error:
+	dev_err(dev, "Unable to communicate with device: %d\n", ret);
+	return ret;
+
+type_error:
+	dev_err(dev, "Device reported wrong type: 0x%X\n", tmp);
+	return -ENODEV;
+}
+
+static const struct of_device_id pm8916_lbc_charger_of_match[] = {
+	{ .compatible = "qcom,pm8916-lbc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pm8916_lbc_charger_of_match);
+
+static struct platform_driver pm8916_lbc_charger_driver = {
+	.driver = {
+		.name = "pm8916-lbc",
+		.of_match_table = of_match_ptr(pm8916_lbc_charger_of_match),
+	},
+	.probe = pm8916_lbc_charger_probe,
+};
+module_platform_driver(pm8916_lbc_charger_driver);
+
+MODULE_DESCRIPTION("pm8916 LBC driver");
+MODULE_AUTHOR("Nikita Travkin <nikitos.tr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/smb1360-driver.c b/drivers/power/supply/smb1360-driver.c
new file mode 120000
index 00000000000..577704623eb
--- /dev/null
+++ b/drivers/power/supply/smb1360-driver.c
@@ -0,0 +1 @@
+smb1360.c
\ No newline at end of file
diff --git a/drivers/power/supply/smb1360-dump.c b/drivers/power/supply/smb1360-dump.c
new file mode 100644
index 00000000000..a0b72b7d2b2
--- /dev/null
+++ b/drivers/power/supply/smb1360-dump.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+#define pr_fmt(fmt) "smb1360-dump: " fmt
+
+#include <linux/i2c.h>
+
+enum smb1360_reg_type {
+	LITTLE_ENDIAN,
+	BIG_ENDIAN,
+	RAW
+};
+
+struct smb1360_reg {
+	u8 addr;
+	const char *name;
+	u8 size;
+	enum smb1360_reg_type type;
+};
+
+struct smb1360_regset {
+	const char *name;
+	u8 start, end;
+	struct smb1360_reg regs[];
+};
+
+static const struct smb1360_regset smb1360_cfg = {
+	.name	= "configuration",
+	.start	= 0x00,
+	.end	= 0x1C,
+	.regs	= {
+		{ 0x00, "CFG_BATT_CHG_REG", 1 },
+		{ 0x05, "CFG_BATT_CHG_ICL_REG", 1 },
+		{ 0x06, "CFG_GLITCH_FLT_REG", 1 },
+		{ 0x07, "CFG_CHG_MISC_REG", 1 },
+		{ 0x08, "CFG_CHG_FUNC_CTRL_REG", 1 },
+		{ 0x09, "CFG_STAT_CTRL_REG", 1 },
+		{ 0x0A, "CFG_SFY_TIMER_CTRL_REG", 1 },
+		{ 0x0D, "CFG_BATT_MISSING_REG", 1 },
+		{ 0x0E, "CFG_FG_BATT_CTRL_REG", 1 },
+		{ 0x0F, "IRQ_CFG_REG", 1 },
+		{ 0x10, "IRQ2_CFG_REG", 1 },
+		{ 0x11, "IRQ3_CFG_REG", 1 },
+		{ 0x12, "PRE_TO_FAST_REG", 1 },
+		{ 0x13, "CHG_CURRENT_REG", 1 },
+		{ 0x14, "CHG_CMP_CFG", 1 },
+		{ 0x15, "BATT_CHG_FLT_VTG_REG", 1 },
+		{ 0x16, "CFG_FVC_REG", 1 },
+		{ 0x1A, "SHDN_CTRL_REG", 1 },
+		{ 0x1C, "TRIM_1C_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_cfg = {
+	.name	= "fg configuration",
+	.start	= 0x20,
+	.end	= 0x2F,
+	.regs	= {
+		{ 0x20, "SHDW_FG_ESR_ACTUAL", 2 },
+		{ 0x24, "SOC_MAX_REG", 1 },
+		{ 0x25, "SOC_MIN_REG", 1 },
+		{ 0x26, "VTG_EMPTY_REG", 1 },
+		{ 0x27, "Temp_external", 1 },
+		{ 0x28, "SOC_DELTA_REG", 1 },
+		{ 0x29, "JEITA_SOFT_COLD_REG", 1 },
+		{ 0x2A, "JEITA_SOFT_HOT_REG", 1 },
+		{ 0x2B, "VTG_MIN_REG", 1 },
+		{ 0x2E, "ESR_sys_replace", 2 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_cmd = {
+	.name	= "command",
+	.start	= 0x40,
+	.end	= 0x42,
+	.regs	= {
+		{ 0x40, "CMD_I2C_REG", 1 },
+		{ 0x41, "CMD_IL_REG", 1 },
+		{ 0x42, "CMD_CHG_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_status = {
+	.name	= "status",
+	.start	= 0x48,
+	.end	= 0x4F,
+	.regs	= {
+		{ 0x48, "STATUS_1_REG", 1 },
+		{ 0x4B, "STATUS_3_REG", 1 },
+		{ 0x4C, "STATUS_4_REG", 1 },
+		{ 0x4F, "REVISION_CTRL_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_irq_status = {
+	.name	= "irq status",
+	.start	= 0x50,
+	.end	= 0x58,
+	.regs	= {
+		{ 0x50, "IRQ_A_REG", 1 },
+		{ 0x51, "IRQ_B_REG", 1 },
+		{ 0x52, "IRQ_C_REG", 1 },
+		{ 0x53, "IRQ_D_REG", 1 },
+		{ 0x54, "IRQ_E_REG", 1 },
+		{ 0x55, "IRQ_F_REG", 1 },
+		{ 0x56, "IRQ_G_REG", 1 },
+		{ 0x57, "IRQ_H_REG", 1 },
+		{ 0x58, "IRQ_I_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_shdw = {
+	.name	= "fg shadow",
+	.start	= 0x60,
+	.end	= 0x6F,
+	.regs	= {
+		{ 0x60, "SHDW_FG_BATT_STATUS", 1 },
+		{ 0x61, "SHDW_FG_MSYS_SOC", 1 },
+		{ 0x62, "SHDW_FG_CAPACITY", 2 },
+		{ 0x64, "Rslow_drop", 2 },
+		{ 0x66, "Latest_SOC", 1 },
+		{ 0x67, "Latest_Cutoff_SOC", 1 },
+		{ 0x68, "Latest_full_SOC", 1 },
+		{ 0x69, "SHDW_FG_VTG_NOW", 2 },
+		{ 0x6B, "SHDW_FG_CURR_NOW", 2 },
+		{ 0x6D, "SHDW_FG_BATT_TEMP", 2 },
+		{ 0x6F, "Latest_system_sbits", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_scratch = {
+	.name	= "fg scratch pad",
+	.start	= 0x80,
+	.end	= 0xDC,
+	.regs	= {
+		{ 0x80, "VOLTAGE_PREDICTED_REG", 2 },
+		{ 0x82, "v_cutoff_predicted", 2 },
+		{ 0x84, "v_full_predicted", 2 },
+		{ 0x86, "ocv_estimate", 2 },
+		{ 0x88, "rslow_drop", 2 },
+		{ 0x8A, "voltage_old", 2 },
+		{ 0x8C, "current_old", 2 },
+		{ 0x8E, "current_average_full", 4 },
+		{ 0x92, "temperature", 2 },
+		{ 0x94, "temp_last_track", 2 },
+		{ 0x96, "ESR_nominal", 2 },
+		{ 0x9A, "Rslow", 2 },
+		{ 0x9C, "counter_imptr", 2 },
+		{ 0x9E, "counter_pulse", 2 },
+		{ 0xA0, "IRQ_delta_prev", 1 },
+		{ 0xA1, "cap_learning_counter", 1 },
+		{ 0xA2, "Vact_int_error", 4 },
+		{ 0xA6, "SOC_cutoff", 3 },
+		{ 0xA9, "SOC_full", 3 },
+		{ 0xAC, "SOC_auto_rechrge_temp", 3 },
+		{ 0xAF, "Battery_SOC", 3 },
+		{ 0xB2, "CC_SOC", 4 },
+		{ 0xB6, "SOC_filtered", 2 },
+		{ 0xB8, "SOC_Monotonic", 2 },
+		{ 0xBA, "CC_TO_SOC_COEFF", 2 },
+		{ 0xBC, "NOMINAL_CAPACITY_REG", 2 },
+		{ 0xBE, "ACTUAL_CAPACITY_REG", 2 },
+		{ 0xC4, "temperature_counter", 1 },
+		{ 0xC5, "Vbatt_filtered", 3 },
+		{ 0xC8, "Ibatt_filtered", 3 },
+		{ 0xCB, "Current_CC_shadow", 2 },
+		{ 0xCF, "FG_IBATT_STANDBY_REG", 2 },
+		{ 0xD2, "FG_AUTO_RECHARGE_SOC", 1 },
+		{ 0xD3, "FG_SYS_CUTOFF_V_REG", 2 },
+		{ 0xD5, "FG_CC_TO_CV_V_REG", 2 },
+		{ 0xD7, "System_term_current", 2 },
+		{ 0xD9, "System_fake_term_current", 2 },
+		{ 0xDB, "FG_THERM_C1_COEFF_REG", 2 },
+		{ }
+	}
+};
+
+/* Note: Only very few OTP registers are known, there may be many more! */
+static const struct smb1360_regset smb1360_fg_otp = {
+	.name	= "fg otp",
+	.start	= 0x12,
+	.end	= 0x1E,
+	.regs	= {
+		{ 0x12, "JEITA_HARD_COLD_REG", 1 },
+		{ 0x13, "JEITA_HARD_HOT_REG", 1 },
+		{ 0x1D, "CURRENT_GAIN_REG", 2 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_otp_backup = {
+	.name	= "fg otp backup",
+	.start	= 0xE0,
+	.end	= 0xF1,
+	.regs	= {
+		{ 0xE0, "OTP_BACKUP_REG", 16, RAW },
+		{ 0xF0, "OTP_BACKUP_WA_ALG", 2, BIG_ENDIAN },
+		{ }
+	}
+};
+
+static void smb1360_reg_dump(const struct smb1360_reg *reg, const u8 val[])
+{
+	u32 num = 0;
+	int i;
+
+	switch (reg->type) {
+	case RAW:
+		pr_info("\t<%#x> %s %*ph\n", reg->addr, reg->name, reg->size, val);
+		return;
+	case LITTLE_ENDIAN:
+		for (i = 0; i < reg->size; ++i) {
+			num |= val[i] << (8 * i);
+		}
+		break;
+	case BIG_ENDIAN:
+		for (i = 0; i < reg->size; ++i) {
+			num <<= 8;
+			num |= val[i];
+		}
+		break;
+	}
+
+	pr_info("\t<%#x> %s %0*x\n", reg->addr, reg->name, 2 * reg->size, num);
+}
+
+static void smb1360_regset_dump(struct i2c_client *client, const struct smb1360_regset *set)
+{
+	const struct smb1360_reg *reg = set->regs;
+	u8 val[U8_MAX];
+	u8 r, next;
+	int ret;
+
+	pr_info("%s:\n", set->name);
+
+	for (r = set->start; r <= set->end; r += ret) {
+		u8 len = set->end - r + 1;
+		int i = r - set->start;
+
+		ret = i2c_smbus_read_i2c_block_data(client, r, len, &val[i]);
+		pr_info("\tread %s at %#x len %d, ret %d\n", set->name, r, len, ret);
+		if (ret < 0) {
+			pr_err("\tFailed to read %d %s registers at %#x: %d\n",
+			       len, set->name, r, ret);
+			return;
+		}
+	}
+
+	for (r = set->start; r <= set->end;) {
+		int i = r - set->start;
+
+		if (reg->name) {
+			if (r == reg->addr) {
+				smb1360_reg_dump(reg, &val[i]);
+				r += reg->size;
+				++reg;
+				continue;
+			}
+
+			/* Dump until next documented reg */
+			next = reg->addr;
+		} else {
+			/* No more documented regs, dump remaining regs */
+			next = set->end + 1;
+		}
+
+		pr_info("\t<%#x> %*ph\n", r, next - r, &val[i]);
+		r = next;
+	}
+}
+
+void smb1360_dump(struct i2c_client *client)
+{
+	smb1360_regset_dump(client, &smb1360_cfg);
+	smb1360_regset_dump(client, &smb1360_fg_cfg);
+	smb1360_regset_dump(client, &smb1360_cmd);
+	smb1360_regset_dump(client, &smb1360_status);
+	smb1360_regset_dump(client, &smb1360_irq_status);
+	smb1360_regset_dump(client, &smb1360_fg_shdw);
+}
+
+/* Should be called with smb1360_enable_fg_access() */
+void smb1360_dump_fg_scratch(struct i2c_client *client)
+{
+	smb1360_regset_dump(client, &smb1360_fg_scratch);
+}
+
+/* Should be called with smb1360_enable_fg_access() and FG I2C client */
+void smb1360_dump_fg(struct i2c_client *fg_client)
+{
+	smb1360_regset_dump(fg_client, &smb1360_fg_otp);
+	smb1360_regset_dump(fg_client, &smb1360_fg_otp_backup);
+	pr_info("\n");
+}
diff --git a/drivers/power/supply/smb1360.c b/drivers/power/supply/smb1360.c
new file mode 100644
index 00000000000..ae6fd3a8928
--- /dev/null
+++ b/drivers/power/supply/smb1360.c
@@ -0,0 +1,1817 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Register definitions taken from drivers/power/smb1360-charger-fg.c
+ * Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ *
+ * TODO:
+ *  - Investigate using common battery device tree properties
+ *    (e.g. voltage-{min,max}-design-microvolt)
+ *  - Implement more power supply properties, e.g.
+ *    - POWER_SUPPLY_PROP_TEMP_{,ALERT_}{MIN,MAX}
+ *    - POWER_SUPPLY_PROP_CAPACITY_ALERT_{MIN,MAX}
+ *    - POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT
+ */
+
+#ifdef CONFIG_SMB1360_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/completion.h>
+#include <linux/extcon-provider.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+/* Charger Registers */
+#define CFG_BATT_CHG_REG		0x00
+#define CHG_ITERM_MASK			GENMASK(2, 0)
+#define RECHG_MV_MASK			GENMASK(6, 5)
+#define RECHG_MV_SHIFT			5
+#define OTG_CURRENT_MASK		GENMASK(4, 3)
+#define OTG_CURRENT_SHIFT		3
+
+#define CFG_BATT_CHG_ICL_REG		0x05
+#define AC_INPUT_ICL_PIN_BIT		BIT(7)
+#define AC_INPUT_PIN_HIGH_BIT		BIT(6)
+#define RESET_STATE_USB_500		BIT(5)
+#define INPUT_CURR_LIM_MASK		GENMASK(3, 0)
+
+#define CFG_GLITCH_FLT_REG		0x06
+#define AICL_ENABLED_BIT		BIT(0)
+#define INPUT_UV_GLITCH_FLT_20MS_BIT	BIT(7)
+
+#define CFG_CHG_MISC_REG		0x7
+#define CHG_EN_BY_PIN_BIT		BIT(7)
+#define CHG_EN_ACTIVE_LOW_BIT		BIT(6)
+#define PRE_TO_FAST_REQ_CMD_BIT		BIT(5)
+#define CFG_BAT_OV_ENDS_CHG_CYC		BIT(4)
+#define CHG_CURR_TERM_DIS_BIT		BIT(3)
+#define CFG_AUTO_RECHG_DIS_BIT		BIT(2)
+#define CFG_CHG_INHIBIT_EN_BIT		BIT(0)
+
+#define CFG_CHG_FUNC_CTRL_REG		0x08
+#define CHG_RECHG_THRESH_FG_SRC_BIT	BIT(1)
+
+#define CFG_STAT_CTRL_REG		0x09
+#define CHG_STAT_IRQ_ONLY_BIT		BIT(4)
+#define CHG_TEMP_CHG_ERR_BLINK_BIT	BIT(3)
+#define CHG_STAT_ACTIVE_HIGH_BIT	BIT(1)
+#define CHG_STAT_DISABLE_BIT		BIT(0)
+
+#define CFG_SFY_TIMER_CTRL_REG		0x0A
+#define SAFETY_TIME_DISABLE_BIT		BIT(5)
+#define SAFETY_TIME_MINUTES_SHIFT	2
+#define SAFETY_TIME_MINUTES_MASK	GENMASK(3, 2)
+
+#define CFG_BATT_MISSING_REG		0x0D
+#define BATT_MISSING_SRC_THERM_BIT	BIT(1)
+
+#define CFG_FG_BATT_CTRL_REG		0x0E
+#define CFG_FG_OTP_BACK_UP_ENABLE	BIT(7)
+#define BATT_ID_ENABLED_BIT		BIT(5)
+#define CHG_BATT_ID_FAIL		BIT(4)
+#define BATT_ID_FAIL_SELECT_PROFILE	BIT(3)
+#define BATT_PROFILE_SELECT_MASK	GENMASK(3, 0)
+#define BATT_PROFILEA_MASK		0x0
+#define BATT_PROFILEB_MASK		0xF
+
+#define IRQ_CFG_REG			0x0F
+#define IRQ_INTERNAL_TEMPERATURE_BIT	BIT(0)
+#define IRQ_AICL_DONE_BIT		BIT(1)
+#define IRQ_DCIN_UV_BIT			BIT(2)
+#define IRQ_BAT_HOT_COLD_SOFT_BIT	BIT(6)
+#define IRQ_HOT_COLD_HARD_BIT		BIT(7)
+
+#define IRQ2_CFG_REG			0x10
+#define IRQ2_VBAT_LOW_BIT		BIT(0)
+#define IRQ2_BATT_MISSING_BIT		BIT(1)
+#define IRQ2_POWER_OK_BIT		BIT(2)
+#define IRQ2_CHG_PHASE_CHANGE_BIT	BIT(4)
+#define IRQ2_CHG_ERR_BIT		BIT(6)
+#define IRQ2_SAFETY_TIMER_BIT		BIT(7)
+
+#define IRQ3_CFG_REG			0x11
+#define IRQ3_SOC_FULL_BIT		BIT(0)
+#define IRQ3_SOC_EMPTY_BIT		BIT(1)
+#define IRQ3_SOC_MAX_BIT		BIT(2)
+#define IRQ3_SOC_MIN_BIT		BIT(3)
+#define IRQ3_SOC_CHANGE_BIT		BIT(4)
+#define IRQ3_FG_ACCESS_OK_BIT		BIT(6)
+
+#define CHG_CURRENT_REG			0x13
+#define FASTCHG_CURR_MASK		GENMASK(4, 2)
+#define FASTCHG_CURR_SHIFT		2
+
+#define CHG_CMP_CFG			0x14
+#define JEITA_COMP_CURR_MASK		GENMASK(3, 0)
+#define JEITA_COMP_EN_MASK		GENMASK(7, 4)
+#define JEITA_COMP_EN_SHIFT		4
+#define JEITA_COMP_EN_BIT		GENMASK(7, 4)
+
+#define BATT_CHG_FLT_VTG_REG		0x15
+#define VFLOAT_MASK			GENMASK(6, 0)
+
+#define CFG_FVC_REG			0x16
+#define FLT_VTG_COMP_MASK		GENMASK(6, 0)
+
+#define SHDN_CTRL_REG			0x1A
+#define SHDN_CMD_USE_BIT		BIT(1)
+#define SHDN_CMD_POLARITY_BIT		BIT(2)
+
+/* Command Registers */
+#define CMD_I2C_REG			0x40
+#define ALLOW_VOLATILE_BIT		BIT(6)
+#define FG_ACCESS_ENABLED_BIT		BIT(5)
+#define FG_RESET_BIT			BIT(4)
+#define CYCLE_STRETCH_CLEAR_BIT		BIT(3)
+
+#define CMD_IL_REG			0x41
+#define USB_CTRL_MASK			GENMASK(1, 0)
+#define USB_100_BIT			0x01
+#define USB_500_BIT			0x00
+#define USB_AC_BIT			0x02
+#define SHDN_CMD_BIT			BIT(7)
+
+#define CMD_CHG_REG			0x42
+#define CMD_CHG_EN			BIT(1)
+#define CMD_OTG_EN_BIT			BIT(0)
+
+/* Status Registers */
+#define STATUS_1_REG			0x48
+#define AICL_CURRENT_STATUS_MASK	GENMASK(6, 0)
+#define AICL_LIMIT_1500MA		0xF
+
+#define STATUS_3_REG			0x4B
+#define CHG_HOLD_OFF_BIT		BIT(3)
+#define CHG_TYPE_MASK			GENMASK(2, 1)
+#define CHG_TYPE_SHIFT			1
+#define BATT_NOT_CHG_VAL		0x0
+#define BATT_PRE_CHG_VAL		0x1
+#define BATT_FAST_CHG_VAL		0x2
+#define BATT_TAPER_CHG_VAL		0x3
+
+#define STATUS_4_REG			0x4C
+#define CYCLE_STRETCH_ACTIVE_BIT	BIT(5)
+
+#define REVISION_CTRL_REG		0x4F
+#define DEVICE_REV_MASK			GENMASK(3, 0)
+
+/* IRQ Status Registers */
+#define IRQ_REG				0x50
+
+#define IRQ_A_REG			0x50
+#define IRQ_A_HOT_HARD_BIT		BIT(6)
+#define IRQ_A_COLD_HARD_BIT		BIT(4)
+#define IRQ_A_HOT_SOFT_BIT		BIT(2)
+#define IRQ_A_COLD_SOFT_BIT		BIT(0)
+
+#define IRQ_B_REG			0x51
+#define IRQ_B_BATT_TERMINAL_BIT		BIT(6)
+#define IRQ_B_BATT_MISSING_BIT		BIT(4)
+#define IRQ_B_VBAT_LOW_BIT		BIT(2)
+#define IRQ_B_CHG_HOT_BIT		BIT(0)
+
+#define IRQ_C_REG			0x52
+#define IRQ_C_FAST_CHG_BIT		BIT(6)
+#define IRQ_C_RECHARGE_BIT		BIT(4)
+#define IRQ_C_TAPER_BIT			BIT(2)
+#define IRQ_C_CHG_TERM_BIT		BIT(0)
+
+#define IRQ_D_REG			0x53
+#define IRQ_D_BATTERY_OV_BIT		BIT(6)
+#define IRQ_D_AICL_DONE_BIT		BIT(4)
+#define IRQ_D_SAFETY_TIMEOUT_BIT	BIT(2)
+#define IRQ_D_PRECHG_TIMEOUT_BIT	BIT(0)
+
+#define IRQ_E_REG			0x54
+#define IRQ_E_INHIBIT_BIT		BIT(6)
+#define IRQ_E_USBIN_OV_BIT		BIT(2)
+#define IRQ_E_USBIN_UV_BIT		BIT(0)
+
+#define IRQ_F_REG			0x54
+#define IRQ_F_OTG_OC_BIT		BIT(6)
+#define IRQ_F_OTG_FAIL_BIT		BIT(4)
+#define IRQ_F_POWER_OK_BIT		BIT(0)
+
+#define IRQ_G_REG			0x56
+#define IRQ_G_WD_TIMEOUT_BIT		BIT(4)
+#define IRQ_G_CHG_ERROR_BIT		BIT(2)
+#define IRQ_G_SOC_CHANGE_BIT		BIT(0)
+
+#define IRQ_H_REG			0x57
+#define IRQ_H_FULL_SOC_BIT		BIT(6)
+#define IRQ_H_EMPTY_SOC_BIT		BIT(4)
+#define IRQ_H_MAX_SOC_BIT		BIT(2)
+#define IRQ_H_MIN_SOC_BIT		BIT(0)
+
+#define IRQ_I_REG			0x58
+#define IRQ_I_BATT_ID_RESULT_BIT	GENMASK(6, 4)
+#define IRQ_I_BATT_ID_SHIFT		4
+#define IRQ_I_BATT_ID_COMPLETE_BIT	BIT(4)
+#define IRQ_I_FG_DATA_RECOVERY_BIT	BIT(2)
+#define IRQ_I_FG_ACCESS_ALLOWED_BIT	BIT(0)
+
+/* FG registers - IRQ config register */
+#define SOC_MAX_REG			0x24
+#define SOC_MIN_REG			0x25
+#define VTG_EMPTY_REG			0x26
+#define SOC_DELTA_REG			0x28
+#define JEITA_SOFT_COLD_REG		0x29
+#define JEITA_SOFT_HOT_REG		0x2A
+#define VTG_MIN_REG			0x2B
+
+#define SOC_DELTA_VAL			1
+#define SOC_MIN_VAL			15
+
+/* FG SHADOW registers */
+#define SHDW_FG_ESR_ACTUAL		0x20
+#define SHDW_FG_BATT_STATUS		0x60
+#define BATTERY_PROFILE_BIT		BIT(0)
+#define SHDW_FG_MSYS_SOC		0x61
+#define SHDW_FG_CAPACITY		0x62
+#define SHDW_FG_VTG_NOW			0x69
+#define SHDW_FG_CURR_NOW		0x6B
+#define SHDW_FG_BATT_TEMP		0x6D
+
+/* FG scratchpad registers */
+#define VOLTAGE_PREDICTED_REG		0x80
+#define CC_TO_SOC_COEFF			0xBA
+#define NOMINAL_CAPACITY_REG		0xBC
+#define ACTUAL_CAPACITY_REG		0xBE
+#define FG_IBATT_STANDBY_REG		0xCF
+#define FG_AUTO_RECHARGE_SOC		0xD2
+#define FG_SYS_CUTOFF_V_REG		0xD3
+#define FG_CC_TO_CV_V_REG		0xD5
+#define FG_ITERM_REG			0xD9
+#define FG_THERM_C1_COEFF_REG		0xDB
+
+/* Constants */
+#define SMB1360_REV_1			0x01
+
+#define FG_RESET_THRESHOLD_MV		15
+
+#define MIN_FLOAT_MV			3460
+#define MAX_FLOAT_MV			4730
+#define VFLOAT_STEP_MV			10
+
+#define MIN_RECHG_MV			50
+#define MAX_RECHG_MV			300
+
+#define SMB1360_FG_ACCESS_TIMEOUT_MS	15000
+#define SMB1360_POWERON_DELAY_MS	2000
+#define SMB1360_FG_RESET_DELAY_MS	1500
+
+/* FG registers (on different I2C address) */
+#define FG_I2C_CFG_MASK			GENMASK(1, 0)
+#define FG_CFG_I2C_ADDR			0x1
+#define FG_PROFILE_A_ADDR		0x2
+#define FG_PROFILE_B_ADDR		0x3
+
+#define CURRENT_GAIN_LSB_REG		0x1D
+#define CURRENT_GAIN_MSB_REG		0x1E
+
+#define OTP_WRITABLE_REG_1		0xE0
+#define OTP_WRITABLE_REG_2		0xE1
+#define OTP_WRITABLE_REG_3		0xE2
+#define OTP_WRITABLE_REG_4		0xE3
+#define OTP_WRITABLE_REG_5		0xE4
+#define OTP_WRITABLE_REG_6		0xE5
+#define OTP_WRITABLE_REG_7		0xE6
+#define OTP_WRITABLE_REG_8		0xE7
+#define OTP_WRITABLE_REG_9		0xE8
+#define OTP_WRITABLE_REG_10		0xE9
+#define OTP_WRITABLE_REG_11		0xEA
+#define OTP_WRITABLE_REG_12		0xEB
+#define OTP_WRITABLE_REG_13		0xEC
+#define OTP_WRITABLE_REG_14		0xED
+#define OTP_WRITABLE_REG_15		0xEE
+#define OTP_WRITABLE_REG_16		0xEF
+#define OTP_BACKUP_MAP_REG		0xF0
+#define CURRENT_GAIN_BITMAP		0x5000
+#define HARD_JEITA_BITMAP		0x0500
+#define RSLOW_BITMAP			0x00AA
+
+#define RSLOW_0				0x54
+#define RSLOW_1				0x55
+#define RSLOW_2				0x56
+#define RSLOW_3				0x57
+
+#define OTP_HARD_COLD_REG_ADDR		0x12
+#define OTP_HARD_HOT_REG_ADDR		0x13
+#define OTP_GAIN_FIRST_HALF_REG_ADDR	0x1D
+#define OTP_GAIN_SECOND_HALF_REG_ADDR	0x1E
+
+#define TEMP_THRE_SET(x) (((x) + 300) / 10)
+
+enum {
+	BATTERY_PROFILE_A,
+	BATTERY_PROFILE_B,
+	BATTERY_PROFILE_MAX,
+};
+
+enum {
+	IRQ_A, IRQ_B, IRQ_C, IRQ_D, IRQ_E, IRQ_F, IRQ_G, IRQ_H, IRQ_I,
+	IRQ_COUNT
+};
+
+static const unsigned int smb1360_usb_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_NONE,
+};
+
+struct smb1360 {
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct regmap		*fg_regmap;
+	struct power_supply	*psy;
+	struct extcon_dev	*edev;
+	struct regulator_dev	*otg_vreg;
+	struct completion	fg_mem_access_granted;
+	struct delayed_work	delayed_init_work;
+
+	unsigned int revision;
+	u8 irqstat[IRQ_COUNT];
+
+	bool shdn_after_pwroff;
+	bool rsense_10mohm;
+	bool initialized;
+
+	int float_voltage;
+};
+
+static enum power_supply_property smb1360_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP
+};
+
+#define EXPONENT_MASK		0xF800
+#define MANTISSA_MASK		0x3FF
+#define SIGN_MASK		0x400
+#define EXPONENT_SHIFT		11
+#define SIGN_SHIFT		10
+#define MICRO_UNIT		1000000ULL
+static s64 float_decode(u16 reg)
+{
+	s64 final_val, exponent_val, mantissa_val;
+	int exponent, mantissa, n;
+	bool sign;
+
+	exponent = (reg & EXPONENT_MASK) >> EXPONENT_SHIFT;
+	mantissa = (reg & MANTISSA_MASK);
+	sign = !!(reg & SIGN_MASK);
+
+	mantissa_val = mantissa * MICRO_UNIT;
+
+	n = exponent - 15;
+	if (n < 0)
+		exponent_val = MICRO_UNIT >> -n;
+	else
+		exponent_val = MICRO_UNIT << n;
+
+	n = n - 10;
+	if (n < 0)
+		mantissa_val >>= -n;
+	else
+		mantissa_val <<= n;
+
+	final_val = exponent_val + mantissa_val;
+
+	if (sign)
+		final_val *= -1;
+
+	return final_val;
+}
+
+#define MAX_MANTISSA (1023 * 1000000ULL)
+unsigned int float_encode(s64 float_val)
+{
+	int exponent = 0, sign = 0;
+	unsigned int final_val = 0;
+
+	if (float_val == 0)
+		return 0;
+
+	if (float_val < 0) {
+		sign = 1;
+		float_val = -float_val;
+	}
+
+	/* Reduce large mantissa until it fits into 10 bit */
+	while (float_val >= MAX_MANTISSA) {
+		exponent++;
+		float_val >>= 1;
+	}
+
+	/* Increase small mantissa to improve precision */
+	while (float_val < MAX_MANTISSA && exponent > -25) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	exponent = exponent + 25;
+
+	/* Convert mantissa from micro-units to units */
+	float_val = div_s64((float_val + MICRO_UNIT), (int)MICRO_UNIT);
+
+	if (float_val == 1024) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	float_val -= 1024;
+
+	/* Ensure that resulting number is within range */
+	if (float_val > MANTISSA_MASK)
+		float_val = MANTISSA_MASK;
+
+	/* Convert to 5 bit exponent, 11 bit mantissa */
+	final_val = (float_val & MANTISSA_MASK) | (sign << SIGN_SHIFT) |
+		((exponent << EXPONENT_SHIFT) & EXPONENT_MASK);
+
+	return final_val;
+}
+
+static int smb1360_update_le16(struct smb1360 *smb, u8 reg, const char *prop, s16 scale)
+{
+	int ret;
+	u32 temp;
+	__le16 val;
+
+	if (device_property_read_u32(smb->dev, prop, &temp))
+		return 0;
+
+	if (scale > 0)
+		temp = div_u64(temp * S16_MAX, scale);
+	else if (scale < 0)
+		temp = div_s64(temp * S16_MAX, scale);
+
+	val = cpu_to_le16(temp);
+	ret = regmap_raw_write(smb->regmap, reg, &val, sizeof(val));
+	if (ret)
+		dev_err(smb->dev, "writing %s failed: %d\n", prop, ret);
+	return ret;
+}
+
+static int smb1360_read_voltage(struct smb1360 *smb, u8 reg,
+				int *voltage)
+{
+	__le16 val;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, reg, &val, sizeof(val));
+	if (ret)
+		return ret;
+
+	*voltage = div_u64(le16_to_cpu(val) * 5000, S16_MAX);
+	return 0;
+}
+
+static int smb1360_get_prop_batt_status(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	unsigned int reg, chg_type;
+	int ret;
+
+	if (smb->irqstat[IRQ_C] & IRQ_C_CHG_TERM_BIT) {
+		val->intval = POWER_SUPPLY_STATUS_FULL;
+		return 0;
+	}
+
+	ret = regmap_read(smb->regmap, STATUS_3_REG, &reg);
+	if (ret) {
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		return ret;
+	}
+
+	if (reg & CHG_HOLD_OFF_BIT) {
+		val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return 0;
+	}
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+	if (chg_type == BATT_NOT_CHG_VAL) {
+		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		return 0;
+	}
+
+	val->intval = POWER_SUPPLY_STATUS_CHARGING;
+	return 0;
+}
+
+static int smb1360_get_prop_charge_type(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	int ret;
+	unsigned int reg;
+
+	ret = regmap_read(smb->regmap, STATUS_3_REG, &reg);
+	if (ret) {
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+		return ret;
+	}
+
+	switch ((reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT) {
+	case BATT_NOT_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	case BATT_FAST_CHG_VAL:
+	case BATT_TAPER_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case BATT_PRE_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	default:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	}
+
+	return 0;
+}
+
+static int smb1360_get_prop_batt_health(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	if (smb->irqstat[IRQ_A] & IRQ_A_HOT_HARD_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_HOT;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_HOT_SOFT_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_WARM;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_COLD_HARD_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_COLD_SOFT_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_COOL;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	return 0;
+}
+
+static int smb1360_get_prop_current_now(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	__le16 temp;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_CURR_NOW, &temp, sizeof(temp));
+	if (ret)
+		return ret;
+
+	val->intval = -(div_s64(((s16)le16_to_cpu(temp)) * 2500, S16_MAX) * 1000);
+
+	return 0;
+}
+
+static int smb1360_get_prop_chg_full_design(struct smb1360 *smb,
+					    union power_supply_propval *val)
+{
+	__le16 fcc_mah;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_CAPACITY, &fcc_mah, sizeof(fcc_mah));
+	if (ret)
+		return ret;
+
+	val->intval = le16_to_cpu(fcc_mah) * 1000;
+	return 0;
+}
+
+static int smb1360_get_prop_batt_capacity(struct smb1360 *smb,
+					  union power_supply_propval *val)
+{
+	int ret, soc = 0;
+	unsigned int reg;
+
+	if (smb->irqstat[IRQ_H] & IRQ_H_EMPTY_SOC_BIT) {
+		val->intval = 0;
+		return 0;
+	}
+
+	ret = regmap_read(smb->regmap, SHDW_FG_MSYS_SOC, &reg);
+	if (ret)
+		return ret;
+
+	soc = DIV_ROUND_CLOSEST(reg * 100, U8_MAX);
+	val->intval = clamp(soc, 0, 100);
+
+	return 0;
+}
+
+static int smb1360_get_prop_batt_temp(struct smb1360 *smb,
+				      union power_supply_propval *val)
+{
+	__le16 temp;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_BATT_TEMP, &temp, sizeof(temp));
+	if (ret)
+		return ret;
+
+	temp = div_u64(le16_to_cpu(temp) * 625, 10000UL); /* temperature in K */
+	val->intval = (temp - 273) * 10; /* temperature in decideg */
+
+	return 0;
+}
+
+static int smb1360_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct smb1360 *smb = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		return smb1360_get_prop_batt_status(smb, val);
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		return smb1360_get_prop_charge_type(smb, val);
+	case POWER_SUPPLY_PROP_HEALTH:
+		return smb1360_get_prop_batt_health(smb, val);
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT);
+		return 0;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		return smb1360_read_voltage(smb, SHDW_FG_VTG_NOW, &val->intval);
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		return smb1360_get_prop_current_now(smb, val);
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return smb1360_get_prop_chg_full_design(smb, val);
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		val->intval = smb->float_voltage * 1000;
+		return 0;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		return smb1360_get_prop_batt_capacity(smb, val);
+	case POWER_SUPPLY_PROP_TEMP:
+		return smb1360_get_prop_batt_temp(smb, val);
+	default:
+		return -EINVAL;
+	}
+}
+
+static irqreturn_t smb1360_irq(int irq, void *data)
+{
+	struct smb1360 *smb = data;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, IRQ_REG, smb->irqstat, sizeof(smb->irqstat));
+	if (ret < 0)
+		return IRQ_NONE;
+
+	extcon_set_state_sync(smb->edev, EXTCON_USB,
+			      !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT));
+
+	if (smb->irqstat[IRQ_F] & (IRQ_F_OTG_FAIL_BIT | IRQ_F_OTG_OC_BIT)) {
+		dev_warn(smb->dev, "otg error: %d\n", smb->irqstat[IRQ_F]);
+		regulator_disable_regmap(smb->otg_vreg);
+	}
+
+	if (smb->irqstat[IRQ_I] & IRQ_I_FG_ACCESS_ALLOWED_BIT)
+		complete_all(&smb->fg_mem_access_granted);
+
+	if (smb->initialized)
+		power_supply_changed(smb->psy);
+
+	return IRQ_HANDLED;
+}
+
+static const struct regulator_ops smb1360_regulator_ops = {
+	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.get_current_limit	= regulator_get_current_limit_regmap,
+	.set_current_limit	= regulator_set_current_limit_regmap,
+};
+
+static const unsigned int smb1360_otg_current_limits[] = {
+	350000, 550000, 950000, 1500000
+};
+
+static const struct regulator_desc smb1360_regulator_desc = {
+	.name			= "usb_otg_vbus",
+	.of_match		= "usb-otg-vbus",
+	.ops			= &smb1360_regulator_ops,
+	.type			= REGULATOR_VOLTAGE,
+	.owner			= THIS_MODULE,
+	.enable_reg		= CMD_CHG_REG,
+	.enable_mask		= CMD_OTG_EN_BIT,
+	.enable_val		= CMD_OTG_EN_BIT,
+	.fixed_uV		= 5000000,
+	.n_voltages		= 1,
+	.curr_table		= smb1360_otg_current_limits,
+	.n_current_limits	= ARRAY_SIZE(smb1360_otg_current_limits),
+	.csel_reg		= CFG_BATT_CHG_REG,
+	.csel_mask		= OTG_CURRENT_MASK,
+};
+
+static int smb1360_register_vbus_regulator(struct smb1360 *smb)
+{
+	struct regulator_config cfg = {
+		.dev = smb->dev,
+	};
+
+	smb->otg_vreg = devm_regulator_register(smb->dev,
+						&smb1360_regulator_desc, &cfg);
+	if (IS_ERR(smb->otg_vreg)) {
+		dev_err(smb->dev, "can't register regulator: %pe\n", smb->otg_vreg);
+		return PTR_ERR(smb->otg_vreg);
+	}
+
+	return 0;
+}
+
+static int smb1360_enable_fg_access(struct smb1360 *smb)
+{
+	unsigned int reg;
+	int ret;
+
+	ret = regmap_read(smb->regmap, IRQ_I_REG, &reg);
+	if (ret || reg & IRQ_I_FG_ACCESS_ALLOWED_BIT)
+		goto err;
+
+	/* request FG access */
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+	if (ret)
+		goto err;
+
+	ret = wait_for_completion_timeout(&smb->fg_mem_access_granted,
+					  msecs_to_jiffies(SMB1360_FG_ACCESS_TIMEOUT_MS));
+
+	if (ret == 0) {
+		/* Clear the FG access bit if request failed */
+		dev_err(smb->dev, "enable FG access timed out\n");
+		regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+
+err:
+	dev_err(smb->dev, "failed to enable fg access: %d\n", ret);
+	return ret;
+}
+
+static int smb1360_disable_fg_access(struct smb1360 *smb)
+{
+	int ret;
+
+	ret = regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't disable FG access: %d\n", ret);
+
+	reinit_completion(&smb->fg_mem_access_granted);
+
+	return ret;
+}
+
+static int smb1360_force_fg_reset(struct smb1360 *smb)
+{
+	int ret;
+
+	dev_dbg(smb->dev, "forcing FG reset!\n");
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, FG_RESET_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't reset FG: %d\n", ret);
+		return ret;
+	}
+
+	msleep(SMB1360_FG_RESET_DELAY_MS);
+
+	ret = regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_RESET_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't un-reset FG: %d\n", ret);
+
+	return ret;
+}
+
+static int smb1360_fg_reset(struct smb1360 *smb)
+{
+	int ret, temp, v_predicted, v_now;
+	u32 val;
+
+	if (!device_property_read_bool(smb->dev, "qcom,fg-reset-at-pon"))
+		return 0;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	ret = smb1360_read_voltage(smb, VOLTAGE_PREDICTED_REG, &v_predicted);
+	if (ret)
+		goto disable_fg_access;
+	ret = smb1360_read_voltage(smb, SHDW_FG_VTG_NOW, &v_now);
+	if (ret)
+		goto disable_fg_access;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-reset-threshold-mv", &val))
+		val = FG_RESET_THRESHOLD_MV;
+
+	temp = abs(v_predicted - v_now);
+	dev_dbg(smb->dev, "FG reset: predicted: %d, now: %d, delta: %d, threshold: %d\n",
+		v_predicted, v_now, temp, val);
+	if (temp >= val) {
+		/* delay for the FG access to settle */
+		msleep(1500);
+
+		ret = smb1360_force_fg_reset(smb);
+		if (ret)
+			goto disable_fg_access;
+	}
+
+disable_fg_access:
+	smb1360_disable_fg_access(smb);
+	return ret;
+}
+
+static int smb1360_check_batt_profile(struct smb1360 *smb)
+{
+	u32 profile, loaded_profile;
+	unsigned int val;
+	int ret, timeout;
+
+	if (device_property_read_u32(smb->dev, "qcom,battery-profile", &profile))
+		return 0;
+
+	if (profile > 1) {
+		dev_err(smb->dev, "invalid battery profile: %d\n", profile);
+		return -EINVAL;
+	}
+
+	ret = regmap_read(smb->regmap, SHDW_FG_BATT_STATUS, &val);
+	if (ret)
+		return ret;
+
+	loaded_profile = !!(val & BATTERY_PROFILE_BIT);
+	dev_dbg(smb->dev, "profile: %d, loaded_profile: %d\n", profile, loaded_profile);
+
+	if (loaded_profile == profile)
+		return 0;
+
+	ret = regmap_update_bits(smb->regmap, CFG_FG_BATT_CTRL_REG,
+				 BATT_PROFILE_SELECT_MASK,
+				 profile ? BATT_PROFILEB_MASK : BATT_PROFILEA_MASK);
+	if (ret)
+		return ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	/* delay after handshaking for profile-switch to continue */
+	msleep(1500);
+
+	ret = smb1360_force_fg_reset(smb);
+	if (ret) {
+		smb1360_disable_fg_access(smb);
+		return ret;
+	}
+	ret = smb1360_disable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	for (timeout = 0; timeout < 10; ++timeout) {
+		/* delay for profile to change */
+		msleep(500);
+		ret = regmap_read(smb->regmap, SHDW_FG_BATT_STATUS, &val);
+		if (ret)
+			return ret;
+
+		loaded_profile = !!(val & BATTERY_PROFILE_BIT);
+		if (loaded_profile == profile)
+			return 0;
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int smb1360_adjust_otp_current_gain(struct smb1360 *smb)
+{
+	int ret;
+	u8 val[4];
+	__le16 current_gain;
+	u16 current_gain_encoded;
+
+	ret = regmap_raw_read(smb->fg_regmap, CURRENT_GAIN_LSB_REG,
+			      &current_gain, sizeof(current_gain));
+	if (ret)
+		return ret;
+
+	current_gain_encoded = le16_to_cpu(current_gain);
+	current_gain_encoded = float_encode(MICRO_UNIT + (2 * float_decode(current_gain_encoded)));
+
+	val[0] = OTP_GAIN_FIRST_HALF_REG_ADDR;
+	val[1] = current_gain_encoded & 0xFF;
+	val[2] = OTP_GAIN_SECOND_HALF_REG_ADDR;
+	val[3] = (current_gain_encoded & 0xFF00) >> 8;
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_1, val, ARRAY_SIZE(val));
+}
+
+static int smb1360_set_otp_hard_jeita_threshold(struct smb1360 *smb)
+{
+	u8 val[4];
+	s32 hot, cold;
+
+	if (device_property_read_u32(smb->dev, "qcom,otp-hot-bat-decidegc", &hot))
+		return -EINVAL;
+	if (device_property_read_u32(smb->dev, "qcom,otp-cold-bat-decidegc", &cold))
+		return -EINVAL;
+
+	val[0] = OTP_HARD_HOT_REG_ADDR;
+	val[1] = TEMP_THRE_SET(hot);
+	val[2] = OTP_HARD_COLD_REG_ADDR;
+	val[3] = TEMP_THRE_SET(cold);
+
+	if (val[1] < 0 || val[3] < 0)
+		return -EINVAL;
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_5, val, ARRAY_SIZE(val));
+}
+
+static int smb1360_set_otp_rslow(struct smb1360 *smb)
+{
+	u8 seq[] = { RSLOW_0, 0x0, RSLOW_1, 0x0, RSLOW_2, 0x0, RSLOW_3, 0x0 };
+	u8 val[4];
+	int i;
+
+	if (device_property_read_u8_array(smb->dev, "qcom,otp-rslow-config", val, 4))
+		return -EINVAL;
+
+	for (i = 0; i < 4; i++)
+		seq[i * 2 + 1] = val[i];
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_9, seq, ARRAY_SIZE(seq));
+}
+
+static int smb1360_reconf_otp(struct smb1360 *smb)
+{
+	bool hard_jeita = device_property_read_bool(smb->dev, "qcom,otp-hard-jeita-config");
+	bool otp_rslow = device_property_present(smb->dev, "qcom,otp-rslow-config");
+	u16 backup_map = 0;
+	__be16 val;
+	int ret;
+
+	if (!smb->rsense_10mohm && !hard_jeita && !otp_rslow)
+		return 0;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	if (smb->rsense_10mohm) {
+		ret = smb1360_adjust_otp_current_gain(smb);
+		if (ret)
+			dev_err(smb->dev,
+				"couldn't reconfigure gain for lower resistance: %d\n", ret);
+		else
+			backup_map |= CURRENT_GAIN_BITMAP;
+	}
+
+	if (hard_jeita) {
+		ret = smb1360_set_otp_hard_jeita_threshold(smb);
+		if (ret)
+			dev_err(smb->dev, "unable to modify otp hard jeita: %d\n", ret);
+		else
+			backup_map |= HARD_JEITA_BITMAP;
+	}
+
+	if (otp_rslow) {
+		ret = smb1360_set_otp_rslow(smb);
+		if (ret)
+			dev_err(smb->dev, "unable to modify otp rslow: %d\n", ret);
+		else
+			backup_map |= RSLOW_BITMAP;
+	}
+
+	val = cpu_to_be16(backup_map);
+	ret = regmap_raw_write(smb->fg_regmap, OTP_BACKUP_MAP_REG, &val, sizeof(val));
+	if (ret)
+		goto out;
+
+	ret = regmap_set_bits(smb->regmap, CFG_FG_BATT_CTRL_REG, CFG_FG_OTP_BACK_UP_ENABLE);
+	if (ret)
+		dev_err(smb->dev, "failed to enable OTP back-up: %d\n", ret);
+
+out:
+	return smb1360_disable_fg_access(smb);
+}
+
+static int smb1360_update_bounds(struct smb1360 *smb)
+{
+	unsigned int val;
+	int ret;
+
+	/* REV_1 does not allow access to FG config registers */
+	if (smb->revision == SMB1360_REV_1)
+		return 0;
+
+	val = abs(((SOC_DELTA_VAL * U8_MAX) / 100) - 1);
+	ret = regmap_write(smb->regmap, SOC_DELTA_REG, val);
+	if (ret)
+		return ret;
+
+	val = DIV_ROUND_CLOSEST(SOC_MIN_VAL * U8_MAX, 100);
+	ret = regmap_write(smb->regmap, SOC_MIN_REG, val);
+	if (ret)
+		return ret;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-voltage-min-mv", &val) == 0) {
+		val = (val - 2500) * U8_MAX;
+		val = DIV_ROUND_UP(val, 2500);
+		ret = regmap_write(smb->regmap, VTG_MIN_REG, val);
+		if (ret)
+			return ret;
+	}
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-voltage-empty-mv", &val) == 0) {
+		val = (val - 2500) * U8_MAX;
+		val = DIV_ROUND_UP(val, 2500);
+		ret = regmap_write(smb->regmap, VTG_EMPTY_REG, val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int smb1360_update_autorecharge_soc_threshold(struct smb1360 *smb)
+{
+	int ret;
+	u32 val;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-auto-recharge-soc", &val))
+		return 0;
+
+	ret = regmap_set_bits(smb->regmap, CFG_CHG_FUNC_CTRL_REG,
+			      CHG_RECHG_THRESH_FG_SRC_BIT);
+	if (ret)
+		return ret;
+
+	val = DIV_ROUND_UP(val * U8_MAX, 100);
+	return regmap_write(smb->regmap, FG_AUTO_RECHARGE_SOC, val);
+}
+
+static int smb1360_fg_config(struct smb1360 *smb)
+{
+	int ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	ret = smb1360_update_le16(smb, ACTUAL_CAPACITY_REG, "qcom,fg-batt-capacity-mah", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, NOMINAL_CAPACITY_REG, "qcom,fg-batt-capacity-mah", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, CC_TO_SOC_COEFF, "qcom,fg-cc-soc-coeff", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_SYS_CUTOFF_V_REG, "qcom,fg-cutoff-voltage-mv", 5000);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_ITERM_REG, "qcom,fg-iterm-ma", -2500);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_IBATT_STANDBY_REG, "qcom,fg-ibatt-standby-ma", 2500);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_CC_TO_CV_V_REG, "qcom,fg-cc-to-cv-mv", 5000);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_THERM_C1_COEFF_REG, "qcom,thermistor-c1-coeff", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_autorecharge_soc_threshold(smb);
+	if (ret) {
+		dev_err(smb->dev, "smb1360_update_autorecharge_soc_threshold failed\n");
+		goto disable_fg_access;
+	}
+
+disable_fg_access:
+	smb1360_disable_fg_access(smb);
+	return ret;
+}
+
+static int smb1360_check_cycle_stretch(struct smb1360 *smb)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(smb->regmap, STATUS_4_REG, &val);
+	if (ret)
+		return ret;
+
+	if (!(val & CYCLE_STRETCH_ACTIVE_BIT))
+		return 0;
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, CYCLE_STRETCH_CLEAR_BIT);
+	if (ret)
+		dev_err(smb->dev, "unable to clear cycle stretch: %d\n", ret);
+
+	return ret;
+}
+
+#ifdef CONFIG_SMB1360_DEBUG
+extern void smb1360_dump(struct i2c_client *client);
+extern void smb1360_dump_fg_scratch(struct i2c_client *fg_client);
+extern void smb1360_dump_fg(struct i2c_client *client);
+
+static void smb1360_dump_fg_access(struct smb1360 *smb)
+{
+	struct i2c_client *client = to_i2c_client(smb->dev);
+	struct i2c_client *fg_client = to_i2c_client(regmap_get_device(smb->fg_regmap));
+	int ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return;
+
+	smb1360_dump_fg_scratch(client);
+	smb1360_dump_fg(fg_client);
+
+	smb1360_disable_fg_access(smb);
+	smb1360_check_cycle_stretch(smb);
+}
+#else
+static inline void smb1360_dump(struct i2c_client *client) {}
+static inline void smb1360_dump_fg_access(struct smb1360 *smb) {}
+#endif
+
+static int smb1360_delayed_hw_init(struct smb1360 *smb)
+{
+	int ret;
+
+	/* Dump initial FG registers */
+	smb1360_dump_fg_access(smb);
+
+	ret = smb1360_check_batt_profile(smb);
+	if (ret) {
+		dev_err(smb->dev, "unable to modify battery profile: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_reconf_otp(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't reconfigure OTP: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_fg_reset(smb);
+	if (ret)
+		dev_err(smb->dev, "smb1360_fg_reset failed: %d\n", ret);
+
+	ret = smb1360_update_bounds(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't configure SOC/voltage bounds: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_fg_config(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't configure FG: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_check_cycle_stretch(smb);
+	if (ret) {
+		dev_err(smb->dev, "Unable to check cycle-stretch\n");
+		return ret;
+	}
+
+	ret = regmap_set_bits(smb->regmap, CMD_CHG_REG, CMD_CHG_EN);
+	if (ret) {
+		dev_err(smb->dev, "couldn't enable battery charging: %d\n", ret);
+		return ret;
+	}
+
+	/* Dump final registers */
+	smb1360_dump(to_i2c_client(smb->dev));
+	smb1360_dump_fg_access(smb);
+
+	return 0;
+}
+
+static void smb1360_delayed_init_work_fn(struct work_struct *work)
+{
+	int ret = 0;
+	struct smb1360 *smb = container_of(work, struct smb1360,
+					   delayed_init_work.work);
+
+	ret = smb1360_delayed_hw_init(smb);
+	if (!ret) {
+		power_supply_changed(smb->psy);
+		smb->initialized = true;
+	} else if (ret == -ETIMEDOUT) {
+		ret = smb1360_force_fg_reset(smb);
+		if (ret)
+			return;
+		schedule_delayed_work(&smb->delayed_init_work, 0);
+	}
+}
+
+static int smb1360_set_shutdown(struct smb1360 *smb, bool shutdown)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	bool polarity;
+
+	ret = regmap_read(smb->regmap, SHDN_CTRL_REG, &val);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't read SHDN_CTRL_REG: %d\n", ret);
+		return ret;
+	}
+
+	if (!(val & SHDN_CMD_USE_BIT))
+		return 0;
+
+	polarity = !!(val & SHDN_CMD_POLARITY_BIT);
+	val = (polarity == shutdown) ? SHDN_CMD_BIT : 0;
+
+	ret = regmap_update_bits(smb->regmap, CMD_IL_REG, SHDN_CMD_BIT, val);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't update shutdown: %d\n", ret);
+
+	return ret;
+}
+
+static inline int smb1360_poweroff(struct smb1360 *smb)
+{
+	return smb1360_set_shutdown(smb, true);
+}
+
+static inline int smb1360_poweron(struct smb1360 *smb)
+{
+	return smb1360_set_shutdown(smb, false);
+}
+
+static int smb1360_float_voltage_set(struct smb1360 *smb)
+{
+	u32 val;
+	int ret;
+
+	if (device_property_read_u32(smb->dev, "qcom,float-voltage-mv", &val)) {
+		/* Read float voltage from registers */
+		ret = regmap_read(smb->regmap, BATT_CHG_FLT_VTG_REG, &val);
+		if (ret)
+			return ret;
+
+		val &= VFLOAT_MASK;
+		smb->float_voltage = (val * VFLOAT_STEP_MV) + MIN_FLOAT_MV;
+		return 0;
+	}
+
+	if (val < MIN_FLOAT_MV || val > MAX_FLOAT_MV)
+		return -EINVAL;
+
+	smb->float_voltage = val;
+	val = (val - MIN_FLOAT_MV) / VFLOAT_STEP_MV;
+
+	return regmap_update_bits(smb->regmap,
+				  BATT_CHG_FLT_VTG_REG, VFLOAT_MASK, val);
+}
+
+static int smb1360_iterm_set(struct smb1360 *smb)
+{
+	int ret, iterm_ma;
+	u8 val;
+
+	if (device_property_read_bool(smb->dev, "qcom,iterm-disabled"))
+		return regmap_set_bits(smb->regmap, CFG_CHG_MISC_REG,
+				       CHG_CURR_TERM_DIS_BIT);
+
+	if (device_property_read_u32(smb->dev, "qcom,iterm-ma", &iterm_ma))
+		return 0;
+
+	if (smb->rsense_10mohm)
+		iterm_ma = iterm_ma / 2;
+
+	val = clamp(iterm_ma, 25, 200);
+	val = DIV_ROUND_UP(val, 25) - 1;
+
+	ret = regmap_update_bits(smb->regmap, CFG_BATT_CHG_REG,
+				 CHG_ITERM_MASK, val);
+	if (ret)
+		return ret;
+
+	ret = regmap_clear_bits(smb->regmap, CFG_CHG_MISC_REG,
+				CHG_CURR_TERM_DIS_BIT);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int smb1360_safety_time_set(struct smb1360 *smb)
+{
+	static const int chg_time[] = { 192, 384, 768, 1536, };
+	int ret, i;
+
+	u32 val;
+	u8 mask, data;
+
+	if (device_property_read_u32(smb->dev, "qcom,charging-timeout", &val))
+		return 0;
+
+	if (val > chg_time[ARRAY_SIZE(chg_time) - 1])
+		return -EINVAL;
+
+	mask = SAFETY_TIME_DISABLE_BIT;
+	data = SAFETY_TIME_DISABLE_BIT;
+
+	if (val != 0) {
+		mask = SAFETY_TIME_DISABLE_BIT | SAFETY_TIME_MINUTES_MASK;
+
+		for (i = 0; i < ARRAY_SIZE(chg_time); i++) {
+			if (val <= chg_time[i]) {
+				data = i << SAFETY_TIME_MINUTES_SHIFT;
+				break;
+			}
+		}
+	}
+
+	ret = regmap_update_bits(smb->regmap,
+				 CFG_SFY_TIMER_CTRL_REG, mask, data);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't update safety timer: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int smb1360_recharge_threshold_set(struct smb1360 *smb)
+{
+	u32 val;
+
+	if (device_property_read_u32(smb->dev, "qcom,recharge-thresh-mv", &val))
+		return 0;
+
+	if (device_property_read_bool(smb->dev, "qcom,recharge-disabled") &&
+	    device_property_read_bool(smb->dev, "qcom,chg-inhibit-disabled")) {
+		dev_err(smb->dev, "recharge: both disabled and mv set\n");
+		return -EINVAL;
+	}
+
+	if (val < MIN_RECHG_MV || val > MAX_RECHG_MV)
+		return -EINVAL;
+
+	val = (val / 100) << RECHG_MV_SHIFT;
+
+	return regmap_update_bits(smb->regmap,
+				  CFG_BATT_CHG_REG, RECHG_MV_MASK, val);
+}
+
+static int smb1360_update_temp_tresh(struct smb1360 *smb, u8 reg, const char *prop)
+{
+	int ret;
+	s32 temp;
+
+	if (device_property_read_u32(smb->dev, prop, &temp))
+		return 0;
+
+	ret = regmap_write(smb->regmap, reg, TEMP_THRE_SET(temp));
+	if (ret)
+		dev_err(smb->dev, "writing %s failed: %d\n", prop, ret);
+	return ret;
+}
+
+static int smb1360_find_fastchg_current(struct smb1360 *smb, int current_ma)
+{
+	static const int fastchg_current[] = {
+		450, 600, 750, 900, 1050, 1200, 1350, 1500,
+	};
+	int i;
+
+	for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+		if (fastchg_current[i] <= current_ma)
+			return i;
+	}
+
+	dev_err(smb->dev, "cannot find fastchg current %d\n", current_ma);
+	return -EINVAL;
+}
+
+static int smb1360_jeita_init(struct smb1360 *smb)
+{
+	int ret;
+	unsigned int tmp;
+	u32 comp_volt, comp_curr;
+
+	ret = smb1360_update_temp_tresh(smb, JEITA_SOFT_COLD_REG, "qcom,cool-bat-decidegc");
+	if (ret)
+		return ret;
+	ret = smb1360_update_temp_tresh(smb, JEITA_SOFT_HOT_REG, "qcom,warm-bat-decidegc");
+	if (ret)
+		return ret;
+
+	if (!device_property_read_bool(smb->dev, "qcom,soft-jeita-config"))
+		return 0;
+
+	if (device_property_read_u32(smb->dev, "qcom,soft-jeita-comp-voltage-mv", &comp_volt) ||
+	    device_property_read_u32(smb->dev, "qcom,soft-jeita-comp-current-ma", &comp_curr)) {
+		dev_err(smb->dev, "qcom,soft-jeita-comp-{voltage,current} required for soft JEITA\n");
+		return -EINVAL;
+	}
+
+	if (comp_volt >= smb->float_voltage) {
+		dev_err(smb->dev, "JEITA compensation voltage larger than float voltage\n");
+		return -EINVAL;
+	}
+
+	tmp = (smb->float_voltage - comp_volt) / 10;
+	ret = regmap_update_bits(smb->regmap, CFG_FVC_REG, FLT_VTG_COMP_MASK, tmp);
+	if (ret)
+		return ret;
+
+	ret = smb1360_find_fastchg_current(smb, comp_curr);
+	if (ret < 0)
+		return ret;
+
+	/* Write compensation current and enable JEITA compensation */
+	return regmap_write(smb->regmap, CHG_CMP_CFG, ret | JEITA_COMP_EN_BIT);
+}
+
+static int smb1360_configure_irq(struct smb1360 *smb)
+{
+	int ret;
+
+	/* enabling only interesting interrupts */
+	ret = regmap_write(smb->regmap, IRQ_CFG_REG,
+			   IRQ_INTERNAL_TEMPERATURE_BIT
+			   | IRQ_DCIN_UV_BIT
+			   | IRQ_BAT_HOT_COLD_SOFT_BIT
+			   | IRQ_HOT_COLD_HARD_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set irq1: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(smb->regmap, IRQ2_CFG_REG,
+			   IRQ2_VBAT_LOW_BIT
+			   | IRQ2_BATT_MISSING_BIT
+			   | IRQ2_POWER_OK_BIT
+			   | IRQ2_CHG_PHASE_CHANGE_BIT
+			   | IRQ2_CHG_ERR_BIT
+			   | IRQ2_SAFETY_TIMER_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set irq2: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(smb->regmap, IRQ3_CFG_REG,
+			   IRQ3_SOC_FULL_BIT
+			   | IRQ3_SOC_EMPTY_BIT
+			   | IRQ3_SOC_MAX_BIT
+			   | IRQ3_SOC_MIN_BIT
+			   | IRQ3_SOC_CHANGE_BIT
+			   | IRQ3_FG_ACCESS_OK_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't set irq3: %d\n", ret);
+
+	return ret;
+}
+
+static int smb1360_hw_init(struct i2c_client *client)
+{
+	struct smb1360 *smb = i2c_get_clientdata(client);
+	int ret;
+	u8 val;
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, ALLOW_VOLATILE_BIT);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't configure volatile: %d\n", ret);
+		return ret;
+	}
+
+	/* Bring SMB1360 out of shutdown, if it was enabled by default */
+	ret = smb1360_poweron(smb);
+	if (ret < 0) {
+		dev_err(smb->dev, "smb1360 power on failed\n");
+		return ret;
+	}
+
+	/* en chg by cmd reg, en chg by writing bit 1, en auto pre to fast */
+	ret = regmap_clear_bits(smb->regmap, CFG_CHG_MISC_REG,
+				CHG_EN_BY_PIN_BIT | CHG_EN_ACTIVE_LOW_BIT
+				| PRE_TO_FAST_REQ_CMD_BIT);
+	if (ret < 0)
+		return ret;
+
+	/* USB/AC pin settings */
+	ret = regmap_update_bits(smb->regmap, CFG_BATT_CHG_ICL_REG,
+				 AC_INPUT_ICL_PIN_BIT | AC_INPUT_PIN_HIGH_BIT,
+				 AC_INPUT_PIN_HIGH_BIT);
+	if (ret < 0)
+		return ret;
+
+	/* AICL enable and set input-uv glitch flt to 20ms */
+	ret = regmap_set_bits(smb->regmap, CFG_GLITCH_FLT_REG,
+			      AICL_ENABLED_BIT | INPUT_UV_GLITCH_FLT_20MS_BIT);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_float_voltage_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_iterm_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_safety_time_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_recharge_threshold_set(smb);
+	if (ret)
+		return ret;
+
+	/* Always stop charging on over-voltage condition */
+	val = CFG_BAT_OV_ENDS_CHG_CYC;
+	if (device_property_read_bool(smb->dev, "qcom,recharge-disabled"))
+		val |= CFG_AUTO_RECHG_DIS_BIT;
+	if (!device_property_read_bool(smb->dev, "qcom,chg-inhibit-disabled"))
+		val |= CFG_CHG_INHIBIT_EN_BIT;
+
+	ret = regmap_update_bits(smb->regmap, CFG_CHG_MISC_REG,
+				 CFG_BAT_OV_ENDS_CHG_CYC
+				 | CFG_AUTO_RECHG_DIS_BIT
+				 | CFG_CHG_INHIBIT_EN_BIT, val);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set bat_ov_ends_charge/rechg/chg_inhibit: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_jeita_init(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't init jeita: %d\n", ret);
+		return ret;
+	}
+
+	/* interrupt enabling - active low */
+	if (client->irq) {
+		ret = regmap_update_bits(smb->regmap, CFG_STAT_CTRL_REG,
+					 CHG_STAT_IRQ_ONLY_BIT
+					 | CHG_STAT_ACTIVE_HIGH_BIT
+					 | CHG_STAT_DISABLE_BIT
+					 | CHG_TEMP_CHG_ERR_BLINK_BIT,
+					 CHG_STAT_IRQ_ONLY_BIT);
+		if (ret < 0) {
+			dev_err(smb->dev, "couldn't set irq: %d\n", ret);
+			return ret;
+		}
+
+		ret = smb1360_configure_irq(smb);
+		if (ret < 0) {
+			dev_err(smb->dev, "couldn't configure irq: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int smb1360_parse_properties(struct smb1360 *smb)
+{
+	struct device *dev = smb->dev;
+
+	smb->shdn_after_pwroff = device_property_read_bool(dev, "qcom,shdn-after-pwroff");
+	smb->rsense_10mohm = device_property_read_bool(dev, "qcom,rsense-10mohm");
+
+	return 0;
+}
+
+static const struct regmap_config smb1360_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+};
+
+static const struct power_supply_desc smb1360_battery_desc = {
+	.name			= "smb1360-battery",
+	.type			= POWER_SUPPLY_TYPE_BATTERY,
+	.get_property		= smb1360_get_property,
+	.properties		= smb1360_props,
+	.num_properties		= ARRAY_SIZE(smb1360_props),
+};
+
+static int smb1360_probe(struct i2c_client *client)
+{
+	int ret;
+	struct power_supply_config psy_cfg = {};
+	struct device *dev = &client->dev;
+	struct i2c_client *fg_client;
+	struct smb1360 *smb;
+	u16 fg_address;
+
+	if (client->addr & FG_I2C_CFG_MASK) {
+		dev_err(&client->dev, "invalid i2c address: %#x\n", client->addr);
+		return -EINVAL;
+	}
+
+	smb = devm_kzalloc(&client->dev, sizeof(*smb), GFP_KERNEL);
+	if (!smb)
+		return -EINVAL;
+
+	smb->dev = dev;
+
+	smb->regmap = devm_regmap_init_i2c(client, &smb1360_regmap_config);
+	if (IS_ERR(smb->regmap)) {
+		dev_err(&client->dev, "failed to init regmap\n");
+		return -EINVAL;
+	}
+
+	INIT_DELAYED_WORK(&smb->delayed_init_work,
+			  smb1360_delayed_init_work_fn);
+	init_completion(&smb->fg_mem_access_granted);
+
+	ret = regmap_read(smb->regmap, REVISION_CTRL_REG, &smb->revision);
+	if (ret) {
+		dev_err(smb->dev, "couldn't read revision: %d\n", ret);
+		return ret;
+	}
+	smb->revision &= DEVICE_REV_MASK;
+	dev_dbg(smb->dev, "device revision: %d\n", smb->revision);
+
+	fg_address = client->addr | FG_CFG_I2C_ADDR;
+	fg_client = devm_i2c_new_dummy_device(dev, client->adapter, fg_address);
+	if (IS_ERR(fg_client)) {
+		dev_err(&client->dev, "failed to init fg i2c client\n");
+		return -EINVAL;
+	}
+
+	smb->fg_regmap = devm_regmap_init_i2c(fg_client, &smb1360_regmap_config);
+	if (IS_ERR(smb->fg_regmap)) {
+		dev_err(&client->dev, "failed to init fg regmap\n");
+		return -EINVAL;
+	}
+
+	ret = smb1360_parse_properties(smb);
+	if (ret) {
+		dev_err(&client->dev, "error parsing device tree: %d\n", ret);
+		return ret;
+	}
+
+	device_init_wakeup(smb->dev, 1);
+	i2c_set_clientdata(client, smb);
+
+	/* Dump initial registers */
+	smb1360_dump(client);
+
+	ret = smb1360_hw_init(client);
+	if (ret < 0) {
+		dev_err(&client->dev, "unable to initialize hw: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_raw_read(smb->regmap, IRQ_REG, smb->irqstat, sizeof(smb->irqstat));
+	if (ret < 0) {
+		dev_err(&client->dev, "unable to determine init status: %d\n", ret);
+		return ret;
+	}
+
+	smb->edev = devm_extcon_dev_allocate(dev, smb1360_usb_extcon_cable);
+	if (IS_ERR(smb->edev))
+		return PTR_ERR(smb->edev);
+
+	ret = devm_extcon_dev_register(dev, smb->edev);
+	if (ret < 0)
+		return ret;
+
+	extcon_set_state_sync(smb->edev, EXTCON_USB,
+			      !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT));
+
+	ret = smb1360_register_vbus_regulator(smb);
+	if (ret < 0)
+		return ret;
+
+	psy_cfg.drv_data = smb;
+	smb->psy = devm_power_supply_register(&client->dev, &smb1360_battery_desc,
+					      &psy_cfg);
+	if (IS_ERR(smb->psy)) {
+		dev_err(&client->dev, "failed to register power supply\n");
+		ret = PTR_ERR(smb->psy);
+		return ret;
+	}
+
+	if (client->irq) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+						smb1360_irq, IRQF_ONESHOT,
+						NULL, smb);
+		if (ret) {
+			dev_err(&client->dev,
+				"request irq %d failed\n", client->irq);
+			return ret;
+		}
+
+		enable_irq_wake(client->irq);
+	}
+
+	schedule_delayed_work(&smb->delayed_init_work,
+			      msecs_to_jiffies(SMB1360_POWERON_DELAY_MS));
+
+	return 0;
+}
+
+static void smb1360_shutdown(struct i2c_client *client)
+{
+	int ret;
+	struct smb1360 *smb = i2c_get_clientdata(client);
+
+	ret = regulator_disable_regmap(smb->otg_vreg);
+	if (ret)
+		dev_err(smb->dev, "couldn't disable OTG: %d\n", ret);
+
+	if (smb->shdn_after_pwroff) {
+		ret = smb1360_poweroff(smb);
+		if (ret)
+			dev_err(smb->dev, "couldn't shutdown: %d\n", ret);
+	}
+}
+
+static int smb1360_suspend(struct device *dev)
+{
+	int ret;
+	struct smb1360 *smb = dev_get_drvdata(dev);
+
+	ret = regmap_write(smb->regmap, IRQ_CFG_REG, IRQ_DCIN_UV_BIT
+						| IRQ_BAT_HOT_COLD_SOFT_BIT
+						| IRQ_HOT_COLD_HARD_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq_cfg: %d\n", ret);
+
+	ret = regmap_write(smb->regmap, IRQ2_CFG_REG, IRQ2_BATT_MISSING_BIT
+						| IRQ2_VBAT_LOW_BIT
+						| IRQ2_POWER_OK_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq2_cfg: %d\n", ret);
+
+	ret = regmap_write(smb->regmap, IRQ3_CFG_REG, IRQ3_SOC_FULL_BIT
+					| IRQ3_SOC_MIN_BIT
+					| IRQ3_SOC_EMPTY_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq3_cfg: %d\n", ret);
+
+	return 0;
+}
+
+static int smb1360_resume(struct device *dev)
+{
+	int ret;
+	struct smb1360 *smb = dev_get_drvdata(dev);
+
+	ret = smb1360_configure_irq(smb);
+	if (ret)
+		return ret;
+
+	power_supply_changed(smb->psy);
+
+	return 0;
+}
+
+static const struct dev_pm_ops smb1360_pm_ops = {
+	.resume = smb1360_resume,
+	.suspend = smb1360_suspend,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id smb1360_match_table[] = {
+	{ .compatible = "qcom,smb1360" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, smb1360_match_table);
+#endif
+
+static struct i2c_driver smb1360_driver = {
+	.driver	= {
+		.name = "smb1360",
+		.of_match_table = of_match_ptr(smb1360_match_table),
+		.pm = &smb1360_pm_ops,
+	},
+	.probe_new = smb1360_probe,
+	.shutdown = smb1360_shutdown,
+};
+
+module_i2c_driver(smb1360_driver);
+
+MODULE_DESCRIPTION("SMB1360 Charger and Fuel Gauge");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/remoteproc/qcom_q6v5_mss.c b/drivers/remoteproc/qcom_q6v5_mss.c
index ca1c7387776..ece2ca3c214 100644
--- a/drivers/remoteproc/qcom_q6v5_mss.c
+++ b/drivers/remoteproc/qcom_q6v5_mss.c
@@ -1815,8 +1815,14 @@ static int q6v5_probe(struct platform_device *pdev)
 	if (ret)
 		goto remove_sysmon_subdev;
 
+	ret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
+	if (ret)
+		goto remove_rproc;
+
 	return 0;
 
+remove_rproc:
+	rproc_del(rproc);
 remove_sysmon_subdev:
 	qcom_remove_sysmon_subdev(qproc->sysmon);
 remove_subdevs:
@@ -1838,6 +1844,7 @@ static int q6v5_remove(struct platform_device *pdev)
 	struct q6v5 *qproc = platform_get_drvdata(pdev);
 	struct rproc *rproc = qproc->rproc;
 
+	of_platform_depopulate(&pdev->dev);
 	rproc_del(rproc);
 
 	qcom_remove_sysmon_subdev(qproc->sysmon);
diff --git a/drivers/soc/qcom/Kconfig b/drivers/soc/qcom/Kconfig
index 499718e131d..91afaa9a8b7 100644
--- a/drivers/soc/qcom/Kconfig
+++ b/drivers/soc/qcom/Kconfig
@@ -191,6 +191,15 @@ config QCOM_SOCINFO
 	 Say yes here to support the Qualcomm socinfo driver, providing
 	 information about the SoC to user space.
 
+config QCOM_SPM
+	tristate "Qualcomm Subsystem Power Manager (SPM)"
+	depends on ARCH_QCOM
+	select QCOM_SCM
+	help
+	  Enable the support for the Qualcomm Subsystem Power Manager, used
+	  to manage cores, L2 low power modes and to configure the internal
+	  Adaptive Voltage Scaler parameters, where supported.
+
 config QCOM_WCNSS_CTRL
 	tristate "Qualcomm WCNSS control driver"
 	depends on ARCH_QCOM || COMPILE_TEST
@@ -210,4 +219,12 @@ config QCOM_APR
 	  application processor and QDSP6. APR is
 	  used by audio driver to configure QDSP6
 	  ASM, ADM and AFE modules.
+
+config QCOM_MEMSHARE_QMI_SERVICE
+       select QCOM_QMI_HELPERS
+       tristate "Qualcomm QMI Shared Memory Service (MEMSHARE)"
+       help
+	  This service provides additional memory regions on request from
+	  remote processors. On some platforms it is used for GPS by
+	  the location service in the modem subsystem.
 endmenu
diff --git a/drivers/soc/qcom/Makefile b/drivers/soc/qcom/Makefile
index ad675a6593d..bad1302a964 100644
--- a/drivers/soc/qcom/Makefile
+++ b/drivers/soc/qcom/Makefile
@@ -20,9 +20,12 @@ obj-$(CONFIG_QCOM_SMEM_STATE) += smem_state.o
 obj-$(CONFIG_QCOM_SMP2P)	+= smp2p.o
 obj-$(CONFIG_QCOM_SMSM)	+= smsm.o
 obj-$(CONFIG_QCOM_SOCINFO)	+= socinfo.o
+obj-$(CONFIG_QCOM_SPM)		+= spm.o
 obj-$(CONFIG_QCOM_WCNSS_CTRL) += wcnss_ctrl.o
 obj-$(CONFIG_QCOM_APR) += apr.o
 obj-$(CONFIG_QCOM_LLCC) += llcc-qcom.o
 obj-$(CONFIG_QCOM_RPMHPD) += rpmhpd.o
 obj-$(CONFIG_QCOM_RPMPD) += rpmpd.o
 obj-$(CONFIG_QCOM_KRYO_L2_ACCESSORS) +=	kryo-l2-accessors.o
+obj-$(CONFIG_QCOM_MEMSHARE_QMI_SERVICE) += qcom_memshare.o
+qcom_memshare-y := memshare.o memshare_qmi_msg.o
diff --git a/drivers/soc/qcom/memshare.c b/drivers/soc/qcom/memshare.c
new file mode 100644
index 00000000000..a19858b9127
--- /dev/null
+++ b/drivers/soc/qcom/memshare.c
@@ -0,0 +1,501 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/net.h>
+#include <linux/soc/qcom/qmi.h>
+
+#include "memshare_qmi_msg.h"
+
+#define MEMSHARE_MAX_CLIENTS 10
+
+struct memshare_client {
+	u32 id;
+	u32 proc_id;
+	u32 qrtr_node;
+	u32 size;
+	phys_addr_t phy_addr;
+};
+
+struct memshare {
+	struct device *dev;
+	struct qmi_handle qmi;
+	unsigned int client_cnt;
+	struct memshare_client *legacy_client;
+	struct memshare_client *clients[MEMSHARE_MAX_CLIENTS];
+};
+
+static struct memshare_client *memshare_get_client(struct memshare *share, u32 id, u32 proc_id)
+{
+	int i;
+
+	for (i = 0; i < share->client_cnt; i++)
+		if (share->clients[i]->id == id && share->clients[i]->proc_id == proc_id)
+			return share->clients[i];
+
+	return NULL;
+}
+
+static void memshare_alloc_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+				       struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_alloc_req_msg_v01 *req = data;
+	struct mem_alloc_resp_msg_v01 resp = { .resp = QMI_RESULT_FAILURE_V01 };
+	struct memshare_client *client = share->legacy_client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"alloc_req: num_bytes=%d, block_alignment_valid=%d, block_alignment=%d, node=%d\n",
+		req->num_bytes,
+		req->block_alignment_valid,
+		req->block_alignment,
+		sq->sq_node
+	);
+
+	if (!client) {
+		dev_err(share->dev, "Unknown request from legacy client (size=%d, node=%d)\n",
+			req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (client->size && client->size != req->num_bytes) {
+		dev_err(share->dev, "Got a request with wrong size (size=%d)\n",
+			req->num_bytes);
+		goto send_response;
+	}
+
+	if (req->block_alignment_valid)
+		if (client->phy_addr % MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment) != 0)
+			dev_warn(share->dev, "Memory region is not aligned by %d bytes\n",
+				 MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment));
+
+	if (!client->phy_addr) {
+		dev_info(share->dev,
+			 "Client sent a request but no memory is configured (size=%d, node=%d)\n",
+			 req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	resp.resp = QMI_RESULT_SUCCESS_V01;
+	resp.handle_valid = true;
+	resp.handle = client->phy_addr;
+	resp.num_bytes_valid = true;
+	resp.num_bytes = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_ALLOC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_alloc_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_free_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+				      struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_free_req_msg_v01 *req = data;
+	struct mem_free_resp_msg_v01 resp = { .resp = QMI_RESULT_FAILURE_V01 };
+	struct memshare_client *client = share->legacy_client;
+	int ret;
+
+	dev_dbg(share->dev, "free_req: node=%d\n", sq->sq_node);
+
+	if (!client) {
+		dev_err(share->dev, "Unknown request from legacy client\n");
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (client->phy_addr != req->handle) {
+		dev_err(share->dev, "Got a request with wrong address\n");
+		goto send_response;
+	}
+
+	resp.resp = QMI_RESULT_SUCCESS_V01;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_FREE_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_free_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_alloc_generic_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					       struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_alloc_generic_req_msg_v01 *req = data;
+	struct mem_alloc_generic_resp_msg_v01 *resp;
+	struct memshare_client *client;
+	int ret;
+
+	resp = kzalloc(sizeof(*resp), GFP_KERNEL);
+	if (!resp)
+		return;
+
+	resp->resp.result = QMI_RESULT_FAILURE_V01;
+	resp->resp.error = QMI_ERR_INTERNAL_V01;
+
+	dev_dbg(share->dev,
+		"alloc_generic_req: num_bytes=%d, client_id=%d, proc_id=%d, sequence_id=%d, "
+		"alloc_contiguous_valid=%d, alloc_contiguous=%d, block_alignment_valid=%d, "
+		"block_alignment=%d, node=%d\n",
+		req->num_bytes,
+		req->client_id,
+		req->proc_id,
+		req->sequence_id,
+		req->alloc_contiguous_valid,
+		req->alloc_contiguous,
+		req->block_alignment_valid,
+		req->block_alignment,
+		sq->sq_node
+	);
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev,
+			"Got a request from unknown client (id=%d, proc=%d, size=%d, node=%d)\n",
+			req->client_id, req->proc_id, req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (!client->phy_addr) {
+		dev_info(share->dev,
+			 "Client sent a request but no memory is configured "
+			 "(id=%d, proc=%d, size=%d, node=%d)\n",
+			 req->client_id, req->proc_id, req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (client->size != req->num_bytes) {
+		dev_err(share->dev,
+			"Got a request with wrong size (id=%d, proc=%d, size=%d)\n",
+			req->client_id, req->proc_id, req->num_bytes);
+		goto send_response;
+	}
+
+	if (req->block_alignment_valid)
+		if (client->phy_addr % MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment) != 0)
+			dev_warn(share->dev, "Memory region is not aligned by %d bytes\n",
+				 MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment));
+
+	resp->resp.result = QMI_RESULT_SUCCESS_V01;
+	resp->resp.error = QMI_ERR_NONE_V01;
+	resp->sequence_id_valid = true;
+	resp->sequence_id = req->sequence_id;
+	resp->dhms_mem_alloc_addr_info_valid = true;
+	resp->dhms_mem_alloc_addr_info_len = 1;
+	resp->dhms_mem_alloc_addr_info[0].phy_addr = client->phy_addr;
+	resp->dhms_mem_alloc_addr_info[0].num_bytes = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_ALLOC_GENERIC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_alloc_generic_resp_msg_data_v01_ei, resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+
+	kfree(resp);
+}
+
+static void memshare_free_generic_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					      struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_free_generic_req_msg_v01 *req = data;
+	struct mem_free_generic_resp_msg_v01 resp = {
+		.resp.result = QMI_RESULT_FAILURE_V01,
+		.resp.error = QMI_ERR_INTERNAL_V01,
+	};
+	struct memshare_client *client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"free_generic_req: dhms_mem_alloc_addr_info_len=%d, client_id_valid=%d, "
+		"client_id=%d, proc_id_valid=%d, proc_id=%d, node=%d\n",
+		req->dhms_mem_alloc_addr_info_len,
+		req->client_id_valid,
+		req->client_id,
+		req->proc_id_valid,
+		req->proc_id,
+		sq->sq_node
+	);
+
+	if (req->dhms_mem_alloc_addr_info_len != 1) {
+		dev_err(share->dev, "addr_info_len = %d is unexpected\n",
+			req->dhms_mem_alloc_addr_info_len);
+		goto send_response;
+	}
+
+	if (!req->client_id_valid || !req->proc_id_valid) {
+		dev_err(share->dev, "Got a request from unknown client\n");
+		goto send_response;
+	}
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev, "Got a request from unknown client (id=%d, proc=%d)\n",
+			req->client_id, req->proc_id);
+		goto send_response;
+	}
+
+	if (req->dhms_mem_alloc_addr_info[0].phy_addr != client->phy_addr) {
+		dev_err(share->dev, "Client sent invalid handle\n");
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	resp.resp.result = QMI_RESULT_SUCCESS_V01;
+	resp.resp.error = QMI_ERR_NONE_V01;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_FREE_GENERIC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_free_generic_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_query_size_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					    struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_query_size_req_msg_v01 *req = data;
+	struct mem_query_size_rsp_msg_v01 resp = {
+		.resp.result = QMI_RESULT_FAILURE_V01,
+		.resp.error = QMI_ERR_INTERNAL_V01,
+	};
+	struct memshare_client *client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"query_size_req: client_id=%d, proc_id_valid=%d, proc_id=%d, node=%d\n",
+		req->client_id,
+		req->proc_id_valid,
+		req->proc_id,
+		sq->sq_node
+	);
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev, "Got a request from unknown client (id=%d, proc=%d)\n",
+			req->client_id, req->proc_id);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (!client->phy_addr)
+		goto send_response;
+
+	resp.resp.result = QMI_RESULT_SUCCESS_V01;
+	resp.resp.error = QMI_ERR_NONE_V01;
+	resp.size_valid = true;
+	resp.size = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_QUERY_SIZE_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_query_size_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static struct qmi_msg_handler memshare_handlers[] = {
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_ALLOC_MSG_V01,
+		.ei = mem_alloc_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_alloc_req_msg_v01),
+		.fn = memshare_alloc_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_FREE_MSG_V01,
+		.ei = mem_free_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_free_req_msg_v01),
+		.fn = memshare_free_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_ALLOC_GENERIC_MSG_V01,
+		.ei = mem_alloc_generic_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_alloc_generic_req_msg_v01),
+		.fn = memshare_alloc_generic_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_FREE_GENERIC_MSG_V01,
+		.ei = mem_free_generic_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_free_generic_req_msg_v01),
+		.fn = memshare_free_generic_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_QUERY_SIZE_MSG_V01,
+		.ei = mem_query_size_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_query_size_req_msg_v01),
+		.fn = memshare_query_size_req_handler,
+	},
+	{ /* sentinel */ }
+};
+
+static int memshare_probe_dt(struct memshare *share)
+{
+	struct device_node *np = share->dev->of_node;
+	struct device_node *proc_node = NULL, *client_node = NULL, *mem_node = NULL;
+	int ret = 0;
+	u32 proc_id, qrtr_node;
+	struct memshare_client *client;
+	phandle legacy_client = 0;
+	struct resource reserved_memory;
+
+	ret = of_property_read_u32(np, "qcom,legacy-client", &legacy_client);
+	if (ret && ret != -EINVAL)
+		return ret;
+
+	for_each_available_child_of_node(np, proc_node) {
+		ret = of_property_read_u32(proc_node, "reg", &proc_id);
+		if (ret)
+			goto error;
+
+		ret = of_property_read_u32(proc_node, "qcom,qrtr-node", &qrtr_node);
+		if (ret)
+			goto error;
+
+		for_each_available_child_of_node(proc_node, client_node) {
+			if (share->client_cnt >= MEMSHARE_MAX_CLIENTS) {
+				ret = -EINVAL;
+				goto error;
+			}
+
+			client = devm_kzalloc(share->dev, sizeof(*client), GFP_KERNEL);
+			if (!client) {
+				ret = -ENOMEM;
+				goto error;
+			}
+
+			ret = of_property_read_u32(client_node, "reg", &client->id);
+			if (ret)
+				goto error;
+
+			client->proc_id = proc_id;
+			client->qrtr_node = qrtr_node;
+
+			mem_node = of_parse_phandle(client_node, "memory-region", 0);
+			if (mem_node) {
+				ret = of_address_to_resource(mem_node, 0, &reserved_memory);
+				of_node_put(mem_node);
+				if (ret)
+					goto error;
+
+				client->phy_addr = reserved_memory.start;
+				client->size = resource_size(&reserved_memory);
+			}
+
+			if (client_node->phandle == legacy_client)
+				share->legacy_client = client;
+
+			share->clients[share->client_cnt] = client;
+			share->client_cnt++;
+		}
+	}
+
+	return 0;
+
+error:
+	of_node_put(client_node);
+	of_node_put(proc_node);
+	return ret;
+}
+
+static int memshare_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct memshare *share;
+	int ret;
+
+	share = devm_kzalloc(&pdev->dev, sizeof(*share), GFP_KERNEL);
+	if (!share)
+		return -ENOMEM;
+
+	share->dev = dev;
+	dev_set_drvdata(&pdev->dev, share);
+
+	ret = qmi_handle_init(&share->qmi, MEM_MAX_MSG_LEN_V01, NULL, memshare_handlers);
+	if (ret < 0)
+		return ret;
+
+	ret = memshare_probe_dt(share);
+	if (ret < 0)
+		goto error;
+
+	ret = qmi_add_server(&share->qmi, MEM_SERVICE_SVC_ID,
+			     MEM_SERVICE_VER, MEM_SERVICE_INS_ID);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	qmi_handle_release(&share->qmi);
+	return ret;
+}
+
+static int memshare_remove(struct platform_device *pdev)
+{
+	struct memshare *share = dev_get_drvdata(&pdev->dev);
+
+	qmi_handle_release(&share->qmi);
+
+	return 0;
+}
+
+static const struct of_device_id memshare_of_match[] = {
+	{ .compatible = "qcom,memshare", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, memshare_of_match);
+
+static struct platform_driver memshare_driver = {
+	.probe = memshare_probe,
+	.remove = memshare_remove,
+	.driver = {
+		.name = "qcom-memshare",
+		.of_match_table = of_match_ptr(memshare_of_match),
+	},
+};
+module_platform_driver(memshare_driver);
+
+MODULE_DESCRIPTION("Qualcomm Memory Share Service");
+MODULE_AUTHOR("Nikita Travkin <nikitos.tr@gmail.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/qcom/memshare_qmi_msg.c b/drivers/soc/qcom/memshare_qmi_msg.c
new file mode 100644
index 00000000000..0cbccaaa799
--- /dev/null
+++ b/drivers/soc/qcom/memshare_qmi_msg.c
@@ -0,0 +1,370 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2013-2015, 2017-2018, The Linux Foundation. All rights reserved.
+
+#include <linux/stddef.h>
+#include <linux/soc/qcom/qmi.h>
+
+#include "memshare_qmi_msg.h"
+
+struct qmi_elem_info mem_alloc_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, num_bytes),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, block_alignment_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, block_alignment_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, block_alignment),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, block_alignment),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, resp),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, resp),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, handle_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, handle_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, handle),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, handle),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, num_bytes_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, num_bytes_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, num_bytes),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_req_msg_v01, handle),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_req_msg_v01, handle),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_resp_msg_v01, resp),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_resp_msg_v01, resp),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info dhms_mem_alloc_addr_info_type_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct dhms_mem_alloc_addr_info_type_v01, phy_addr),
+		.tlv_type       = QMI_COMMON_TLV_TYPE,
+		.offset         = offsetof(struct dhms_mem_alloc_addr_info_type_v01, phy_addr),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct dhms_mem_alloc_addr_info_type_v01, num_bytes),
+		.tlv_type       = QMI_COMMON_TLV_TYPE,
+		.offset         = offsetof(struct dhms_mem_alloc_addr_info_type_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_generic_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, num_bytes),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, client_id),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, proc_id),
+		.tlv_type       = 0x03,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, sequence_id),
+		.tlv_type       = 0x04,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, sequence_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       alloc_contiguous_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01,
+					   alloc_contiguous_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_1_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       alloc_contiguous),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, alloc_contiguous),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       block_alignment_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01,
+					   block_alignment_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       block_alignment),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, block_alignment),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_generic_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       sequence_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, sequence_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01, sequence_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, sequence_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info_valid),
+	},
+	{
+		.data_type	= QMI_DATA_LEN,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info_len),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info_len),
+	},
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = MAX_ARR_CNT_V01,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info),
+		.array_type     = VAR_LEN_ARRAY,
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info),
+		.ei_array       = dhms_mem_alloc_addr_info_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_generic_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_DATA_LEN,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01,
+					       dhms_mem_alloc_addr_info_len),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01,
+					   dhms_mem_alloc_addr_info_len),
+	},
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = MAX_ARR_CNT_V01,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01,
+					       dhms_mem_alloc_addr_info),
+		.array_type     = VAR_LEN_ARRAY,
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01,
+					   dhms_mem_alloc_addr_info),
+		.ei_array	= dhms_mem_alloc_addr_info_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, client_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, client_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, client_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, proc_id_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, proc_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, proc_id),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_generic_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_resp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_free_generic_resp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_query_size_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, client_id),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, proc_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, proc_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, proc_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_query_size_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, size_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, size_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, size),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, size),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
diff --git a/drivers/soc/qcom/memshare_qmi_msg.h b/drivers/soc/qcom/memshare_qmi_msg.h
new file mode 100644
index 00000000000..c436330a071
--- /dev/null
+++ b/drivers/soc/qcom/memshare_qmi_msg.h
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2013-2015, 2017-2018, The Linux Foundation. All rights reserved. */
+
+#ifndef HEAP_MEM_EXT_SERVICE_01_H
+#define HEAP_MEM_EXT_SERVICE_01_H
+
+#include <linux/types.h>
+#include <linux/soc/qcom/qmi.h>
+
+#define MEM_SERVICE_SVC_ID 0x00000034
+#define MEM_SERVICE_INS_ID 1
+#define MEM_SERVICE_VER 1
+
+/* Service Message Definition */
+#define MEM_ALLOC_MSG_V01 0x0020
+#define MEM_FREE_MSG_V01 0x0021
+#define MEM_ALLOC_GENERIC_MSG_V01 0x0022
+#define MEM_FREE_GENERIC_MSG_V01 0x0023
+#define MEM_QUERY_SIZE_MSG_V01 0x0024
+
+#define MEM_MAX_MSG_LEN_V01 255
+#define MAX_ARR_CNT_V01 64
+
+#define MEM_BLOCK_ALIGN_TO_BYTES(x) (2 << (x)) /* 0..11 */
+
+/**
+ * Unless stated otherwise, any property X that is paired with X_valid
+ * property is an optional property. Other properties are mandatory.
+ */
+
+/**
+ * struct dhms_mem_alloc_addr_info_type_v01 - Element of memory block array.
+ * @phy_addr: Physical address of memory block.
+ * @num_bytes: Size of memory block.
+ */
+struct dhms_mem_alloc_addr_info_type_v01 {
+	u64 phy_addr;
+	u32 num_bytes;
+};
+
+/**
+ * struct mem_alloc_req_msg_v01 - Legacy memory allocation request.
+ * @num_bytes: Requested size.
+ * @block_alignment_valid: Must be set to true if block_alignment is being passed.
+ * @block_alignment: The block alignment for the memory block to be allocated.
+ *
+ * Request Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem.
+ */
+struct mem_alloc_req_msg_v01 {
+	u32 num_bytes;
+	u8 block_alignment_valid;
+	u32 block_alignment;
+};
+
+/**
+ * struct mem_alloc_resp_msg_v01 - Response for legacy allocation memory request.
+ * @resp: Result Code. The result of the requested memory operation.
+ * @handle_valid: Must be set to true if handle is being passed.
+ * @handle: Memory Block Handle. The physical address of the memory allocated on the HLOS.
+ * @num_bytes_valid: Must be set to true if num_bytes is being passed.
+ * @num_bytes: Memory block size. The number of bytes actually allocated for the request.
+ *             This value can be smaller than the size requested in QMI_DHMS_MEM_ALLOC_REQ_MSG.
+ *
+ * Response Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_resp_msg_v01 {
+	u16 resp;
+	u8 handle_valid;
+	u64 handle;
+	u8 num_bytes_valid;
+	u32 num_bytes;
+};
+
+/**
+ * struct mem_free_req_msg_v01 - Legacy memory free request.
+ * @handle: Physical address of memory to be freed.
+ *
+ * Request Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem.
+ */
+struct mem_free_req_msg_v01 {
+	u64 handle;
+};
+
+/**
+ * struct mem_free_resp_msg_v01 - Response for legacy memory free request.
+ * @resp: Result of the requested memory operation.
+ *
+ * Response Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem.
+ */
+struct mem_free_resp_msg_v01 {
+	u16 resp;
+};
+
+/**
+ * struct mem_alloc_generic_req_msg_v01 - Memory allocation request.
+ * @num_bytes: Requested size.
+ * @client_id: Client ID.
+ * @proc_id: Peripheral ID.
+ * @sequence_id: Sequence ID.
+ * @alloc_contiguous_valid: Must be set to true if alloc_contiguous is being passed.
+ * @alloc_contiguous: alloc_contiguous is used to identify that clients are requesting
+ *                    for contiguous or non contiguous memory, default is contiguous.
+ *                    0 = non contiguous else contiguous.
+ * @block_alignment_valid: Must be set to true if block_alignment is being passed.
+ * @block_alignment: The block alignment for the memory block to be allocated.
+ *
+ * Request Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_generic_req_msg_v01 {
+	u32 num_bytes;
+	u32 client_id;
+	u32 proc_id;
+	u32 sequence_id;
+	u8 alloc_contiguous_valid;
+	u8 alloc_contiguous;
+	u8 block_alignment_valid;
+	u32 block_alignment;
+};
+
+/**
+ * struct mem_alloc_generic_resp_msg_v01 - Response for memory allocation request.
+ * @resp: Result Code. The result of the requested memory operation.
+ * @sequence_id_valid: Must be set to true if sequence_id is being passed.
+ * @sequence_id: Sequence ID. This property is marked as mandatory.
+ * @dhms_mem_alloc_addr_info_valid: Must be set to true if handle is being passed.
+ * @dhms_mem_alloc_addr_info_len: Handle Size.
+ * @dhms_mem_alloc_addr_info: Memory Block Handle. The physical address of the
+ *                            memory allocated on the HLOS.
+ *
+ * Response Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_generic_resp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+	u8 sequence_id_valid;
+	u32 sequence_id;
+	u8 dhms_mem_alloc_addr_info_valid;
+	u8 dhms_mem_alloc_addr_info_len;
+	struct dhms_mem_alloc_addr_info_type_v01 dhms_mem_alloc_addr_info[MAX_ARR_CNT_V01];
+};
+
+/**
+ * struct mem_free_generic_req_msg_v01 - Memory free request.
+ * @dhms_mem_alloc_addr_info_len: Must be set to # of elments in array.
+ * @dhms_mem_alloc_addr_info: Physical address and size of the memory allocated
+ *                            on the HLOS to be freed.
+ * @client_id_valid: Must be set to true if client_id is being passed.
+ * @client_id: Client ID.
+ * @proc_id_valid: Must be set to true if proc_id is being passed.
+ * @proc_id: Peripheral ID.
+ *
+ * Request Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem
+ */
+struct mem_free_generic_req_msg_v01 {
+	u8 dhms_mem_alloc_addr_info_len;
+	struct dhms_mem_alloc_addr_info_type_v01 dhms_mem_alloc_addr_info[MAX_ARR_CNT_V01];
+	u8 client_id_valid;
+	u32 client_id;
+	u8 proc_id_valid;
+	u32 proc_id;
+};
+
+/**
+ * struct mem_free_generic_resp_msg_v01 - Response for memory free request.
+ * @resp: Result of the requested memory operation.
+ *
+ * Response Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem
+ */
+struct mem_free_generic_resp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+};
+
+/**
+ * struct mem_query_size_req_msg_v01 - Size query request.
+ * @client_id: Client ID.
+ * @proc_id_valid: proc_id_valid must be set to true if proc_id is being passed.
+ * @proc_id: Proc ID.
+ *
+ * Request Message.
+ */
+struct mem_query_size_req_msg_v01 {
+	u32 client_id;
+	u8 proc_id_valid;
+	u32 proc_id;
+};
+
+/**
+ * struct mem_query_size_rsp_msg_v01 - Response for Size query request.
+ * @resp: Result Code.
+ * @size_valid: size_valid must be set to true if size is being passed.
+ * @size: Size.
+ *
+ * Response Message.
+ */
+struct mem_query_size_rsp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+	u8 size_valid;
+	u32 size;
+};
+
+/* Message structure definitions defined in "memshare_qmi_msg.c" */
+extern struct qmi_elem_info mem_alloc_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_generic_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_generic_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_generic_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_generic_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_query_size_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_query_size_resp_msg_data_v01_ei[];
+
+#endif
diff --git a/drivers/soc/qcom/spm.c b/drivers/soc/qcom/spm.c
new file mode 100644
index 00000000000..f831420b7fd
--- /dev/null
+++ b/drivers/soc/qcom/spm.c
@@ -0,0 +1,279 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014,2015, Linaro Ltd.
+ *
+ * SAW power controller driver
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <soc/qcom/spm.h>
+
+#define SPM_CTL_INDEX		0x7f
+#define SPM_CTL_INDEX_SHIFT	4
+#define SPM_CTL_EN		BIT(0)
+
+enum spm_reg {
+	SPM_REG_CFG,
+	SPM_REG_SPM_CTL,
+	SPM_REG_DLY,
+	SPM_REG_PMIC_DLY,
+	SPM_REG_PMIC_DATA_0,
+	SPM_REG_PMIC_DATA_1,
+	SPM_REG_VCTL,
+	SPM_REG_SEQ_ENTRY,
+	SPM_REG_SPM_STS,
+	SPM_REG_PMIC_STS,
+	SPM_REG_AVS_CTL,
+	SPM_REG_AVS_LIMIT,
+	SPM_REG_NR,
+};
+
+static const u16 spm_reg_offset_v4_1[SPM_REG_NR] = {
+	[SPM_REG_AVS_CTL]	= 0x904,
+	[SPM_REG_AVS_LIMIT]	= 0x908,
+};
+
+static const struct spm_reg_data spm_reg_660_gold_l2  = {
+	.reg_offset = spm_reg_offset_v4_1,
+	.avs_ctl = 0x1010031,
+	.avs_limit = 0x4580458,
+};
+
+static const struct spm_reg_data spm_reg_660_silver_l2  = {
+	.reg_offset = spm_reg_offset_v4_1,
+	.avs_ctl = 0x101c031,
+	.avs_limit = 0x4580458,
+};
+
+static const struct spm_reg_data spm_reg_8998_gold_l2  = {
+	.reg_offset = spm_reg_offset_v4_1,
+	.avs_ctl = 0x1010031,
+	.avs_limit = 0x4700470,
+};
+
+static const struct spm_reg_data spm_reg_8998_silver_l2  = {
+	.reg_offset = spm_reg_offset_v4_1,
+	.avs_ctl = 0x1010031,
+	.avs_limit = 0x4200420,
+};
+
+static const u16 spm_reg_offset_v3_0[SPM_REG_NR] = {
+	[SPM_REG_CFG]		= 0x08,
+	[SPM_REG_SPM_CTL]	= 0x30,
+	[SPM_REG_DLY]		= 0x34,
+	[SPM_REG_SEQ_ENTRY]	= 0x400,
+};
+
+/* SPM register data for 8916 */
+static const struct spm_reg_data spm_reg_8916_cpu = {
+	.reg_offset = spm_reg_offset_v3_0,
+	.spm_cfg = 0x1,
+	.spm_dly = 0x3C102800,
+	.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,
+		0x5B, 0x60, 0x03, 0x60, 0x3B, 0x76, 0x76, 0x0B, 0x94, 0x5B,
+		0x80, 0x10, 0x26, 0x30, 0x0F },
+	.start_index[PM_SLEEP_MODE_STBY] = 0,
+	.start_index[PM_SLEEP_MODE_SPC] = 5,
+};
+
+static const u16 spm_reg_offset_v2_1[SPM_REG_NR] = {
+	[SPM_REG_CFG]		= 0x08,
+	[SPM_REG_SPM_CTL]	= 0x30,
+	[SPM_REG_DLY]		= 0x34,
+	[SPM_REG_SEQ_ENTRY]	= 0x80,
+};
+
+/* SPM register data for 8974, 8084 */
+static const struct spm_reg_data spm_reg_8974_8084_cpu  = {
+	.reg_offset = spm_reg_offset_v2_1,
+	.spm_cfg = 0x1,
+	.spm_dly = 0x3C102800,
+	.seq = { 0x03, 0x0B, 0x0F, 0x00, 0x20, 0x80, 0x10, 0xE8, 0x5B, 0x03,
+		0x3B, 0xE8, 0x5B, 0x82, 0x10, 0x0B, 0x30, 0x06, 0x26, 0x30,
+		0x0F },
+	.start_index[PM_SLEEP_MODE_STBY] = 0,
+	.start_index[PM_SLEEP_MODE_SPC] = 3,
+};
+
+/* SPM register data for 8226 */
+static const struct spm_reg_data spm_reg_8226_cpu  = {
+	.reg_offset = spm_reg_offset_v2_1,
+	.spm_cfg = 0x0,
+	.spm_dly = 0x3C102800,
+	.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,
+		0x5B, 0x60, 0x03, 0x60, 0x3B, 0x76, 0x76, 0x0B, 0x94, 0x5B,
+		0x80, 0x10, 0x26, 0x30, 0x0F },
+	.start_index[PM_SLEEP_MODE_STBY] = 0,
+	.start_index[PM_SLEEP_MODE_SPC] = 5,
+};
+
+static const u16 spm_reg_offset_v1_1[SPM_REG_NR] = {
+	[SPM_REG_CFG]		= 0x08,
+	[SPM_REG_SPM_CTL]	= 0x20,
+	[SPM_REG_PMIC_DLY]	= 0x24,
+	[SPM_REG_PMIC_DATA_0]	= 0x28,
+	[SPM_REG_PMIC_DATA_1]	= 0x2C,
+	[SPM_REG_SEQ_ENTRY]	= 0x80,
+};
+
+/* SPM register data for 8064 */
+static const struct spm_reg_data spm_reg_8064_cpu = {
+	.reg_offset = spm_reg_offset_v1_1,
+	.spm_cfg = 0x1F,
+	.pmic_dly = 0x02020004,
+	.pmic_data[0] = 0x0084009C,
+	.pmic_data[1] = 0x00A4001C,
+	.seq = { 0x03, 0x0F, 0x00, 0x24, 0x54, 0x10, 0x09, 0x03, 0x01,
+		0x10, 0x54, 0x30, 0x0C, 0x24, 0x30, 0x0F },
+	.start_index[PM_SLEEP_MODE_STBY] = 0,
+	.start_index[PM_SLEEP_MODE_SPC] = 2,
+};
+
+static inline void spm_register_write(struct spm_driver_data *drv,
+					enum spm_reg reg, u32 val)
+{
+	if (drv->reg_data->reg_offset[reg])
+		writel_relaxed(val, drv->reg_base +
+				drv->reg_data->reg_offset[reg]);
+}
+
+/* Ensure a guaranteed write, before return */
+static inline void spm_register_write_sync(struct spm_driver_data *drv,
+					enum spm_reg reg, u32 val)
+{
+	u32 ret;
+
+	if (!drv->reg_data->reg_offset[reg])
+		return;
+
+	do {
+		writel_relaxed(val, drv->reg_base +
+				drv->reg_data->reg_offset[reg]);
+		ret = readl_relaxed(drv->reg_base +
+				drv->reg_data->reg_offset[reg]);
+		if (ret == val)
+			break;
+		cpu_relax();
+	} while (1);
+}
+
+static inline u32 spm_register_read(struct spm_driver_data *drv,
+				    enum spm_reg reg)
+{
+	return readl_relaxed(drv->reg_base + drv->reg_data->reg_offset[reg]);
+}
+
+void spm_set_low_power_mode(struct spm_driver_data *drv,
+			    enum pm_sleep_mode mode)
+{
+	u32 start_index;
+	u32 ctl_val;
+
+	start_index = drv->reg_data->start_index[mode];
+
+	ctl_val = spm_register_read(drv, SPM_REG_SPM_CTL);
+	ctl_val &= ~(SPM_CTL_INDEX << SPM_CTL_INDEX_SHIFT);
+	ctl_val |= start_index << SPM_CTL_INDEX_SHIFT;
+	ctl_val |= SPM_CTL_EN;
+	spm_register_write_sync(drv, SPM_REG_SPM_CTL, ctl_val);
+}
+
+static const struct of_device_id spm_match_table[] = {
+	{ .compatible = "qcom,sdm660-gold-saw2-v4.1-l2",
+	  .data = &spm_reg_660_gold_l2 },
+	{ .compatible = "qcom,sdm660-silver-saw2-v4.1-l2",
+	  .data = &spm_reg_660_silver_l2 },
+	{ .compatible = "qcom,msm8226-saw2-v2.1-cpu",
+	  .data = &spm_reg_8226_cpu },
+	{ .compatible = "qcom,msm8916-saw2-v3.0-cpu",
+	  .data = &spm_reg_8916_cpu },
+	{ .compatible = "qcom,msm8974-saw2-v2.1-cpu",
+	  .data = &spm_reg_8974_8084_cpu },
+	{ .compatible = "qcom,msm8998-gold-saw2-v4.1-l2",
+	  .data = &spm_reg_8998_gold_l2 },
+	{ .compatible = "qcom,msm8998-silver-saw2-v4.1-l2",
+	  .data = &spm_reg_8998_silver_l2 },
+	{ .compatible = "qcom,apq8084-saw2-v2.1-cpu",
+	  .data = &spm_reg_8974_8084_cpu },
+	{ .compatible = "qcom,apq8064-saw2-v1.1-cpu",
+	  .data = &spm_reg_8064_cpu },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, spm_match_table);
+
+static int spm_dev_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match_id;
+	struct spm_driver_data *drv;
+	struct resource *res;
+	void __iomem *addr;
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	drv->reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(drv->reg_base))
+		return PTR_ERR(drv->reg_base);
+
+	match_id = of_match_node(spm_match_table, pdev->dev.of_node);
+	if (!match_id)
+		return -ENODEV;
+
+	drv->reg_data = match_id->data;
+	platform_set_drvdata(pdev, drv);
+
+	/* Write the SPM sequences first.. */
+	addr = drv->reg_base + drv->reg_data->reg_offset[SPM_REG_SEQ_ENTRY];
+	__iowrite32_copy(addr, drv->reg_data->seq,
+			ARRAY_SIZE(drv->reg_data->seq) / 4);
+
+	/*
+	 * ..and then the control registers.
+	 * On some SoC if the control registers are written first and if the
+	 * CPU was held in reset, the reset signal could trigger the SPM state
+	 * machine, before the sequences are completely written.
+	 */
+	spm_register_write(drv, SPM_REG_AVS_CTL, drv->reg_data->avs_ctl);
+	spm_register_write(drv, SPM_REG_AVS_LIMIT, drv->reg_data->avs_limit);
+	spm_register_write(drv, SPM_REG_CFG, drv->reg_data->spm_cfg);
+	spm_register_write(drv, SPM_REG_DLY, drv->reg_data->spm_dly);
+	spm_register_write(drv, SPM_REG_PMIC_DLY, drv->reg_data->pmic_dly);
+	spm_register_write(drv, SPM_REG_PMIC_DATA_0,
+				drv->reg_data->pmic_data[0]);
+	spm_register_write(drv, SPM_REG_PMIC_DATA_1,
+				drv->reg_data->pmic_data[1]);
+
+	/* Set up Standby as the default low power mode */
+	if (drv->reg_data->reg_offset[SPM_REG_SPM_CTL])
+		spm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);
+
+	return 0;
+}
+
+static struct platform_driver spm_driver = {
+	.probe = spm_dev_probe,
+	.driver = {
+		.name = "qcom_spm",
+		.of_match_table = spm_match_table,
+	},
+};
+
+static int __init qcom_spm_init(void)
+{
+	return platform_driver_register(&spm_driver);
+}
+arch_initcall(qcom_spm_init);
+
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/soc/qcom,memshare.h b/include/dt-bindings/soc/qcom,memshare.h
new file mode 100644
index 00000000000..4cef1ef75d0
--- /dev/null
+++ b/include/dt-bindings/soc/qcom,memshare.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __DT_QCOM_MEMSHARE_H__
+#define __DT_QCOM_MEMSHARE_H__
+
+#define MEMSHARE_PROC_MPSS_V01 0
+#define MEMSHARE_PROC_ADSP_V01 1
+#define MEMSHARE_PROC_WCNSS_V01 2
+
+#endif /* __DT_QCOM_MEMSHARE_H__ */
diff --git a/include/dt-bindings/sound/qcom,q6voice.h b/include/dt-bindings/sound/qcom,q6voice.h
new file mode 100644
index 00000000000..fe5aa3a3fce
--- /dev/null
+++ b/include/dt-bindings/sound/qcom,q6voice.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __DT_BINDINGS_Q6_VOICE_H__
+#define __DT_BINDINGS_Q6_VOICE_H__
+
+#define	CS_VOICE        0
+
+#endif /* __DT_BINDINGS_Q6_VOICE_H__ */
diff --git a/include/soc/qcom/spm.h b/include/soc/qcom/spm.h
new file mode 100644
index 00000000000..4951f9d8b0b
--- /dev/null
+++ b/include/soc/qcom/spm.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014,2015, Linaro Ltd.
+ */
+
+#ifndef __SPM_H__
+#define __SPM_H__
+
+#include <linux/cpuidle.h>
+
+#define MAX_PMIC_DATA		2
+#define MAX_SEQ_DATA		64
+
+enum pm_sleep_mode {
+	PM_SLEEP_MODE_STBY,
+	PM_SLEEP_MODE_RET,
+	PM_SLEEP_MODE_SPC,
+	PM_SLEEP_MODE_PC,
+	PM_SLEEP_MODE_NR,
+};
+
+struct spm_reg_data {
+	const u16 *reg_offset;
+	u32 spm_cfg;
+	u32 spm_dly;
+	u32 pmic_dly;
+	u32 pmic_data[MAX_PMIC_DATA];
+	u32 avs_ctl;
+	u32 avs_limit;
+	u8 seq[MAX_SEQ_DATA];
+	u8 start_index[PM_SLEEP_MODE_NR];
+};
+
+struct spm_driver_data {
+	void __iomem *reg_base;
+	const struct spm_reg_data *reg_data;
+};
+
+void spm_set_low_power_mode(struct spm_driver_data *drv,
+			    enum pm_sleep_mode mode);
+
+#endif /* __SPM_H__ */
diff --git a/kernel/configs/pmos.config b/kernel/configs/pmos.config
new file mode 100644
index 00000000000..c2332840adc
--- /dev/null
+++ b/kernel/configs/pmos.config
@@ -0,0 +1,160 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+
+CONFIG_BLK_DEV_DM=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CGROUPS=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_DEVTMPFS=y
+CONFIG_DM_CRYPT=m
+CONFIG_EXT4_FS=y
+CONFIG_MD=y
+CONFIG_SYSVIPC=y
+CONFIG_UEVENT_HELPER=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USER_NS=y
+CONFIG_VT=y
+
+# Anbox / Waydroid
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+# CONFIG_ANDROID_BINDERFS is not set
+CONFIG_STAGING=y
+CONFIG_ASHMEM=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_PSI=y
+
+# /usr/share/docker/contrib/check-config.sh (from Gentoo)
+# Missing dependency?
+CONFIG_NET_SCHED=y
+
+# Generally Necessary:
+CONFIG_NAMESPACES=y
+CONFIG_NET_NS=y
+CONFIG_PID_NS=y
+CONFIG_IPC_NS=y
+CONFIG_UTS_NS=y
+#ONFIG_CGROUPS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CPUSETS=y
+CONFIG_KEYS=y
+CONFIG_VETH=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_NETFILTER=m
+#ONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MARK=m
+#ONFIG_IP_NF_NAT=m
+CONFIG_NF_NAT=m
+CONFIG_POSIX_MQUEUE=y
+
+# Optional Features:
+#ONFIG_USER_NS=y
+CONFIG_SECCOMP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_BLK_CGROUP=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_CGROUP_PERF=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=m
+#ONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_VXLAN=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_IPVLAN=m
+CONFIG_MACVLAN=m
+CONFIG_DUMMY=m
+#ONFIG_BLK_DEV_DM=m
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_OVERLAY_FS=m
+
+# lxc
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+
+# elogind
+CONFIG_TMPFS_POSIX_ACL=y
+
+# fbkeyboard
+CONFIG_INPUT_UINPUT=m
+
+# nftables
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_CT=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_REJECT=m
+
+# Wireguard
+CONFIG_WIREGUARD=m
+
+# zram support
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=m
+CONFIG_CRYPTO_LZ4=y
+
+# LED triggers
+CONFIG_LEDS_TRIGGER_ONESHOT=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_LEDS_TRIGGER_ACTIVITY=m
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_TRANSIENT=m
+CONFIG_LEDS_TRIGGER_CAMERA=m
+CONFIG_LEDS_TRIGGER_NETDEV=m
+CONFIG_LEDS_TRIGGER_PATTERN=m
+CONFIG_LEDS_TRIGGER_AUDIO=m
+CONFIG_LEDS_TRIGGER_TTY=m
+
+# F2FS support
+CONFIG_F2FS_FS=m
+CONFIG_F2FS_FS_COMPRESSION=y
+
+# AppArmor support
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_DEFAULT_SECURITY_APPARMOR=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,apparmor,selinux,smack,tomoyo,bpf"
+
+# iwd support
+CONFIG_KEY_DH_OPERATIONS=y
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_DES=m
+CONFIG_PKCS8_PRIVATE_KEY_PARSER=m
+
+# External devices
+CONFIG_UHID=m
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index d59a7e99ce4..651d87b7068 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -52,6 +52,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_AK5558
 	imply SND_SOC_ALC5623
 	imply SND_SOC_ALC5632
+	imply SND_SOC_AW8738
 	imply SND_SOC_BT_SCO
 	imply SND_SOC_BD28623
 	imply SND_SOC_CQ0093VC
@@ -555,6 +556,10 @@ config SND_SOC_ALC5632
 	tristate
 	depends on I2C
 
+config SND_SOC_AW8738
+	tristate "Awinic AW8738 CODEC"
+	depends on GPIOLIB
+
 config SND_SOC_BD28623
 	tristate "ROHM BD28623 CODEC"
 	help
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 8dcea2c4604..15a963cd881 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -44,6 +44,7 @@ snd-soc-ak4671-objs := ak4671.o
 snd-soc-ak5386-objs := ak5386.o
 snd-soc-ak5558-objs := ak5558.o
 snd-soc-arizona-objs := arizona.o arizona-jack.o
+snd-soc-aw8738-objs := aw8738.o
 snd-soc-bd28623-objs := bd28623.o
 snd-soc-bt-sco-objs := bt-sco.o
 snd-soc-cpcap-objs := cpcap.o
@@ -375,6 +376,7 @@ obj-$(CONFIG_SND_SOC_AK5558)	+= snd-soc-ak5558.o
 obj-$(CONFIG_SND_SOC_ALC5623)    += snd-soc-alc5623.o
 obj-$(CONFIG_SND_SOC_ALC5632)	+= snd-soc-alc5632.o
 obj-$(CONFIG_SND_SOC_ARIZONA)	+= snd-soc-arizona.o
+obj-$(CONFIG_SND_SOC_AW8738)	+= snd-soc-aw8738.o
 obj-$(CONFIG_SND_SOC_BD28623)	+= snd-soc-bd28623.o
 obj-$(CONFIG_SND_SOC_BT_SCO)	+= snd-soc-bt-sco.o
 obj-$(CONFIG_SND_SOC_CQ0093VC) += snd-soc-cq93vc.o
diff --git a/sound/soc/codecs/aw8738.c b/sound/soc/codecs/aw8738.c
new file mode 100644
index 00000000000..a1861b50217
--- /dev/null
+++ b/sound/soc/codecs/aw8738.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+#include <sound/soc.h>
+
+struct aw8738_priv {
+	struct gpio_desc *enable_gpio;
+	unsigned int mode;
+};
+
+static int aw8738_drv_event(struct snd_soc_dapm_widget *w,
+			    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+	struct aw8738_priv *aw8738 = snd_soc_component_get_drvdata(comp);
+	int i;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		for (i = 0; i < aw8738->mode; i++) {
+			gpiod_set_value_cansleep(aw8738->enable_gpio, 0);
+			udelay(2);
+			gpiod_set_value_cansleep(aw8738->enable_gpio, 1);
+			udelay(2);
+		}
+
+		msleep(40);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		gpiod_set_value_cansleep(aw8738->enable_gpio, 0);
+		usleep_range(1000, 2000);
+		break;
+	default:
+		WARN(1, "Unexpected event");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget aw8738_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("IN"),
+	SND_SOC_DAPM_OUT_DRV_E("DRV", SND_SOC_NOPM, 0, 0, NULL, 0,
+			       aw8738_drv_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_OUTPUT("OUT"),
+};
+
+static const struct snd_soc_dapm_route aw8738_dapm_routes[] = {
+	{ "DRV", NULL, "IN" },
+	{ "OUT", NULL, "DRV" },
+};
+
+static const struct snd_soc_component_driver aw8738_component_driver = {
+	.dapm_widgets = aw8738_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(aw8738_dapm_widgets),
+	.dapm_routes = aw8738_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(aw8738_dapm_routes),
+};
+
+static int aw8738_probe(struct platform_device *pdev)
+{
+	struct aw8738_priv *aw8738;
+	int ret;
+
+	aw8738 = devm_kzalloc(&pdev->dev, sizeof(*aw8738), GFP_KERNEL);
+	if (!aw8738)
+		return -ENOMEM;
+
+	aw8738->enable_gpio = devm_gpiod_get(&pdev->dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(aw8738->enable_gpio))
+		return PTR_ERR(aw8738->enable_gpio);
+
+	ret = device_property_read_u32(&pdev->dev, "aw8738,mode", &aw8738->mode);
+	if (ret)
+		return -EINVAL;
+
+	dev_set_drvdata(&pdev->dev, aw8738);
+
+	return devm_snd_soc_register_component(&pdev->dev,
+					       &aw8738_component_driver,
+					       NULL, 0);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aw8738_device_id[] = {
+	{ .compatible = "awinic,aw8738" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, aw8738_device_id);
+#endif
+
+static struct platform_driver aw8738_driver = {
+	.driver = {
+		.name = "aw8738",
+		.of_match_table = of_match_ptr(aw8738_device_id),
+	},
+	.probe	= aw8738_probe,
+};
+module_platform_driver(aw8738_driver);
+
+MODULE_DESCRIPTION("Awinic AW8738 Amplifier Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/msm8916-wcd-analog.c b/sound/soc/codecs/msm8916-wcd-analog.c
index 971b8360b5b..a38862710d7 100644
--- a/sound/soc/codecs/msm8916-wcd-analog.c
+++ b/sound/soc/codecs/msm8916-wcd-analog.c
@@ -11,6 +11,7 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
 #include <sound/soc.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -298,6 +299,7 @@ struct pm8916_wcd_analog_priv {
 	struct snd_soc_component *component;
 	struct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];
 	struct snd_soc_jack *jack;
+	struct snd_soc_jack_gpio jack_gpio;
 	bool hphl_jack_type_normally_open;
 	bool gnd_jack_type_normally_open;
 	/* Voltage threshold when internal current source of 100uA is used */
@@ -319,6 +321,10 @@ static const struct soc_enum hph_enum = SOC_ENUM_SINGLE_VIRT(
 static const struct snd_kcontrol_new ear_mux = SOC_DAPM_ENUM("EAR_S", hph_enum);
 static const struct snd_kcontrol_new hphl_mux = SOC_DAPM_ENUM("HPHL", hph_enum);
 static const struct snd_kcontrol_new hphr_mux = SOC_DAPM_ENUM("HPHR", hph_enum);
+static const struct snd_kcontrol_new hphl_ext_mux = SOC_DAPM_ENUM("HPHL EXT",
+								  hph_enum);
+static const struct snd_kcontrol_new hphr_ext_mux = SOC_DAPM_ENUM("HPHR EXT",
+								  hph_enum);
 
 /* ADC2 MUX */
 static const struct soc_enum adc2_enum = SOC_ENUM_SINGLE_VIRT(
@@ -480,7 +486,7 @@ static void pm8916_wcd_setup_mbhc(struct pm8916_wcd_analog_priv *wcd)
 	struct snd_soc_component *component = wcd->component;
 	bool micbias_enabled = false;
 	u32 plug_type = 0;
-	u32 int_en_mask;
+	u32 int_en_mask = 0;
 
 	snd_soc_component_write(component, CDC_A_MBHC_DET_CTL_1,
 		      CDC_A_MBHC_DET_CTL_L_DET_EN |
@@ -515,7 +521,8 @@ static void pm8916_wcd_setup_mbhc(struct pm8916_wcd_analog_priv *wcd)
 
 	pm8916_mbhc_configure_bias(wcd, micbias_enabled);
 
-	int_en_mask = MBHC_SWITCH_INT;
+	if (!wcd->jack_gpio.report)
+		int_en_mask |= MBHC_SWITCH_INT;
 	if (wcd->mbhc_btn_enabled)
 		int_en_mask |= MBHC_BUTTON_PRESS_DET | MBHC_BUTTON_RELEASE_DET;
 
@@ -822,22 +829,27 @@ static const struct snd_soc_dapm_route pm8916_wcd_analog_audio_map[] = {
 	{"EAR PA", NULL, "EAR CP"},
 
 	/* Headset (RX MIX1 and RX MIX2) */
-	{"HEADPHONE", NULL, "HPHL PA"},
-	{"HEADPHONE", NULL, "HPHR PA"},
+	{"HPH_L", NULL, "HPHL"},
+	{"HPH_R", NULL, "HPHR"},
+	{"HPHL", "Switch", "HPHL PA"},
+	{"HPHR", "Switch", "HPHR PA"},
+
+	{"HPH_L_EXT", NULL, "HPHL EXT"},
+	{"HPHL EXT", "Switch", "HPHL PA"},
+	{"HPH_R_EXT", NULL, "HPHR EXT"},
+	{"HPHR EXT", "Switch", "HPHR PA"},
 
 	{"HPHL DAC", NULL, "EAR_HPHL_CLK"},
 	{"HPHR DAC", NULL, "EAR_HPHR_CLK"},
 
 	{"CP", NULL, "NCP_CLK"},
 
-	{"HPHL PA", NULL, "HPHL"},
-	{"HPHR PA", NULL, "HPHR"},
+	{"HPHL PA", NULL, "HPHL DAC"},
+	{"HPHR PA", NULL, "HPHR DAC"},
 	{"HPHL PA", NULL, "CP"},
 	{"HPHL PA", NULL, "RX_BIAS"},
 	{"HPHR PA", NULL, "CP"},
 	{"HPHR PA", NULL, "RX_BIAS"},
-	{"HPHL", "Switch", "HPHL DAC"},
-	{"HPHR", "Switch", "HPHR DAC"},
 
 	{"RX_BIAS", NULL, "DAC_REF"},
 
@@ -870,7 +882,14 @@ static const struct snd_soc_dapm_widget pm8916_wcd_analog_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("AMIC3"),
 	SND_SOC_DAPM_INPUT("AMIC2"),
 	SND_SOC_DAPM_OUTPUT("EAR"),
-	SND_SOC_DAPM_OUTPUT("HEADPHONE"),
+	SND_SOC_DAPM_OUTPUT("HPH_L"),
+	SND_SOC_DAPM_OUTPUT("HPH_R"),
+
+	/* There may be an external speaker amplifier connected to HPHL/HPHR */
+	SND_SOC_DAPM_OUTPUT("HPH_L_EXT"),
+	SND_SOC_DAPM_OUTPUT("HPH_R_EXT"),
+	SND_SOC_DAPM_MUX("HPHL EXT", SND_SOC_NOPM, 0, 0, &hphl_ext_mux),
+	SND_SOC_DAPM_MUX("HPHR EXT", SND_SOC_NOPM, 0, 0, &hphr_ext_mux),
 
 	/* RX stuff */
 	SND_SOC_DAPM_SUPPLY("INT_LDO_H", SND_SOC_NOPM, 1, 0, NULL, 0),
@@ -979,6 +998,22 @@ static int pm8916_wcd_analog_set_jack(struct snd_soc_component *component,
 {
 	struct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);
 
+	if (wcd->jack_gpio.report && wcd->jack != jack) {
+		int ret;
+
+		if (wcd->jack)
+			snd_soc_jack_free_gpios(wcd->jack, 1, &wcd->jack_gpio);
+
+		if (jack) {
+			ret = snd_soc_jack_add_gpiods(component->dev, jack,
+						      1, &wcd->jack_gpio);
+			if (ret)
+				dev_err(component->dev,
+					"Failed to add GPIO to jack: %d\n",
+					ret);
+		}
+	}
+
 	wcd->jack = jack;
 
 	return 0;
@@ -1040,15 +1075,10 @@ static irqreturn_t mbhc_btn_press_irq_handler(int irq, void *arg)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
+static int pm8916_wcd_analog_switch_check(struct pm8916_wcd_analog_priv *priv, bool ins)
 {
-	struct pm8916_wcd_analog_priv *priv = arg;
 	struct snd_soc_component *component = priv->component;
-	bool ins = false;
-
-	if (snd_soc_component_read(component, CDC_A_MBHC_DET_CTL_1) &
-				CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK)
-		ins = true;
+	int report;
 
 	/* Set the detection type appropriately */
 	snd_soc_component_update_bits(component, CDC_A_MBHC_DET_CTL_1,
@@ -1072,23 +1102,46 @@ static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
 		 * a headset.
 		 */
 		if (priv->mbhc_btn0_released)
-			snd_soc_jack_report(priv->jack,
-					    SND_JACK_HEADSET, hs_jack_mask);
+			report = SND_JACK_HEADSET;
 		else
-			snd_soc_jack_report(priv->jack,
-					    SND_JACK_HEADPHONE, hs_jack_mask);
+			report = SND_JACK_HEADPHONE;
 
 		priv->detect_accessory_type = false;
 
 	} else { /* removal */
-		snd_soc_jack_report(priv->jack, 0, hs_jack_mask);
+		report = 0;
 		priv->detect_accessory_type = true;
 		priv->mbhc_btn0_released = false;
 	}
 
+	return report;
+}
+
+static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
+{
+	struct pm8916_wcd_analog_priv *priv = arg;
+	struct snd_soc_component *component = priv->component;
+	bool ins = false;
+	int report;
+
+	if (snd_soc_component_read(component, CDC_A_MBHC_DET_CTL_1) &
+				CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK)
+		ins = true;
+
+	report = pm8916_wcd_analog_switch_check(priv, ins);
+	snd_soc_jack_report(priv->jack, report, hs_jack_mask);
+
 	return IRQ_HANDLED;
 }
 
+static int pm8916_wcd_analog_jack_status_check(void *data)
+{
+	struct pm8916_wcd_analog_priv *wcd = data;
+	bool ins = gpiod_get_value_cansleep(wcd->jack_gpio.desc);
+
+	return pm8916_wcd_analog_switch_check(wcd, ins);
+}
+
 static struct snd_soc_dai_driver pm8916_wcd_analog_dai[] = {
 	[0] = {
 	       .name = "pm8916_wcd_analog_pdm_rx",
@@ -1220,19 +1273,26 @@ static int pm8916_wcd_analog_spmi_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	irq = platform_get_irq_byname(pdev, "mbhc_switch_int");
-	if (irq < 0) {
-		ret = irq;
-		goto err_disable_clk;
-	}
+	if (gpiod_count(dev, "jack") > 0) {
+		priv->jack_gpio.name = "jack";
+		priv->jack_gpio.report = hs_jack_mask;
+		priv->jack_gpio.debounce_time = 100;
+		priv->jack_gpio.jack_status_check =
+			pm8916_wcd_analog_jack_status_check;
+		priv->jack_gpio.data = priv;
+	} else {
+		irq = platform_get_irq_byname(pdev, "mbhc_switch_int");
+		if (irq < 0)
+			return irq;
 
-	ret = devm_request_threaded_irq(dev, irq, NULL,
-			       pm8916_mbhc_switch_irq_handler,
-			       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-			       IRQF_ONESHOT,
-			       "mbhc switch irq", priv);
-	if (ret)
-		dev_err(dev, "cannot request mbhc switch irq\n");
+		ret = devm_request_threaded_irq(dev, irq, NULL,
+				       pm8916_mbhc_switch_irq_handler,
+				       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+				       IRQF_ONESHOT,
+				       "mbhc switch irq", priv);
+		if (ret)
+			dev_err(dev, "cannot request mbhc switch irq\n");
+	}
 
 	if (priv->mbhc_btn_enabled) {
 		irq = platform_get_irq_byname(pdev, "mbhc_but_press_det");
diff --git a/sound/soc/codecs/tfa989x.c b/sound/soc/codecs/tfa989x.c
index 643b45188b6..c96e941da1a 100644
--- a/sound/soc/codecs/tfa989x.c
+++ b/sound/soc/codecs/tfa989x.c
@@ -7,6 +7,7 @@
  * Copyright (C) 2013 Sony Mobile Communications Inc.
  */
 
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/regmap.h>
@@ -19,6 +20,7 @@
 #define TFA989X_REVISIONNUMBER		0x03
 #define TFA989X_REVISIONNUMBER_REV_MSK	GENMASK(7, 0)	/* device revision */
 #define TFA989X_I2SREG			0x04
+#define TFA989X_I2SREG_RCV		2	/* receiver mode */
 #define TFA989X_I2SREG_CHSA		6	/* amplifier input select */
 #define TFA989X_I2SREG_CHSA_MSK		GENMASK(7, 6)
 #define TFA989X_I2SREG_I2SSR		12	/* sample rate */
@@ -53,7 +55,9 @@ struct tfa989x_rev {
 };
 
 struct tfa989x {
+	const struct tfa989x_rev *rev;
 	struct regulator *vddd_supply;
+	struct gpio_desc *rcv_gpiod;
 };
 
 static bool tfa989x_writeable_reg(struct device *dev, unsigned int reg)
@@ -77,13 +81,16 @@ static const struct regmap_config tfa989x_regmap = {
 
 static const char * const chsa_text[] = { "Left", "Right", /* "DSP" */ };
 static SOC_ENUM_SINGLE_DECL(chsa_enum, TFA989X_I2SREG, TFA989X_I2SREG_CHSA, chsa_text);
-static const struct snd_kcontrol_new chsa_mux = SOC_DAPM_ENUM("Amp Input", chsa_enum);
+static const struct snd_kcontrol_new
+	chsa_mux = SOC_DAPM_ENUM("Amp Input", chsa_enum),
+	amp_switch = SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 1);
 
 static const struct snd_soc_dapm_widget tfa989x_dapm_widgets[] = {
 	SND_SOC_DAPM_OUTPUT("OUT"),
 	SND_SOC_DAPM_SUPPLY("POWER", TFA989X_SYS_CTRL, TFA989X_SYS_CTRL_PWDN, 1, NULL, 0),
 	SND_SOC_DAPM_OUT_DRV("AMPE", TFA989X_SYS_CTRL, TFA989X_SYS_CTRL_AMPE, 0, NULL, 0),
 
+	SND_SOC_DAPM_SWITCH("Amp", SND_SOC_NOPM, 0, 0, &amp_switch),
 	SND_SOC_DAPM_MUX("Amp Input", SND_SOC_NOPM, 0, 0, &chsa_mux),
 	SND_SOC_DAPM_AIF_IN("AIFINL", "HiFi Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("AIFINR", "HiFi Playback", 1, SND_SOC_NOPM, 0, 0),
@@ -92,12 +99,41 @@ static const struct snd_soc_dapm_widget tfa989x_dapm_widgets[] = {
 static const struct snd_soc_dapm_route tfa989x_dapm_routes[] = {
 	{"OUT", NULL, "AMPE"},
 	{"AMPE", NULL, "POWER"},
-	{"AMPE", NULL, "Amp Input"},
+	{"AMPE", NULL, "Amp"},
+	{"Amp", "Switch", "Amp Input"},
 	{"Amp Input", "Left", "AIFINL"},
 	{"Amp Input", "Right", "AIFINR"},
 };
 
+static int tfa989x_put_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct tfa989x *tfa989x = snd_soc_component_get_drvdata(component);
+
+	gpiod_set_value_cansleep(tfa989x->rcv_gpiod, ucontrol->value.enumerated.item[0]);
+
+	return snd_soc_put_enum_double(kcontrol, ucontrol);
+}
+
+static const char * const mode_text[] = { "Speaker", "Receiver" };
+static SOC_ENUM_SINGLE_DECL(mode_enum, TFA989X_I2SREG, TFA989X_I2SREG_RCV, mode_text);
+static const struct snd_kcontrol_new tfa989x_mode_controls[] = {
+	SOC_ENUM_EXT("Mode", mode_enum, snd_soc_get_enum_double, tfa989x_put_mode),
+};
+
+static int tfa989x_probe(struct snd_soc_component *component)
+{
+	struct tfa989x *tfa989x = snd_soc_component_get_drvdata(component);
+
+	if (tfa989x->rev->rev == TFA9897_REVISION)
+		return snd_soc_add_component_controls(component, tfa989x_mode_controls,
+						      ARRAY_SIZE(tfa989x_mode_controls));
+
+	return 0;
+}
+
 static const struct snd_soc_component_driver tfa989x_component = {
+	.probe			= tfa989x_probe,
 	.dapm_widgets		= tfa989x_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(tfa989x_dapm_widgets),
 	.dapm_routes		= tfa989x_dapm_routes,
@@ -273,6 +309,7 @@ static int tfa989x_i2c_probe(struct i2c_client *i2c)
 	if (!tfa989x)
 		return -ENOMEM;
 
+	tfa989x->rev = rev;
 	i2c_set_clientdata(i2c, tfa989x);
 
 	tfa989x->vddd_supply = devm_regulator_get(dev, "vddd");
@@ -280,6 +317,12 @@ static int tfa989x_i2c_probe(struct i2c_client *i2c)
 		return dev_err_probe(dev, PTR_ERR(tfa989x->vddd_supply),
 				     "Failed to get vddd regulator\n");
 
+	if (tfa989x->rev->rev == TFA9897_REVISION) {
+		tfa989x->rcv_gpiod = devm_gpiod_get_optional(dev, "rcv", GPIOD_OUT_LOW);
+		if (IS_ERR(tfa989x->rcv_gpiod))
+			return PTR_ERR(tfa989x->rcv_gpiod);
+	}
+
 	regmap = devm_regmap_init_i2c(i2c, &tfa989x_regmap);
 	if (IS_ERR(regmap))
 		return PTR_ERR(regmap);
diff --git a/sound/soc/qcom/Kconfig b/sound/soc/qcom/Kconfig
index cc7c1de2f1d..93fe7b4f325 100644
--- a/sound/soc/qcom/Kconfig
+++ b/sound/soc/qcom/Kconfig
@@ -103,6 +103,24 @@ config SND_SOC_QDSP6
 	 audio drivers. This includes q6asm, q6adm,
 	 q6afe interfaces to DSP using apr.
 
+config SND_SOC_QDSP6_Q6VOICE_DAI
+	tristate
+
+config SND_SOC_QDSP6_Q6VOICE
+	tristate "QDSP6 Q6Voice audio driver"
+	depends on SND_SOC_QDSP6
+	select SND_SOC_QDSP6_Q6VOICE_DAI
+
+config SND_SOC_MSM8916_QDSP6
+	tristate "SoC Machine driver for MSM8916 via QDSP6"
+	depends on QCOM_APR
+	select SND_SOC_QDSP6
+	select SND_SOC_QCOM_COMMON
+	help
+	  Support for Qualcomm Technologies LPASS audio block via QDSP6
+	  in MSM8916 SoC-based systems.
+	  Say Y if you want to use audio devices via QDSP6.
+
 config SND_SOC_MSM8996
 	tristate "SoC Machine driver for MSM8996 and APQ8096 boards"
 	depends on QCOM_APR
diff --git a/sound/soc/qcom/Makefile b/sound/soc/qcom/Makefile
index 1600ae55bd3..b321064cc27 100644
--- a/sound/soc/qcom/Makefile
+++ b/sound/soc/qcom/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_SND_SOC_LPASS_SC7180) += snd-soc-lpass-sc7180.o
 # Machine
 snd-soc-storm-objs := storm.o
 snd-soc-apq8016-sbc-objs := apq8016_sbc.o
+snd-soc-msm8916-qdsp6-objs := msm8916-qdsp6.o
 snd-soc-apq8096-objs := apq8096.o
 snd-soc-sc7180-objs := sc7180.o
 snd-soc-sdm845-objs := sdm845.o
@@ -25,6 +26,7 @@ snd-soc-qcom-common-objs := common.o
 
 obj-$(CONFIG_SND_SOC_STORM) += snd-soc-storm.o
 obj-$(CONFIG_SND_SOC_APQ8016_SBC) += snd-soc-apq8016-sbc.o
+obj-$(CONFIG_SND_SOC_MSM8916_QDSP6) += snd-soc-msm8916-qdsp6.o
 obj-$(CONFIG_SND_SOC_MSM8996) += snd-soc-apq8096.o
 obj-$(CONFIG_SND_SOC_SC7180) += snd-soc-sc7180.o
 obj-$(CONFIG_SND_SOC_SDM845) += snd-soc-sdm845.o
diff --git a/sound/soc/qcom/apq8016_sbc.c b/sound/soc/qcom/apq8016_sbc.c
index ba2a98268ee..0b1944e4673 100644
--- a/sound/soc/qcom/apq8016_sbc.c
+++ b/sound/soc/qcom/apq8016_sbc.c
@@ -105,6 +105,9 @@ static int apq8016_sbc_dai_init(struct snd_soc_pcm_runtime *rtd)
 		snd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);
 		snd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEUP);
 		snd_jack_set_key(jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);
+
+		snd_jack_add_new_kctl(jack, "Headphone", SND_JACK_HEADPHONE);
+		snd_jack_add_new_kctl(jack, "Headset Mic", SND_JACK_MICROPHONE);
 		pdata->jack_setup = true;
 	}
 
diff --git a/sound/soc/qcom/common.c b/sound/soc/qcom/common.c
index 09af0070070..2e1c618f752 100644
--- a/sound/soc/qcom/common.c
+++ b/sound/soc/qcom/common.c
@@ -44,7 +44,7 @@ int qcom_snd_parse_of(struct snd_soc_card *card)
 		return ret;
 
 	/* Populate links */
-	num_links = of_get_child_count(dev->of_node);
+	num_links = of_get_available_child_count(dev->of_node);
 
 	/* Allocate the DAI link array */
 	card->dai_link = devm_kcalloc(dev, num_links, sizeof(*link), GFP_KERNEL);
@@ -54,7 +54,7 @@ int qcom_snd_parse_of(struct snd_soc_card *card)
 	card->num_links = num_links;
 	link = card->dai_link;
 
-	for_each_child_of_node(dev->of_node, np) {
+	for_each_available_child_of_node(dev->of_node, np) {
 		dlc = devm_kzalloc(dev, 2 * sizeof(*dlc), GFP_KERNEL);
 		if (!dlc) {
 			ret = -ENOMEM;
diff --git a/sound/soc/qcom/msm8916-qdsp6.c b/sound/soc/qcom/msm8916-qdsp6.c
new file mode 100644
index 00000000000..b02ad99af7b
--- /dev/null
+++ b/sound/soc/qcom/msm8916-qdsp6.c
@@ -0,0 +1,278 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <sound/soc.h>
+#include <uapi/linux/input-event-codes.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+
+#include "common.h"
+#include "qdsp6/q6afe.h"
+
+enum {
+	MI2S_PRIMARY,
+	MI2S_SECONDARY,
+	MI2S_TERTIARY,
+	MI2S_QUATERNARY,
+	MI2S_COUNT
+};
+
+struct msm8916_qdsp6_data {
+	void __iomem *mic_iomux;
+	void __iomem *spkr_iomux;
+	struct snd_soc_jack jack;
+	bool jack_setup;
+	unsigned int mi2s_clk_count[MI2S_COUNT];
+};
+
+#define MIC_CTRL_TER_WS_SLAVE_SEL	BIT(21)
+#define MIC_CTRL_QUA_WS_SLAVE_SEL_10	BIT(17)
+#define MIC_CTRL_TLMM_SCLK_EN		BIT(1)
+#define SPKR_CTL_PRI_WS_SLAVE_SEL_11	(BIT(17) | BIT(16))
+#define DEFAULT_MCLK_RATE		9600000
+#define MI2S_BCLK_RATE			1536000
+
+static int msm8916_qdsp6_get_mi2s_id(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+	int id = asoc_rtd_to_cpu(rtd, 0)->id;
+
+	if (id < PRIMARY_MI2S_RX || id > QUATERNARY_MI2S_TX) {
+		dev_err(card->dev, "Unsupported CPU DAI: %d\n", id);
+		return -EINVAL;
+	}
+
+	return (id - PRIMARY_MI2S_RX) / 2;
+}
+
+static int msm8916_qdsp6_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai;
+	struct snd_soc_component *component;
+	struct snd_soc_card *card = rtd->card;
+	struct msm8916_qdsp6_data *pdata = snd_soc_card_get_drvdata(card);
+	int i, rval, mi2s;
+
+	mi2s = msm8916_qdsp6_get_mi2s_id(rtd);
+	if (mi2s < 0)
+		return mi2s;
+
+	switch (mi2s) {
+	case MI2S_PRIMARY:
+		writel(readl(pdata->spkr_iomux) | SPKR_CTL_PRI_WS_SLAVE_SEL_11,
+			pdata->spkr_iomux);
+		break;
+	case MI2S_QUATERNARY:
+		/* Configure the Quat MI2S to TLMM */
+		writel(readl(pdata->mic_iomux) | MIC_CTRL_QUA_WS_SLAVE_SEL_10 |
+			MIC_CTRL_TLMM_SCLK_EN,
+			pdata->mic_iomux);
+		break;
+	case MI2S_TERTIARY:
+		writel(readl(pdata->mic_iomux) | MIC_CTRL_TER_WS_SLAVE_SEL |
+			MIC_CTRL_TLMM_SCLK_EN,
+			pdata->mic_iomux);
+
+		break;
+	default:
+		dev_err(card->dev, "unsupported cpu dai configuration\n");
+		return -ENOTSUPP;
+
+	}
+
+	if (!pdata->jack_setup) {
+		struct snd_jack *jack;
+
+		rval = snd_soc_card_jack_new(card, "Headset Jack",
+					     SND_JACK_HEADSET |
+					     SND_JACK_HEADPHONE |
+					     SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+					     SND_JACK_BTN_2 | SND_JACK_BTN_3 |
+					     SND_JACK_BTN_4,
+					     &pdata->jack, NULL, 0);
+
+		if (rval < 0) {
+			dev_err(card->dev, "Unable to add Headphone Jack\n");
+			return rval;
+		}
+
+		jack = pdata->jack.jack;
+
+		snd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+		snd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);
+		snd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEUP);
+		snd_jack_set_key(jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);
+
+		snd_jack_add_new_kctl(jack, "Headphone", SND_JACK_HEADPHONE);
+		snd_jack_add_new_kctl(jack, "Headset Mic", SND_JACK_MICROPHONE);
+
+		pdata->jack_setup = true;
+	}
+
+	for_each_rtd_codec_dais(rtd, i, codec_dai) {
+		component = codec_dai->component;
+
+		/* Set default mclk for internal codec */
+		rval = snd_soc_component_set_sysclk(component, 0, 0, DEFAULT_MCLK_RATE,
+				       SND_SOC_CLOCK_IN);
+		if (rval != 0 && rval != -ENOTSUPP) {
+			dev_warn(card->dev, "Failed to set mclk: %d\n", rval);
+			return rval;
+		}
+		rval = snd_soc_component_set_jack(component, &pdata->jack, NULL);
+		if (rval != 0 && rval != -ENOTSUPP) {
+			dev_warn(card->dev, "Failed to set jack: %d\n", rval);
+			return rval;
+		}
+	}
+
+	snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_CBS_CFS);
+
+	return 0;
+}
+
+static int msm8916_qdsp6_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct msm8916_qdsp6_data *data = snd_soc_card_get_drvdata(card);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	int mi2s, ret;
+
+	mi2s = msm8916_qdsp6_get_mi2s_id(rtd);
+	if (mi2s < 0)
+		return mi2s;
+
+	if (++data->mi2s_clk_count[mi2s] > 1)
+		return 0;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, LPAIF_BIT_CLK, MI2S_BCLK_RATE, 0);
+	if (ret)
+		dev_err(card->dev, "Failed to enable LPAIF bit clk: %d\n", ret);
+	return ret;
+}
+
+static void msm8916_qdsp6_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct msm8916_qdsp6_data *data = snd_soc_card_get_drvdata(card);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	int mi2s, ret;
+
+	mi2s = msm8916_qdsp6_get_mi2s_id(rtd);
+	if (mi2s < 0)
+		return;
+
+	if (--data->mi2s_clk_count[mi2s] > 0)
+		return;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, LPAIF_BIT_CLK, 0, 0);
+	if (ret)
+		dev_err(card->dev, "Failed to disable LPAIF bit clk: %d\n", ret);
+}
+
+static const struct snd_soc_ops msm8916_qdsp6_be_ops = {
+	.startup = msm8916_qdsp6_startup,
+	.shutdown = msm8916_qdsp6_shutdown,
+};
+
+static int msm8916_qdsp6_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
+					 struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+	snd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);
+
+	return 0;
+}
+
+static void msm8916_qdsp6_add_ops(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *link;
+	int i;
+
+	for_each_card_prelinks(card, i, link) {
+		if (link->no_pcm) {
+			link->init = msm8916_qdsp6_dai_init;
+			link->ops = &msm8916_qdsp6_be_ops;
+			link->be_hw_params_fixup = msm8916_qdsp6_hw_params_fixup;
+		}
+	}
+}
+
+static int msm8916_qdsp6_platform_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_soc_card *card;
+	struct msm8916_qdsp6_data *data;
+	struct resource *res;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	card->dev = dev;
+	card->owner = THIS_MODULE;
+	card->components = "qdsp6";
+	ret = qcom_snd_parse_of(card);
+	if (ret)
+		return ret;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mic-iomux");
+	data->mic_iomux = devm_ioremap_resource(dev, res);
+	if (IS_ERR(data->mic_iomux))
+		return PTR_ERR(data->mic_iomux);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "spkr-iomux");
+	data->spkr_iomux = devm_ioremap_resource(dev, res);
+	if (IS_ERR(data->spkr_iomux))
+		return PTR_ERR(data->spkr_iomux);
+
+	snd_soc_card_set_drvdata(card, data);
+	msm8916_qdsp6_add_ops(card);
+
+	return devm_snd_soc_register_card(&pdev->dev, card);
+}
+
+static const struct of_device_id msm8916_qdsp6_device_id[]  = {
+	{ .compatible = "qcom,msm8916-qdsp6-sndcard" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, msm8916_qdsp6_device_id);
+
+static struct platform_driver msm8916_qdsp6_platform_driver = {
+	.driver = {
+		.name = "qcom-msm8916-qdsp6",
+		.of_match_table = of_match_ptr(msm8916_qdsp6_device_id),
+	},
+	.probe = msm8916_qdsp6_platform_probe,
+};
+module_platform_driver(msm8916_qdsp6_platform_driver);
+
+MODULE_AUTHOR("Minecrell <minecrell@minecrell.net>");
+MODULE_DESCRIPTION("MSM8916 QDSP6 ASoC Machine Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/Makefile b/sound/soc/qcom/qdsp6/Makefile
index 3c1dd9f32f1..eea7e123591 100644
--- a/sound/soc/qcom/qdsp6/Makefile
+++ b/sound/soc/qcom/qdsp6/Makefile
@@ -8,3 +8,6 @@ obj-$(CONFIG_SND_SOC_QDSP6_ADM) += q6adm.o
 obj-$(CONFIG_SND_SOC_QDSP6_ROUTING) += q6routing.o
 obj-$(CONFIG_SND_SOC_QDSP6_ASM) += q6asm.o
 obj-$(CONFIG_SND_SOC_QDSP6_ASM_DAI) += q6asm-dai.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE) += q6cvp.o q6cvs.o q6mvm.o q6voice-common.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE) += q6voice.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE_DAI) += q6voice-dai.o
diff --git a/sound/soc/qcom/qdsp6/q6cvp.c b/sound/soc/qcom/qdsp6/q6cvp.c
new file mode 100644
index 00000000000..3549d3f14c9
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvp.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6cvp.h"
+#include "q6voice-common.h"
+
+#define VSS_IVOCPROC_DIRECTION_RX	0
+#define VSS_IVOCPROC_DIRECTION_TX	1
+#define VSS_IVOCPROC_DIRECTION_RX_TX	2
+
+#define VSS_IVOCPROC_PORT_ID_NONE	0xFFFF
+
+#define VSS_IVOCPROC_TOPOLOGY_ID_NONE			0x00010F70
+#define VSS_IVOCPROC_TOPOLOGY_ID_TX_SM_ECNS		0x00010F71
+#define VSS_IVOCPROC_TOPOLOGY_ID_TX_DM_FLUENCE		0x00010F72
+
+#define VSS_IVOCPROC_TOPOLOGY_ID_RX_DEFAULT		0x00010F77
+
+#define VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING		0x00010F7C
+#define VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING		0x00010F7D
+
+#define VSS_ICOMMON_CAL_NETWORK_ID_NONE			0x0001135E
+
+#define VSS_IVOCPROC_CMD_ENABLE				0x000100C6
+#define VSS_IVOCPROC_CMD_DISABLE			0x000110E1
+
+#define VSS_IVOCPROC_CMD_CREATE_FULL_CONTROL_SESSION_V2	0x000112BF
+
+struct vss_ivocproc_cmd_create_full_control_session_v2_cmd {
+	struct apr_hdr hdr;
+
+	/*
+	 * Vocproc direction. The supported values:
+	 * VSS_IVOCPROC_DIRECTION_RX
+	 * VSS_IVOCPROC_DIRECTION_TX
+	 * VSS_IVOCPROC_DIRECTION_RX_TX
+	 */
+	u16 direction;
+
+	/*
+	 * Tx device port ID to which the vocproc connects. If a port ID is
+	 * not being supplied, set this to #VSS_IVOCPROC_PORT_ID_NONE.
+	 */
+	u16 tx_port_id;
+
+	/*
+	 * Tx path topology ID. If a topology ID is not being supplied, set
+	 * this to #VSS_IVOCPROC_TOPOLOGY_ID_NONE.
+	 */
+	u32 tx_topology_id;
+
+	/*
+	 * Rx device port ID to which the vocproc connects. If a port ID is
+	 * not being supplied, set this to #VSS_IVOCPROC_PORT_ID_NONE.
+	 */
+	u16 rx_port_id;
+
+	/*
+	 * Rx path topology ID. If a topology ID is not being supplied, set
+	 * this to #VSS_IVOCPROC_TOPOLOGY_ID_NONE.
+	 */
+	u32 rx_topology_id;
+
+	/* Voice calibration profile ID. */
+	u32 profile_id;
+
+	/*
+	 * Vocproc mode. The supported values:
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING
+	 */
+	u32 vocproc_mode;
+
+	/*
+	 * Port ID to which the vocproc connects for receiving echo
+	 * cancellation reference signal. If a port ID is not being supplied,
+	 * set this to #VSS_IVOCPROC_PORT_ID_NONE. This parameter value is
+	 * ignored when the vocproc_mode parameter is set to
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING.
+	 */
+	u16 ec_ref_port_id;
+
+	/*
+	 * Session name string used to identify a session that can be shared
+	 * with passive controllers (optional).
+	 */
+	char name[20];
+} __packed;
+
+struct q6voice_session *q6cvp_session_create(enum q6voice_path_type path,
+					     u16 tx_port, u16 rx_port)
+{
+	struct vss_ivocproc_cmd_create_full_control_session_v2_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IVOCPROC_CMD_CREATE_FULL_CONTROL_SESSION_V2;
+
+	/* TODO: Implement calibration */
+	cmd.tx_topology_id = VSS_IVOCPROC_TOPOLOGY_ID_TX_SM_ECNS;
+	cmd.rx_topology_id = VSS_IVOCPROC_TOPOLOGY_ID_RX_DEFAULT;
+
+	cmd.direction = VSS_IVOCPROC_DIRECTION_RX_TX;
+	cmd.tx_port_id = tx_port;
+	cmd.rx_port_id = rx_port;
+	cmd.profile_id = VSS_ICOMMON_CAL_NETWORK_ID_NONE;
+	cmd.vocproc_mode = VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
+	cmd.ec_ref_port_id = VSS_IVOCPROC_PORT_ID_NONE;
+
+	return q6voice_session_create(Q6VOICE_SERVICE_CVP, path, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6cvp_session_create);
+
+int q6cvp_enable(struct q6voice_session *cvp, bool state)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = state ? VSS_IVOCPROC_CMD_ENABLE : VSS_IVOCPROC_CMD_DISABLE;
+
+	return q6voice_common_send(cvp, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6cvp_enable);
+
+static int q6cvp_probe(struct apr_device *adev)
+{
+	return q6voice_common_probe(adev, Q6VOICE_SERVICE_CVP);
+}
+
+static const struct of_device_id q6cvp_device_id[]  = {
+	{ .compatible = "qcom,q6cvp" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6cvp_device_id);
+
+static struct apr_driver qcom_q6cvp_driver = {
+	.probe = q6cvp_probe,
+	.remove = q6voice_common_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6cvp",
+		.of_match_table = of_match_ptr(q6cvp_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6cvp_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6 Core Voice Processor");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6cvp.h b/sound/soc/qcom/qdsp6/q6cvp.h
new file mode 100644
index 00000000000..2381a3cfe07
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvp.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_CVP_H
+#define _Q6_CVP_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+struct q6voice_session *q6cvp_session_create(enum q6voice_path_type path,
+					     u16 tx_port, u16 rx_port);
+int q6cvp_enable(struct q6voice_session *cvp, bool enable);
+
+#endif /*_Q6_CVP_H */
diff --git a/sound/soc/qcom/qdsp6/q6cvs.c b/sound/soc/qcom/qdsp6/q6cvs.c
new file mode 100644
index 00000000000..440715870a0
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvs.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6cvs.h"
+#include "q6voice-common.h"
+
+static int q6cvs_probe(struct apr_device *adev)
+{
+	return q6voice_common_probe(adev, Q6VOICE_SERVICE_CVS);
+}
+
+static const struct of_device_id q6cvs_device_id[]  = {
+	{ .compatible = "qcom,q6cvs" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6cvs_device_id);
+
+static struct apr_driver qcom_q6cvs_driver = {
+	.probe = q6cvs_probe,
+	.remove = q6voice_common_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6cvs",
+		.of_match_table = of_match_ptr(q6cvs_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6cvs_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6 Core Voice Stream");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6cvs.h b/sound/soc/qcom/qdsp6/q6cvs.h
new file mode 100644
index 00000000000..5c204682c76
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvs.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_CVS_H
+#define _Q6_CVS_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+#endif /*_Q6_CVS_H */
diff --git a/sound/soc/qcom/qdsp6/q6mvm.c b/sound/soc/qcom/qdsp6/q6mvm.c
new file mode 100644
index 00000000000..b649910c817
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6mvm.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6mvm.h"
+#include "q6voice-common.h"
+
+#define VSS_IMVM_CMD_CREATE_PASSIVE_CONTROL_SESSION	0x000110FF
+
+struct vss_imvm_cmd_create_control_session_cmd {
+	struct apr_hdr hdr;
+
+	/* A variable-sized stream name. */
+	char name[20];
+} __packed;
+
+#define VSS_IMVM_CMD_SET_POLICY_DUAL_CONTROL		0x00011327
+
+/* This command is required to let MVM know who is in control of session. */
+struct vss_imvm_cmd_set_policy_dual_control_cmd {
+	struct apr_hdr hdr;
+
+	/* Set to TRUE to enable modem state machine control */
+	bool enable;
+} __packed;
+
+#define VSS_IMVM_CMD_ATTACH_VOCPROC			0x0001123E
+#define VSS_IMVM_CMD_DETACH_VOCPROC			0x0001123F
+
+/*
+ * Attach/detach a vocproc to the MVM.
+ * The MVM will symmetrically connect/disconnect this vocproc
+ * to/from all the streams currently attached to it.
+ */
+struct vss_imvm_cmd_attach_vocproc_cmd {
+	struct apr_hdr hdr;
+
+	/* Handle of vocproc being attached. */
+	u16 handle;
+} __packed;
+
+#define VSS_IMVM_CMD_START_VOICE			0x00011190
+#define VSS_IMVM_CMD_STOP_VOICE				0x00011192
+
+static inline const char *q6mvm_session_name(enum q6voice_path_type path)
+{
+	switch (path) {
+	case Q6VOICE_PATH_VOICE:
+		return "default modem voice";
+	default:
+		return NULL;
+	}
+}
+
+static int q6mvm_set_dual_control(struct q6voice_session *mvm)
+{
+	struct vss_imvm_cmd_set_policy_dual_control_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IMVM_CMD_SET_POLICY_DUAL_CONTROL;
+
+	cmd.enable = true;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+
+struct q6voice_session *q6mvm_session_create(enum q6voice_path_type path)
+{
+	struct vss_imvm_cmd_create_control_session_cmd cmd;
+	struct q6voice_session *mvm;
+	const char *session_name;
+	int ret;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IMVM_CMD_CREATE_PASSIVE_CONTROL_SESSION;
+
+	session_name = q6mvm_session_name(path);
+	if (session_name)
+		strlcpy(cmd.name, session_name, sizeof(cmd.name));
+
+	mvm = q6voice_session_create(Q6VOICE_SERVICE_MVM, path, &cmd.hdr);
+	if (IS_ERR(mvm))
+		return mvm;
+
+	ret = q6mvm_set_dual_control(mvm);
+	if (ret) {
+		dev_err(mvm->dev, "failed to set dual control: %d\n", ret);
+		q6voice_session_release(mvm);
+		return ERR_PTR(ret);
+	}
+
+	return mvm;
+}
+EXPORT_SYMBOL_GPL(q6mvm_session_create);
+
+int q6mvm_attach(struct q6voice_session *mvm, struct q6voice_session *cvp,
+		 bool state)
+{
+	struct vss_imvm_cmd_attach_vocproc_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = state ? VSS_IMVM_CMD_ATTACH_VOCPROC : VSS_IMVM_CMD_DETACH_VOCPROC;
+
+	cmd.handle = cvp->handle;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6mvm_attach);
+
+int q6mvm_start(struct q6voice_session *mvm, bool state)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = state ? VSS_IMVM_CMD_START_VOICE : VSS_IMVM_CMD_STOP_VOICE;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6mvm_start);
+
+static int q6mvm_probe(struct apr_device *adev)
+{
+	int ret;
+
+	ret = q6voice_common_probe(adev, Q6VOICE_SERVICE_MVM);
+	if (ret)
+		return ret;
+
+	return of_platform_populate(adev->dev.of_node, NULL, NULL, &adev->dev);
+}
+
+static int q6mvm_remove(struct apr_device *adev)
+{
+	of_platform_depopulate(&adev->dev);
+	return q6voice_common_remove(adev);
+}
+
+static const struct of_device_id q6mvm_device_id[]  = {
+	{ .compatible = "qcom,q6mvm" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6mvm_device_id);
+
+static struct apr_driver qcom_q6mvm_driver = {
+	.probe = q6mvm_probe,
+	.remove = q6mvm_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6mvm",
+		.of_match_table = of_match_ptr(q6mvm_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6mvm_driver);
+MODULE_DESCRIPTION("Q6 Multimode Voice Manager");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6mvm.h b/sound/soc/qcom/qdsp6/q6mvm.h
new file mode 100644
index 00000000000..51279eddb89
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6mvm.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_MVM_H
+#define _Q6_MVM_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+struct q6voice_session *q6mvm_session_create(enum q6voice_path_type path);
+
+int q6mvm_attach(struct q6voice_session *mvm, struct q6voice_session *cvp,
+		 bool state);
+int q6mvm_start(struct q6voice_session *mvm, bool state);
+
+#endif /*_Q6_MVM_H */
diff --git a/sound/soc/qcom/qdsp6/q6voice-common.c b/sound/soc/qcom/qdsp6/q6voice-common.c
new file mode 100644
index 00000000000..0c7377a64fc
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-common.c
@@ -0,0 +1,273 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6voice-common.h"
+
+#define APRV2_IBASIC_CMD_DESTROY_SESSION	0x0001003C
+
+#define TIMEOUT_MS	300
+
+struct q6voice_service {
+	struct apr_device *adev;
+	enum q6voice_service_type type;
+
+	/* Protect sessions array */
+	spinlock_t lock;
+	struct q6voice_session *sessions[Q6VOICE_PATH_COUNT];
+};
+
+/* Protect q6voice_services */
+static DEFINE_SPINLOCK(q6voice_services_lock);
+static struct q6voice_service *q6voice_services[Q6VOICE_SERVICE_COUNT] = {0};
+
+int q6voice_common_probe(struct apr_device *adev, enum q6voice_service_type type)
+{
+	struct device *dev = &adev->dev;
+	struct q6voice_service *svc, *current_svc;
+	unsigned long flags;
+
+	if (type >= Q6VOICE_SERVICE_COUNT)
+		return -EINVAL;
+
+	svc = devm_kzalloc(dev, sizeof(*svc), GFP_KERNEL);
+	if (!svc)
+		return -ENOMEM;
+
+	svc->adev = adev;
+	svc->type = type;
+	spin_lock_init(&svc->lock);
+
+	dev_set_drvdata(dev, svc);
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	current_svc = q6voice_services[type];
+	if (!current_svc)
+		q6voice_services[type] = svc;
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+
+	return current_svc ? -EEXIST : 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_probe);
+
+int q6voice_common_remove(struct apr_device *adev)
+{
+	struct q6voice_service *svc = dev_get_drvdata(&adev->dev);
+	enum q6voice_service_type type = svc->type;
+	unsigned long flags;
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	if (q6voice_services[type] == svc)
+		q6voice_services[type] = NULL;
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+
+	/* TODO: Should probably free up sessions here??? */
+	return 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_remove);
+
+static void q6voice_session_free(struct kref *ref)
+{
+	struct q6voice_session *s = container_of(ref, struct q6voice_session,
+						 refcount);
+
+	kfree(s);
+}
+
+static int q6voice_session_destroy(struct q6voice_session *s)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = APRV2_IBASIC_CMD_DESTROY_SESSION;
+
+	return q6voice_common_send(s, &cmd.hdr);
+}
+
+void q6voice_session_release(struct q6voice_session *s)
+{
+	struct q6voice_service *svc = s->svc;
+	unsigned long flags;
+
+	if (s->handle)
+		q6voice_session_destroy(s);
+
+	spin_lock_irqsave(&svc->lock, flags);
+	if (svc->sessions[s->port] == s)
+		svc->sessions[s->port] = NULL;
+	spin_unlock_irqrestore(&svc->lock, flags);
+
+	kref_put(&s->refcount, q6voice_session_free);
+}
+EXPORT_SYMBOL_GPL(q6voice_session_release);
+
+struct q6voice_session *
+q6voice_session_create(enum q6voice_service_type type,
+		       enum q6voice_path_type path, struct apr_hdr *hdr)
+{
+	struct q6voice_service *svc;
+	struct q6voice_session *s;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	svc = q6voice_services[type];
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+	if (!svc)
+		return ERR_PTR(-ENODEV);
+
+	s = kzalloc(sizeof(*s), GFP_KERNEL);
+	if (!s)
+		return ERR_PTR(-ENOMEM);
+
+	s->dev = &svc->adev->dev;
+	s->svc = svc;
+	s->port = path;
+
+	kref_init(&s->refcount);
+	spin_lock_init(&s->lock);
+	init_waitqueue_head(&s->wait);
+
+	spin_lock_irqsave(&svc->lock, flags);
+	if (svc->sessions[path]) {
+		spin_unlock_irqrestore(&svc->lock, flags);
+		kfree(s);
+		return ERR_PTR(-EBUSY);
+	}
+	svc->sessions[path] = s;
+	spin_unlock_irqrestore(&svc->lock, flags);
+
+	dev_dbg(s->dev, "create session\n");
+
+	ret = q6voice_common_send(s, hdr);
+	if (ret)
+		goto err;
+
+	if (!s->handle) {
+		dev_warn(s->dev, "failed to receive handle\n");
+		ret = -EIO;
+		goto err;
+	}
+
+	dev_dbg(s->dev, "handle: %d\n", s->handle);
+
+	return s;
+
+err:
+	q6voice_session_release(s);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(q6voice_session_create);
+
+static void q6voice_session_callback(struct q6voice_session *s,
+				     struct apr_resp_pkt *data)
+{
+	struct aprv2_ibasic_rsp_result_t *result = data->payload;
+	unsigned long flags;
+
+	if (data->hdr.opcode != APR_BASIC_RSP_RESULT)
+		return; /* Not handled here */
+
+	dev_dbg(s->dev, "basic result: opcode %#x, status: %#x\n",
+		result->opcode, result->status);
+
+	spin_lock_irqsave(&s->lock, flags);
+	if (result->opcode != s->expected_opcode) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		dev_warn(s->dev, "unexpected reply for opcode %#x (status: %#x)\n",
+			 result->opcode, result->status);
+		return;
+	}
+
+	if (!s->handle) {
+		s->handle = data->hdr.src_port;
+	} else if (s->handle != data->hdr.src_port) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		dev_warn(s->dev, "unexpected reply for session %#x (!= %#x)\n",
+			 data->hdr.src_port, s->handle);
+		return;
+	}
+
+	s->result = result->status;
+	s->expected_opcode = 0;
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	wake_up(&s->wait);
+}
+
+int q6voice_common_callback(struct apr_device *adev, struct apr_resp_pkt *data)
+{
+	struct device *dev = &adev->dev;
+	struct q6voice_service *v = dev_get_drvdata(dev);
+	struct q6voice_session *s;
+	unsigned long flags;
+
+	dev_dbg(dev, "callback: %#x\n", data->hdr.opcode);
+
+	if (data->hdr.dest_port >= Q6VOICE_PATH_COUNT) {
+		dev_warn(dev, "callback() called for unhandled/invalid path: %d\n",
+			 data->hdr.dest_port);
+		return 0;
+	}
+
+	spin_lock_irqsave(&v->lock, flags);
+	s = v->sessions[data->hdr.dest_port];
+	if (s)
+		kref_get(&s->refcount);
+	spin_unlock_irqrestore(&v->lock, flags);
+
+	if (s) {
+		q6voice_session_callback(s, data);
+		kref_put(&s->refcount, q6voice_session_free);
+	} else {
+		dev_warn(dev, "callback() called for inactive path: %d\n",
+			 data->hdr.dest_port);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_callback);
+
+int q6voice_common_send(struct q6voice_session *s, struct apr_hdr *hdr)
+{
+	unsigned long flags;
+	int ret;
+
+	hdr->hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+				       APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	hdr->src_port = s->port;
+	hdr->dest_port = s->handle;
+	hdr->token = 0;
+
+	spin_lock_irqsave(&s->lock, flags);
+	s->expected_opcode = hdr->opcode;
+	s->result = 0;
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	ret = apr_send_pkt(s->svc->adev, (struct apr_pkt *)hdr);
+	if (ret < 0)
+		return ret;
+
+	ret = wait_event_timeout(s->wait, (s->expected_opcode == 0),
+				 msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		s->expected_opcode = 0;
+		return -ETIMEDOUT;
+	}
+
+	if (s->result > 0) {
+		dev_err(s->dev, "command %#x failed with error %d\n",
+			hdr->opcode, s->result);
+		return -EIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_send);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice common session management");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice-common.h b/sound/soc/qcom/qdsp6/q6voice-common.h
new file mode 100644
index 00000000000..7db198c20d7
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-common.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_VOICE_COMMON_H
+#define _Q6_VOICE_COMMON_H
+
+#include <linux/soc/qcom/apr.h>
+#include "q6voice.h"
+
+enum q6voice_service_type {
+	Q6VOICE_SERVICE_MVM,
+	Q6VOICE_SERVICE_CVP,
+	Q6VOICE_SERVICE_CVS,
+	Q6VOICE_SERVICE_COUNT
+};
+
+struct q6voice_service;
+
+struct q6voice_session {
+	struct device *dev;
+	struct q6voice_service *svc;
+	struct kref refcount;
+
+	u16 port;
+	u16 handle;
+
+	wait_queue_head_t wait;
+
+	/* Protect expected_opcode and result */
+	spinlock_t lock;
+	u32 expected_opcode;
+	u32 result;
+};
+
+int q6voice_common_probe(struct apr_device *adev, enum q6voice_service_type type);
+int q6voice_common_remove(struct apr_device *adev);
+
+int q6voice_common_callback(struct apr_device *adev, struct apr_resp_pkt *data);
+int q6voice_common_send(struct q6voice_session *s, struct apr_hdr *hdr);
+
+struct q6voice_session *q6voice_session_create(enum q6voice_service_type type,
+					       enum q6voice_path_type path,
+					       struct apr_hdr *hdr);
+void q6voice_session_release(struct q6voice_session *s);
+
+#endif /*_Q6_VOICE_COMMON_H */
diff --git a/sound/soc/qcom/qdsp6/q6voice-dai.c b/sound/soc/qcom/qdsp6/q6voice-dai.c
new file mode 100644
index 00000000000..73401ed12b9
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-dai.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/soc.h>
+#include <dt-bindings/sound/qcom,q6voice.h>
+#include "q6voice.h"
+
+#define DRV_NAME	"q6voice-dai"
+
+static int q6voice_dai_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct q6voice *v = snd_soc_dai_get_drvdata(dai);
+
+	return q6voice_start(v, Q6VOICE_PATH_VOICE, substream->stream);
+}
+
+static void q6voice_dai_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct q6voice *v = snd_soc_dai_get_drvdata(dai);
+
+	q6voice_stop(v, Q6VOICE_PATH_VOICE, substream->stream);
+}
+
+static struct snd_soc_dai_ops q6voice_dai_ops = {
+	.startup = q6voice_dai_startup,
+	.shutdown = q6voice_dai_shutdown,
+};
+
+static struct snd_soc_dai_driver q6voice_dais[] = {
+	{
+		.id = CS_VOICE,
+		.name = "CS-VOICE",
+		/* The constraints here are not really meaningful... */
+		.playback = {
+			.stream_name =	"CS-VOICE Playback",
+			.formats =	SNDRV_PCM_FMTBIT_S16_LE,
+			.rates =	SNDRV_PCM_RATE_8000,
+			.rate_min =	8000,
+			.rate_max =	8000,
+			.channels_min =	1,
+			.channels_max =	1,
+		},
+		.capture = {
+			.stream_name =	"CS-VOICE Capture",
+			.formats =	SNDRV_PCM_FMTBIT_S16_LE,
+			.rates =	SNDRV_PCM_RATE_8000,
+			.rate_min =	8000,
+			.rate_max =	8000,
+			.channels_min =	1,
+			.channels_max =	1,
+		},
+		.ops = &q6voice_dai_ops,
+	},
+};
+
+/* FIXME: Use codec2codec instead */
+static struct snd_pcm_hardware q6voice_dai_hardware = {
+	.info =			SNDRV_PCM_INFO_INTERLEAVED,
+	.buffer_bytes_max =	4096 * 2,
+	.period_bytes_min =	2048,
+	.period_bytes_max =	4096,
+	.periods_min =		2,
+	.periods_max =		4,
+	.fifo_size =		0,
+};
+
+static int q6voice_dai_open(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream)
+{
+	substream->runtime->hw = q6voice_dai_hardware;
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget q6voice_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN("CS-VOICE_DL1", "CS-VOICE Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("CS-VOICE_UL1", "CS-VOICE Capture", 0, SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_dapm_route q6voice_dapm_routes[] = {
+	/* TODO: Make routing configurable */
+	{"CS-VOICE_UL1", NULL, "TERT_MI2S_TX"},
+	{"PRI_MI2S_RX", NULL, "CS-VOICE_DL1"},
+};
+
+static const struct snd_soc_component_driver q6voice_dai_component = {
+	.name = DRV_NAME,
+	.open = q6voice_dai_open,
+
+	.dapm_widgets = q6voice_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(q6voice_dapm_widgets),
+	.dapm_routes = q6voice_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(q6voice_dapm_routes),
+
+	/* Needs to probe after q6afe */
+	.probe_order = SND_SOC_COMP_ORDER_LATE,
+};
+
+static int q6voice_dai_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct q6voice *v;
+
+	v = q6voice_create(dev);
+	if (IS_ERR(v))
+		return PTR_ERR(v);
+
+	dev_set_drvdata(dev, v);
+
+	return devm_snd_soc_register_component(dev, &q6voice_dai_component,
+					       q6voice_dais,
+					       ARRAY_SIZE(q6voice_dais));
+}
+
+static const struct of_device_id q6voice_dai_device_id[] = {
+	{ .compatible = "qcom,q6voice-dais" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6voice_dai_device_id);
+
+static struct platform_driver q6voice_dai_platform_driver = {
+	.driver = {
+		.name = "q6voice-dai",
+		.of_match_table = of_match_ptr(q6voice_dai_device_id),
+	},
+	.probe = q6voice_dai_probe,
+};
+module_platform_driver(q6voice_dai_platform_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice DAI driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice.c b/sound/soc/qcom/qdsp6/q6voice.c
new file mode 100644
index 00000000000..2a6910d9651
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice.c
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include "q6cvp.h"
+#include "q6cvs.h"
+#include "q6mvm.h"
+#include "q6voice-common.h"
+
+/* FIXME: Remove */
+#define AFE_PORT_ID_PRIMARY_MI2S_RX         0x1000
+#define AFE_PORT_ID_PRIMARY_MI2S_TX         0x1001
+#define AFE_PORT_ID_SECONDARY_MI2S_RX       0x1002
+#define AFE_PORT_ID_SECONDARY_MI2S_TX       0x1003
+#define AFE_PORT_ID_TERTIARY_MI2S_RX        0x1004
+#define AFE_PORT_ID_TERTIARY_MI2S_TX        0x1005
+#define AFE_PORT_ID_QUATERNARY_MI2S_RX      0x1006
+#define AFE_PORT_ID_QUATERNARY_MI2S_TX      0x1007
+
+struct q6voice_path_runtime {
+	struct q6voice_session *sessions[Q6VOICE_SERVICE_COUNT];
+	unsigned int started;
+};
+
+struct q6voice_path {
+	struct q6voice *v;
+
+	enum q6voice_path_type type;
+	/* Serialize access to voice path session */
+	struct mutex lock;
+	struct q6voice_path_runtime *runtime;
+};
+
+struct q6voice {
+	struct device *dev;
+	struct q6voice_path paths[Q6VOICE_PATH_COUNT];
+};
+
+static int q6voice_path_start(struct q6voice_path *p)
+{
+	struct device *dev = p->v->dev;
+	struct q6voice_session *mvm, *cvp;
+	int ret;
+
+	dev_dbg(dev, "start path %d\n", p->type);
+
+	mvm = p->runtime->sessions[Q6VOICE_SERVICE_MVM];
+	if (!mvm) {
+		mvm = q6mvm_session_create(p->type);
+		if (IS_ERR(mvm))
+			return PTR_ERR(mvm);
+		p->runtime->sessions[Q6VOICE_SERVICE_MVM] = mvm;
+	}
+
+	cvp = p->runtime->sessions[Q6VOICE_SERVICE_CVP];
+	if (!cvp) {
+		/* FIXME: Stop hardcoding */
+		cvp = q6cvp_session_create(p->type, AFE_PORT_ID_TERTIARY_MI2S_TX,
+					   AFE_PORT_ID_PRIMARY_MI2S_RX);
+		if (IS_ERR(cvp))
+			return PTR_ERR(cvp);
+		p->runtime->sessions[Q6VOICE_SERVICE_CVP] = cvp;
+	}
+
+	ret = q6cvp_enable(cvp, true);
+	if (ret) {
+		dev_err(dev, "failed to enable cvp: %d\n", ret);
+		goto cvp_err;
+	}
+
+	ret = q6mvm_attach(mvm, cvp, true);
+	if (ret) {
+		dev_err(dev, "failed to attach cvp to mvm: %d\n", ret);
+		goto attach_err;
+	}
+
+	ret = q6mvm_start(mvm, true);
+	if (ret) {
+		dev_err(dev, "failed to start voice: %d\n", ret);
+		goto start_err;
+	}
+
+	return ret;
+
+start_err:
+	q6mvm_start(mvm, false);
+attach_err:
+	q6mvm_attach(mvm, cvp, false);
+cvp_err:
+	q6cvp_enable(cvp, false);
+	return ret;
+}
+
+int q6voice_start(struct q6voice *v, enum q6voice_path_type path, bool capture)
+{
+	struct q6voice_path *p = &v->paths[path];
+	int ret = 0;
+
+	mutex_lock(&p->lock);
+	if (!p->runtime) {
+		p->runtime = kzalloc(sizeof(*p), GFP_KERNEL);
+		if (!p->runtime) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	if (p->runtime->started & BIT(capture)) {
+		ret = -EALREADY;
+		goto out;
+	}
+
+	p->runtime->started |= BIT(capture);
+
+	/* FIXME: For now we only start if both RX/TX are active */
+	if (p->runtime->started != 3)
+		goto out;
+
+	ret = q6voice_path_start(p);
+	if (ret) {
+		p->runtime->started &= ~BIT(capture);
+		dev_err(v->dev, "failed to start path %d: %d\n", path, ret);
+		goto out;
+	}
+
+out:
+	mutex_unlock(&p->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(q6voice_start);
+
+static void q6voice_path_stop(struct q6voice_path *p)
+{
+	struct device *dev = p->v->dev;
+	struct q6voice_session *mvm = p->runtime->sessions[Q6VOICE_SERVICE_MVM];
+	struct q6voice_session *cvp = p->runtime->sessions[Q6VOICE_SERVICE_CVP];
+	int ret;
+
+	dev_dbg(dev, "stop path %d\n", p->type);
+
+	ret = q6mvm_start(mvm, false);
+	if (ret)
+		dev_err(dev, "failed to stop voice: %d\n", ret);
+
+	ret = q6mvm_attach(mvm, cvp, false);
+	if (ret)
+		dev_err(dev, "failed to detach cvp from mvm: %d\n", ret);
+
+	ret = q6cvp_enable(cvp, false);
+	if (ret)
+		dev_err(dev, "failed to disable cvp: %d\n", ret);
+}
+
+static void q6voice_path_destroy(struct q6voice_path *p)
+{
+	struct q6voice_path_runtime *runtime = p->runtime;
+	enum q6voice_service_type svc;
+
+	for (svc = 0; svc < Q6VOICE_SERVICE_COUNT; ++svc) {
+		if (runtime->sessions[svc])
+			q6voice_session_release(runtime->sessions[svc]);
+	}
+
+	p->runtime = NULL;
+	kfree(runtime);
+}
+
+int q6voice_stop(struct q6voice *v, enum q6voice_path_type path, bool capture)
+{
+	struct q6voice_path *p = &v->paths[path];
+	int ret = 0;
+
+	mutex_lock(&p->lock);
+	if (!p->runtime || !(p->runtime->started & BIT(capture)))
+		goto out;
+
+	if (p->runtime->started == 3)
+		q6voice_path_stop(p);
+
+	p->runtime->started &= ~BIT(capture);
+
+	if (p->runtime->started == 0)
+		q6voice_path_destroy(p);
+
+out:
+	mutex_unlock(&p->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(q6voice_stop);
+
+static void q6voice_free(void *data)
+{
+	struct q6voice *v = data;
+	enum q6voice_path_type path;
+
+	for (path = 0; path < Q6VOICE_PATH_COUNT; ++path) {
+		struct q6voice_path *p = &v->paths[path];
+
+		mutex_lock(&p->lock);
+		if (p->runtime) {
+			dev_warn(v->dev,
+				 "q6voice_remove() called while path %d is active\n",
+				 path);
+
+			if (p->runtime->started == 3)
+				q6voice_path_stop(p);
+			q6voice_path_destroy(p);
+		}
+		mutex_unlock(&p->lock);
+		mutex_destroy(&p->lock);
+	}
+}
+
+struct q6voice *q6voice_create(struct device *dev)
+{
+	struct q6voice *v;
+	enum q6voice_path_type path;
+	int ret;
+
+	v = devm_kzalloc(dev, sizeof(*v), GFP_KERNEL);
+	if (!v)
+		return ERR_PTR(-ENOMEM);
+
+	v->dev = dev;
+
+	for (path = 0; path < Q6VOICE_PATH_COUNT; ++path) {
+		struct q6voice_path *p = &v->paths[path];
+
+		p->v = v;
+		p->type = path;
+		mutex_init(&p->lock);
+	}
+
+	ret = devm_add_action(dev, q6voice_free, v);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return v;
+}
+EXPORT_SYMBOL_GPL(q6voice_create);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice.h b/sound/soc/qcom/qdsp6/q6voice.h
new file mode 100644
index 00000000000..b760b85ad37
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_VOICE_H
+#define _Q6_VOICE_H
+
+enum q6voice_path_type {
+	Q6VOICE_PATH_VOICE	= 0,
+	/* TODO: Q6VOICE_PATH_VOIP	= 1, */
+	/* TODO: Q6VOICE_PATH_VOLTE	= 2, */
+	/* TODO: Q6VOICE_PATH_VOICE2	= 3, */
+	/* TODO: Q6VOICE_PATH_QCHAT	= 4, */
+	/* TODO: Q6VOICE_PATH_VOWLAN	= 5, */
+	/* TODO: Q6VOICE_PATH_VOICEMMODE1	= 6, */
+	/* TODO: Q6VOICE_PATH_VOICEMMODE2	= 7, */
+	Q6VOICE_PATH_COUNT
+};
+
+struct q6voice;
+
+struct q6voice *q6voice_create(struct device *dev);
+int q6voice_start(struct q6voice *v, enum q6voice_path_type path, bool capture);
+int q6voice_stop(struct q6voice *v, enum q6voice_path_type path, bool capture);
+
+#endif /*_Q6_VOICE_H */
